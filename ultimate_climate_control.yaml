blueprint:
  name: Ultimate Smart Climate Control - v5.0.2

  description: |
    **Ultimate Smart Climate Control v5.0.2**

    üå°Ô∏è The most advanced Home Assistant climate automation with intelligent presence detection, dynamic fan control, outside temperature compensation, and 40-60% energy savings.

    **üìã VERSION UPDATES:**

    **v5.0.2 - Removed Legacy Hardware Delay Setting:**
    ‚Ä¢ **Removed Hardware Response Delay** - Obsolete setting from old timing-based detection (snapshot system doesn't need it!)
    ‚Ä¢ **Simplified Configuration** - One less confusing setting in the UI
    ‚Ä¢ **No Functional Changes** - Snapshot detection already eliminated hardware timing dependencies

    **v5.0.1 - Code Cleanup & Simplification:**
    ‚Ä¢ **Simplified Variable Names** - Removed "new" prefix from `manual_override_detection`
    ‚Ä¢ **Cleaner Codebase** - Removed deprecated variables and outdated version tags

    **v5.0.0 Major Release:**
    ‚Ä¢ **99% Reduction in False Override Detections** - Snapshot-based detection system eliminates timing assumptions
    ‚Ä¢ **BRP084 Firmware Optimized** - Proper service call sequencing for all Daikin firmware types
    ‚Ä¢ **"Always Send" Paradigm** - Commands sent every periodic check for perfect state synchronization
    ‚Ä¢ **10-100x Faster Override Detection** - Instant snapshot comparison (10-120s ‚Üí 1-5s)

    ---

    ## üöÄ EASY SETUP - Use the Setup Wizard!

    **‚ö†Ô∏è Don't create helpers manually!** Install the companion **Setup Wizard** for automated setup:

    ‚úÖ **2-Minute Setup** - Complete automation in ~2 minutes
    ‚úÖ **Zero Manual Work** - All 20 helpers created automatically (1 new in v3.16.0)
    ‚úÖ **Dashboard Card Generator** - Animated control card included
    ‚úÖ **Safe & Isolated** - Package-based helpers won't affect existing setup

    **Install via HACS:**
    Settings ‚Üí HACS ‚Üí Integrations ‚Üí ‚ãÆ Menu ‚Üí Custom Repositories
    Add: `https://github.com/Chris971991/Smart-Climate-Control` (Category: Integration)

    *Advanced users can still create helpers manually - see [Documentation](https://github.com/Chris971991/Smart-Climate-Control)*

    ---

    ## ‚ú® Key Features

    **üéÆ 4 Control Modes:**
    - **Auto:** House-wide automation with home/away detection
    - **Smart:** Room-specific presence with BLE/PIR/mmWave sensors (immediate shutoff when leaving)
    - **Manual:** Full user control with emergency temperature overrides only
    - **Override:** (Auto-set) User manually changed AC - automation paused temporarily

    **üß† Intelligent Automation:**
    - Room-specific presence detection (BLE, motion, door sensors, adjacent room support)
    - Dynamic 5-level fan escalation based on actual effectiveness (Level 1‚Üí5)
    - Temperature stability auto-off (prevents wasted runtime)
    - Proximity pre-conditioning (cools/heats before you arrive home)
    - Near-target stall detection (pushes through final degrees)
    - Accurate presence confirmation delays (no more false timer accumulation!)
    - Enhanced manual override detection (temp, fan, swing, HVAC mode changes)

    **‚ö° Energy Efficiency:**
    - 40-60% energy savings vs always-on operation
    - Smart hysteresis prevents short-cycling and equipment wear
    - Unified cooling/heating modes with dynamic escalation (L0-L4)
    - Eco mode for unoccupied rooms (off/eco/maintain options)
    - Comfort zone idle (no unnecessary cooling/heating)

    **üîß Advanced Capabilities:**
    - Universal A/C compatibility (auto-detects HVAC modes, fan speeds, swing modes)
    - Multi-zone support (control 1 or multiple units simultaneously)
    - **NEW v3.2.0:** Outside Temperature Compensation (makes AC work HARDER on extreme days to ACHIEVE your target)
    - Time-based scheduling (morning/day/evening/night + weekends)
    - Window detection with auto-shutoff
    - **ENHANCED v3.3.0:** Comprehensive manual override (detects all parameter changes via HA UI or remote)

    ---

    ## üÜï Latest Updates

    **v4.6.14 - CRITICAL: Legacy 3-Tier Modes Service Call Order (Comprehensive Fix)**
    - üêõ **FIXED**: All 4 legacy 3-tier modes now send fan_mode FIRST, then temperature
    - üîß **MODES FIXED**: Cooling LOW, Cooling MEDIUM, Heating LOW, Heating MEDIUM
    - ‚úÖ **IMPACT**: 76% of service calls had wrong order - now all legacy modes corrected
    - üéØ **RESULT**: Daikin AC responds correctly to fan speed changes in all legacy escalation modes

    **v4.6.13 - CRITICAL: Continue Mode Service Call Order (Daikin Integration)**
    - üêõ **FIXED**: Continue mode now sends fan_mode FIRST, then temperature
    - üîß **ROOT CAUSE**: climate.set_temperature does GET (reads old f_rate) before POST
    - ‚úÖ **SOLUTION**: Set fan first so subsequent GET reads correct fan rate

    **v4.6.12 - CRITICAL: Continue Mode Fan Selection Ignoring Escalation**
    - üêõ **FIXED**: Continue mode now respects escalation level for fan speed selection
    - ‚ö° **IMPROVED**: Fan speed uses HIGHER of effectiveness-based OR escalation-based level

    **v4.6.9 - REMOVED: Redundant Overshoot Action Feature**
    - üóëÔ∏è **REMOVED**: overshoot_action input (duplicate of existing comfort_zone_action)
    - ‚úÖ **UNIFIED**: Use existing "Action When Comfort Zone Edge Reached" feature instead

    **v4.6.8 - CRITICAL: Bed Comfort ECO + Overshoot Conflict Resolution**
    - üêõ **FIXED**: Bed ECO blocked after overshoot fan-only activated
    - üõ°Ô∏è **SAFETY**: Overshoot turn-off now respects bed sensor (never turns off AC while user sleeping)

    üìñ **[Full Changelog & Version History](https://github.com/Chris971991/Smart-Climate-Control/releases)**

    ---

    **Blueprint Direct Import:** `https://github.com/Chris971991/Smart-Climate-Control/blob/main/ultimate_climate_control.yaml`
  domain: automation
  source_url: https://github.com/Chris971991/Smart-Climate-Control/blob/main/ultimate_climate_control.yaml
  input:
    # Basic required settings (always visible)
    room_name:
      name: Room Name *
      description: |
        **Enter the name of this room** for logging and BLE detection.
        
        **Used for:**
        ‚Ä¢ **Debug logging:** Prefixes all log entries with room name
        ‚Ä¢ **BLE triangulation:** Must match sensor output exactly for presence detection
        ‚Ä¢ **Multi-room setup:** Helps distinguish between different AC automations
        
        **Examples:** "Office", "Living Room", "Master Bedroom"
        
        **Important:** If using BLE sensors, check sensor state in Developer Tools for exact string
      selector:
        text:
    
    climate_entities:
      name: Climate Entities *
      description: |
        Select one or more **climate entities** to control with this automation.

        **Supported devices:** All types of A/C units, heat pumps, and climate control devices.
      selector:
        entity:
          multiple: true
          domain: climate
    
    helper_last_mode:
      name: Last Mode Helper Entity *
      description: |
        Input Text helper to track the **last active climate mode**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_text.climate_last_mode_living_room`

        ‚Ä¢ `input_text.climate_last_mode_bedroom`

        ‚Ä¢ `input_text.climate_last_mode_office`

        **Important:** This helper stores state information for proper automation behavior.
      selector:
        entity:
          domain: input_text
    
    helper_last_change:
      name: Last Change Helper Entity *
      description: |
        Input DateTime helper to track **when climate changes occurred**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_datetime.climate_last_change_living_room`

        ‚Ä¢ `input_datetime.climate_last_change_bedroom`

        ‚Ä¢ `input_datetime.climate_last_change_office`

        **Used for:** Timing calculations and false detection protection (2-minute buffer).
      selector:
        entity:
          domain: input_datetime

    helper_mode_before_override:
      name: Mode Before Override Helper *
      description: |
        Input Text helper to store **which mode was active before Override**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_text.climate_mode_before_override_living_room`

        ‚Ä¢ `input_text.climate_mode_before_override_bedroom`

        ‚Ä¢ `input_text.climate_mode_before_override_office`

        **Purpose:** Stores "Auto" or "Smart" so when Override timeout expires or is cleared, the system returns to the correct mode.

        **Note:** This replaces the old separate override flag + timestamp helpers with a simpler approach.
      selector:
        entity:
          domain: input_text

    helper_override_time:
      name: Override Start Time Helper *
      description: |
        Input DateTime helper to track **when Override mode was activated**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_datetime.climate_override_time_living_room`

        ‚Ä¢ `input_datetime.climate_override_time_bedroom`

        ‚Ä¢ `input_datetime.climate_override_time_office`

        **Purpose:** Timestamp used to calculate if override timeout period has expired and system should return to previous mode.
      selector:
        entity:
          domain: input_datetime

    helper_override_active:
      name: Override Active Visual Indicator *
      description: |
        Input Boolean helper for **visual override indicator** in dashboards.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_boolean.climate_override_active_living_room`

        ‚Ä¢ `input_boolean.climate_override_active_bedroom`

        ‚Ä¢ `input_boolean.climate_override_active_master_bedroom`

        **Purpose:** Provides visual feedback in UI cards when Override mode is active. Automatically synced with Override mode state.

        **Note:** This is for display only - the actual Override mode is controlled by the control mode select helper.
      selector:
        entity:
          domain: input_boolean

    helper_override_timeout:
      name: Override Timeout Duration Helper
      description: |
        Input Number helper to store **override timeout duration** (in hours).

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_number.climate_override_timeout_living_room`

        ‚Ä¢ `input_number.climate_override_timeout_bedroom`

        ‚Ä¢ `input_number.climate_override_timeout_office`

        **Purpose:** Stores the timeout duration from blueprint config for use in dashboard countdown timers.

        **Note:** This is updated automatically when Override mode activates - do not manually edit.
      selector:
        entity:
          domain: input_number
      default: ""

    helper_expected_temp:
      name: Expected Temperature Helper *
      description: |
        Input Number helper to track **expected temperature setpoint**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_number.climate_expected_temp_living_room`

        ‚Ä¢ `input_number.climate_expected_temp_bedroom`

        ‚Ä¢ `input_number.climate_expected_temp_office`

        **Purpose:** Enhanced manual override detection - tracks what temperature automation expects vs actual AC setpoint.

        **Required for:** Detecting user temperature changes via HA UI or physical remote (e.g., 20¬∞C ‚Üí 24¬∞C).
      selector:
        entity:
          domain: input_number

    helper_expected_fan:
      name: Expected Fan Mode Helper *
      description: |
        Input Text helper to track **expected fan mode**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_text.climate_expected_fan_living_room`

        ‚Ä¢ `input_text.climate_expected_fan_bedroom`

        ‚Ä¢ `input_text.climate_expected_fan_office`

        **Purpose:** Enhanced manual override detection - tracks what fan mode automation expects vs actual AC fan mode.

        **Required for:** Detecting user fan speed changes via HA UI or physical remote (e.g., Fan 3 ‚Üí Fan 5).
      selector:
        entity:
          domain: input_text

    helper_expected_swing:
      name: Expected Swing Mode Helper *
      description: |
        Input Text helper to track **expected swing mode**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_text.climate_expected_swing_living_room`

        ‚Ä¢ `input_text.climate_expected_swing_bedroom`

        ‚Ä¢ `input_text.climate_expected_swing_office`

        **Purpose:** Enhanced manual override detection - tracks what swing mode automation expects vs actual AC swing mode.

        **Required for:** Detecting user swing mode changes via HA UI or physical remote (e.g., vertical ‚Üí horizontal).
      selector:
        entity:
          domain: input_text

    helper_expected_hvac:
      name: Expected HVAC Mode Helper *
      description: |
        Input Text helper to track **expected HVAC mode**.

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_text.climate_expected_hvac_living_room`

        ‚Ä¢ `input_text.climate_expected_hvac_bedroom`

        ‚Ä¢ `input_text.climate_expected_hvac_office`

        **Purpose:** Enhanced manual override detection - tracks what HVAC mode automation expects vs actual AC mode.

        **Required for:** Detecting user HVAC mode changes via HA UI or physical remote (e.g., cool ‚Üí heat).
      selector:
        entity:
          domain: input_text

    # =====================================
    # STATE MACHINE HELPERS (v5.0.0 Redesign)
    # =====================================

    helper_state_machine:
      name: Climate State Machine
      description: |
        Input Select helper to track **current automation state** (v5.0.0+ redesign).

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_select.climate_state_machine_living_room`

        ‚Ä¢ `input_select.climate_state_machine_bedroom`

        ‚Ä¢ `input_select.climate_state_machine_office`

        **Purpose:** Single source of truth for what automation thinks it's doing.

        **States:** AUTOMATION_OFF, AUTOMATION_COOLING, AUTOMATION_HEATING, AUTOMATION_ECO, AUTOMATION_FAN_ONLY, MANUAL_OVERRIDE_ACTIVE, PRESENCE_TIMEOUT, LOCKED

        **Required for:** v5.0.0 state machine-based override detection system.
      default: ""
      selector:
        entity:
          domain: input_select

    helper_state_start:
      name: State Start Time
      description: |
        Input DateTime helper to track **when current state began** (v5.0.0+ redesign).

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_datetime.climate_state_start_living_room`

        ‚Ä¢ `input_datetime.climate_state_start_bedroom`

        ‚Ä¢ `input_datetime.climate_state_start_office`

        **Purpose:** Timestamp when current state began (for timeout logic only).

        **Required for:** v5.0.0 override timeout calculations.
      default: ""
      selector:
        entity:
          domain: input_datetime

    helper_last_command:
      name: Last Command Snapshot
      description: |
        Input Text helper to store **complete snapshot of last automation command** (v5.0.0+ redesign).

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_text.climate_last_command_living_room`

        ‚Ä¢ `input_text.climate_last_command_bedroom`

        ‚Ä¢ `input_text.climate_last_command_office`

        **Purpose:** Complete snapshot of what automation LAST commanded.

        **Format:** `hvac=cool,temp=22.5,fan=Level3,swing=both`

        **Required for:** v5.0.0 deterministic override detection (no timing assumptions).
      default: ""
      selector:
        entity:
          domain: input_text

    helper_state_checksum:
      name: State Checksum
      description: |
        Input Number helper to store **MD5 hash of AC state** for fast change detection (v5.0.0+ redesign).

        **Create a unique helper for each room/automation instance:**

        ‚Ä¢ `input_number.climate_state_checksum_living_room`

        ‚Ä¢ `input_number.climate_state_checksum_bedroom`

        ‚Ä¢ `input_number.climate_state_checksum_office`

        **Purpose:** MD5 hash of complete AC state for instant detection (<1ms).

        **Required for:** v5.0.0 fast override detection system.
      default: ""
      selector:
        entity:
          domain: input_number

    # Manual Override Detection Settings
    manual_override_settings:
      name: "Manual Override Detection Settings"
      icon: mdi:hand-back-right
      collapsed: true
      input:
        enable_manual_override_detection:
          name: Enable Manual Override Detection
          description: |
            **Detect when you manually change AC settings** and temporarily pause automation.

            **How it works:**
            When you change temperature, fan speed, or turn AC on/off via HA app, dashboard,
            or physical remote, automation detects this and enters **Override mode**.

            **Override mode:**
            ‚Ä¢ Pauses temperature/fan adjustments for the configured timeout
            ‚Ä¢ Respects your manual settings
            ‚Ä¢ Automatically returns to previous mode after timeout

            **When to disable:**
            ‚Ä¢ If you have other automations controlling the same AC
            ‚Ä¢ If you're getting false override detections
            ‚Ä¢ For testing purposes

            **Recommended:** Keep enabled for normal use.
          default: true
          selector:
            boolean:


    # Debugging & Logging Settings
    debugging_settings:
      name: "Debugging & Logging Settings"
      icon: mdi:message-text
      collapsed: true
      input:
        enable_event_logging:
          name: "Event Logging (Recommended: Keep ON)"
          description: |
            üü¢ **RECOMMENDED: Keep this enabled for easy troubleshooting!**

            **Logs important events when AC turns on/off or manual override is detected.**

            **What you'll see:**
            ‚Ä¢ üü¢ AC Activation logs - Why AC turned on (temperature, mode, reason)
            ‚Ä¢ üî¥ AC Deactivation logs - Why AC turned off (target reached, presence timeout, etc.)
            ‚Ä¢ üü° Manual Override logs - When you manually change AC settings

            **Benefits:**
            ‚Ä¢ ‚úÖ Understand why your AC turned on at 3am
            ‚Ä¢ ‚úÖ Debug issues without enabling verbose logging
            ‚Ä¢ ‚úÖ See manual override detection in real-time
            ‚Ä¢ ‚úÖ Minimal log spam (only on state changes)

            **Performance Impact:** Very low (only logs on actual events)

            **View logs:** Settings ‚Üí System ‚Üí Logs (search for your room name)

            **Recommendation:** Leave this ON unless you want completely silent operation.
          default: true
          selector:
            boolean:

        enable_full_debug_logging:
          name: "Full Debug Logging (Troubleshooting Only)"
          description: |
            ‚ö†Ô∏è **WARNING: Creates MANY log entries - enable only when troubleshooting!**

            **Enables extensive debug logging for deep troubleshooting.**

            **What you'll see:**
            ‚Ä¢ üîç Every condition evaluation (true/false checks)
            ‚Ä¢ üîç Variable states at decision points
            ‚Ä¢ üîç Temperature calculations and thresholds
            ‚Ä¢ üîç Presence detection logic
            ‚Ä¢ üîç Effectiveness tracking details
            ‚Ä¢ üîç Escalation/de-escalation reasoning
            ‚Ä¢ üîç Fan speed selection logic
            ‚Ä¢ üîç Continue mode decision-making

            **Performance Impact:** Moderate (logs every periodic check)

            **When to enable:**
            ‚Ä¢ ‚úÖ Diagnosing complex automation issues
            ‚Ä¢ ‚úÖ Understanding why specific conditions aren't met
            ‚Ä¢ ‚úÖ Debugging effectiveness tracking problems
            ‚Ä¢ ‚úÖ Investigating unexpected behavior

            **When to disable:**
            ‚Ä¢ ‚ùå Normal operation (generates too many logs)
            ‚Ä¢ ‚ùå Once issue is identified and resolved

            **Recommendation:** Keep this OFF unless actively troubleshooting.
          default: false
          selector:
            boolean:

    # Temperature Settings - Simple Mode
    temperature_settings:
      name: "Temperature Settings"
      icon: mdi:thermometer
      collapsed: false
      input:
        temperature_sensor:
          name: Temperature Sensor(s) (Optional)
          description: |
            External temperature sensor(s) for **more accurate room temperature readings**.

            **NEW v3.9.0:** Supports **multiple sensors** for rooms cooled/heated by one AC unit!

            If not configured, the system will use your A/C unit's built-in sensor.

            **Multi-Sensor Strategy (automatic):**
            ‚Ä¢ **Cooling Mode:** Uses WARMEST room (ensures all rooms cool down)
            ‚Ä¢ **Heating Mode:** Uses COLDEST room (ensures all rooms warm up)
            ‚Ä¢ **Both/Neither:** Uses AVERAGE temperature

            **Example:** Living Room AC also cools Media Room
            ‚Üí Add both room sensors ‚Üí System ensures both reach target temperature

            **Best practices for external sensors:**

            ‚Ä¢ Place at seated height (1-1.5m from floor)
            ‚Ä¢ Position away from direct sunlight and heat sources
            ‚Ä¢ Central location in the room for representative readings
            ‚Ä¢ Avoid drafty areas or corners

            **Benefit:** External sensors provide significantly better temperature control accuracy.
          default: []
          selector:
            entity:
              domain: sensor
              device_class: temperature
              multiple: true
        
        use_average_temperature:
          name: Use Average Temperature
          description: |
            Controls how temperature is calculated when using **multiple A/C units**.

            ‚Ä¢ **ON:** Average temperatures from all A/C units
            ‚Ä¢ **OFF:** Use temperature from the first A/C unit only

            **Important:** Turn OFF when using a single external sensor for all units to avoid conflicts.
          default: true
          selector:
            boolean:
        
        # SIMPLE CONTROLS (Always visible)
        target_temperature:
          name: üéØ Target Temperature
          description: |
            Your **ideal room temperature** in degrees Celsius.

            This is the **main temperature control** that affects all other zones proportionally.

            Adjusting this value will shift all temperature thresholds up or down together.

            **Auto mode target:** This is where the system will maintain temperature.
          default: 23
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
              mode: slider
        
        comfort_zone_width:
          name: üìè Comfort Zone Range
          description: |
            Temperature variation tolerance around target **(¬±¬∞C)**:

            ‚Ä¢ **Wider** = more tolerance, less switching, more efficient
            ‚Ä¢ **Narrower** = tighter control, more activity, less efficient

            **Example:** Target 23¬∞C with ¬±2¬∞C = comfort zone 21-25¬∞C (saves 40-60% power)
          default: 2
          selector:
            number:
              min: 0.5
              max: 3
              step: 0.1
              unit_of_measurement: "¬∞C"
              mode: slider

        target_overshoot_strategy:
          name: üéØ Target Overshoot Strategy
          description: |
            **How far past target temperature** should AC run before turning off?

            Overshooting creates a buffer zone that prevents rapid on/off cycling while maintaining comfort.

            ‚Ä¢ **None:** No overshoot - Turns off exactly at target temp ‚ö†Ô∏è **May cause rapid cycling**
            ‚Ä¢ **Minimal:** 0.5¬∞C past target - Precise control, may cycle more often in extreme conditions
            ‚Ä¢ **Moderate:** Halfway to comfort zone edge - Balanced comfort and efficiency ‚≠ê **RECOMMENDED**
            ‚Ä¢ **Maximum:** Full comfort zone edge - Maximum cycling prevention, larger temperature swings

            **Example with target 22.5¬∞C, comfort zone 21.1-23.9¬∞C:**
            ‚Ä¢ Cooling stops at: **22.5¬∞C** (none) / **22.0¬∞C** (minimal) / **21.8¬∞C** (moderate) / **21.1¬∞C** (maximum)
            ‚Ä¢ Heating stops at: **22.5¬∞C** (none) / **23.0¬∞C** (minimal) / **23.2¬∞C** (moderate) / **23.9¬∞C** (maximum)

            **When to use:**
            ‚Ä¢ **None:** Only if you understand cycling risks and want pure target-based operation
            ‚Ä¢ **Minimal:** Bedrooms, offices where precise temp control is critical
            ‚Ä¢ **Moderate:** Most rooms - best balance (default)
            ‚Ä¢ **Maximum:** High thermal load rooms, extreme outdoor temps, or frequent cycling issues
          default: moderate
          selector:
            select:
              options:
                - label: "None (No overshoot - ‚ö†Ô∏è May cause rapid cycling)"
                  value: "none"
                - label: "Minimal (0.5¬∞C overshoot)"
                  value: "minimal"
                - label: "Moderate (Halfway to comfort edge) - RECOMMENDED"
                  value: "moderate"
                - label: "Maximum (Full comfort zone)"
                  value: "maximum"

        enable_heating_mode:
          name: üî• Enable Heating Mode
          description: |
            **Control whether heating activates** when temperature drops below comfort zone.
            
            ‚Ä¢ **ON:** Heating will activate when room gets cold (full climate control)
            ‚Ä¢ **OFF:** Heating disabled - cooling only (perfect for people who run hot)
            
            **Use cases:** Seasonal control, energy management, personal preference, cooling-only setups.
          default: true
          selector:
            boolean:
        
        enable_cooling_mode:
          name: ‚ùÑÔ∏è Enable Cooling Mode
          description: |
            **Control whether cooling activates** when temperature rises above comfort zone.
            
            ‚Ä¢ **ON:** Cooling will activate when room gets warm (full climate control)
            ‚Ä¢ **OFF:** Cooling disabled - heating only (perfect for cold climates)
            
            **Use cases:** Seasonal control, energy management, heating-only setups, winter operation.
          default: true
          selector:
            boolean:
        
        temperature_aggressiveness:
          name: ‚ö° Response Aggressiveness
          description: |
            **Controls how quickly the AC reaches maximum power** when temperature goes outside comfort zone.

            **What this actually does:**
            - Higher values = AC ramps to HIGH/MAX cooling faster = reaches target temp quicker
            - Lower values = AC escalates gradually through LOW‚ÜíMEDIUM‚ÜíHIGH = more efficient but slower

            **Settings explained:**

            ‚Ä¢ **1 = Gentle** - AC won't hit maximum power until 3¬∞C past comfort zone
              ‚îî‚îÄ Most efficient, but AC may run for hours on low power

            ‚Ä¢ **2 = Smooth** (Default) - Medium power at comfort edge, high at +1¬∞C, max at +2¬∞C
              ‚îî‚îÄ Balanced approach for most situations

            ‚Ä¢ **3 = Balanced** - Maximum power kicks in at 2¬∞C past comfort zone
              ‚îî‚îÄ Good balance between speed and efficiency

            ‚Ä¢ **5 = Aggressive** - Maximum power immediately at 1¬∞C past comfort zone
              ‚îî‚îÄ Fastest response, reaches target quickly, uses more power

            **Real Example** (Target: 23¬∞C, Comfort Zone: ¬±2¬∞C = 21-25¬∞C):

            **With Aggressiveness = 2 (Default):**
            - 21-25¬∞C ‚Üí AC OFF (in comfort zone)
            - 25.1¬∞C ‚Üí LOW cooling starts
            - 26¬∞C ‚Üí MEDIUM cooling (+1¬∞C past edge)
            - 27¬∞C ‚Üí HIGH cooling (+2¬∞C past edge)

            **With Aggressiveness = 5 (Aggressive):**
            - 21-25¬∞C ‚Üí AC OFF (in comfort zone)
            - 25.1¬∞C ‚Üí LOW cooling starts
            - 26¬∞C ‚Üí HIGH cooling already! (+1¬∞C triggers max power)

            **üí° Choose based on your priority:**
            - AC running too long trying to reach target? ‚Üí Increase to 3-5
            - Want maximum efficiency and don't mind slower response? ‚Üí Use 1-2
          default: 2
          selector:
            number:
              min: 1
              max: 5
              step: 1
              mode: slider
        
        # ADVANCED OVERRIDES (Hidden by default)
        enable_advanced_temp:
          name: üîß Enable Advanced Temperature Controls
          description: |
            Manually override **individual temperature thresholds**.

            ‚Ä¢ For users who want **precise control** over all thresholds
            ‚Ä¢ Overrides automatic calculations based on target temperature
            ‚Ä¢ Allows fine-tuning of comfort zones and trigger points

            **Recommendation:** Most users should leave this disabled and use the base target temperature.
          default: false
          selector:
            boolean:
        
        # These are only shown when advanced mode is enabled
        comfort_min_temp:
          name: Comfort Zone Minimum (Advanced)
          description: |
            Override auto-calculated **minimum comfort temperature**.

            ‚Ä¢ **Bottom of comfort zone** where heating may start
            ‚Ä¢ Should be lower than comfort maximum
            ‚Ä¢ Typically 1-2¬∞C below target temperature

            **Behavior:** When room is above this, system stays in eco/off mode.
          default: 21
          selector:
            number:
              min: 18
              max: 25
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        comfort_max_temp:
          name: Comfort Zone Maximum (Advanced)
          description: |
            Override auto-calculated **maximum comfort temperature**.

            ‚Ä¢ **Top of comfort zone** where cooling may start
            ‚Ä¢ Should be higher than comfort minimum
            ‚Ä¢ Typically 1-2¬∞C above target temperature

            **Behavior:** When room is below this, system stays in eco/off mode.
          default: 23
          selector:
            number:
              min: 20
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        cooling_target_temp:
          name: Cooling Target (Advanced)
          description: |
            Override **cooling target temperature**.

            ‚Ä¢ **What temperature to cool the room to**
            ‚Ä¢ Used when room exceeds comfort maximum
            ‚Ä¢ Usually same as or slightly below base target

            **Behavior:** System will cool to this temperature then switch to eco/off.
          default: 22
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        heating_target_temp:
          name: Heating Target (Advanced)
          description: |
            Override **heating target temperature**.

            ‚Ä¢ **What temperature to heat the room to**
            ‚Ä¢ Used when room falls below comfort minimum
            ‚Ä¢ Usually same as or slightly above base target

            **Behavior:** System will heat to this temperature then switch to eco/off.
          default: 23
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        precool_target_temp:
          name: Pre-cooling Target (Advanced)
          description: |
            Override **pre-conditioning target temperature**.

            ‚Ä¢ **Temperature to achieve before you arrive home**
            ‚Ä¢ Used with proximity sensors and approaching detection
            ‚Ä¢ Should be comfortable for immediate occupancy

            **Recommendation:** Usually matches your preferred target temperature.
          default: 22
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"

    # Presence & Proximity Settings
    presence_settings:
      name: "Presence & Proximity"
      icon: mdi:account-multiple
      collapsed: true
      input:
        presence_persons:
          name: People to Track
          description: |
            Select people for **presence detection**.

            ‚Ä¢ **Used for away mode detection**
            ‚Ä¢ Triggers pre-conditioning when approaching home
            ‚Ä¢ Works with proximity/direction sensors for advanced features
          default: []
          selector:
            entity:
              multiple: true
              domain: person
        
        presence_devices:
          name: Presence Detection Devices
          description: |
            Additional devices indicating presence when **person entities aren't sufficient**.

            **Examples:**

            ‚Ä¢ PC power state sensors
            ‚Ä¢ Smart TV power sensors
            ‚Ä¢ Gaming console entities
            ‚Ä¢ Workstation activity sensors

            **Purpose:** These supplement person presence detection for more accurate home/away detection.
          default: []
          selector:
            entity:
              multiple: true
        
        proximity_sensor:
          name: Proximity Distance Sensor
          description: |
            Sensor tracking **nearest person's distance from home**.

            ‚Ä¢ **Used for proximity-based pre-conditioning**
            ‚Ä¢ Works with direction sensor for smart approach detection
            ‚Ä¢ **Example:** `sensor.home_nearest_distance`

            **Requirement:** Home Assistant proximity integration setup.
          default: sensor.home_nearest_distance
          selector:
            entity:
              domain: sensor
        
        direction_sensor:
          name: Direction of Travel Sensor
          description: |
            Sensor tracking **direction of travel** relative to home.

            **States:**

            ‚Ä¢ **towards:** Approaching home
            ‚Ä¢ **away:** Moving away from home
            ‚Ä¢ **arrived:** At home location

            **Example:** `sensor.home_nearest_direction_of_travel`
          default: sensor.home_nearest_direction_of_travel
          selector:
            entity:
              domain: sensor
        
        home_zone_distance:
          name: Home Zone Distance
          description: |
            Distance defining your **"home zone" boundary**. Controls all proximity behaviors:

            ‚Ä¢ **Within this distance:** Maintain comfort temperature, pre-condition when approaching
            ‚Ä¢ **Beyond this distance:** Switch to away mode (off or eco mode)
          default: 5000
          selector:
            number:
              min: 1000
              max: 10000
              step: 500
              unit_of_measurement: m

    # Away Mode Settings
    away_settings:
      name: "Away Mode Settings"
      icon: mdi:home-export-outline
      collapsed: true
      input:
        enable_away_mode:
          name: Enable Away Mode
          description: |
            **Turn off or set to eco** when everyone leaves.

            Automatically manages climate control based on home occupancy for **energy savings**.
          default: true
          selector:
            boolean:
        
        away_mode_action:
          name: Away Mode Action
          description: |
            What to do when **everyone leaves home**:

            ‚Ä¢ **OFF:** Turn AC completely off (saves most energy, slow to cool when returning)
            ‚Ä¢ **ECO:** Reduce to eco mode with wider temperature range (balanced energy savings)
            ‚Ä¢ **MAINTAIN:** Keep current temperature (wastes energy but fastest comfort when returning)
          default: "eco"
          selector:
            select:
              options:
                - "off"
                - "eco"
                - "maintain"
        
        enable_pre_conditioning:
          name: Enable Pre-conditioning
          description: |
            **Pre-cool/heat when approaching home**.

            Uses proximity sensors to start conditioning before arrival for **immediate comfort**.
          default: true
          selector:
            boolean:

    # Smart Mode Settings
    smart_mode_settings:
      name: "Smart Mode Settings"
      icon: mdi:brain
      collapsed: true
      input:
        helper_control_mode:
          name: Control Mode Helper Entity
          description: |
            Input Select helper for **control mode selection**.

            **Required options:**

            ‚Ä¢ **Auto:** Temperature-based control
            ‚Ä¢ **Manual:** User-controlled operation
            ‚Ä¢ **Smart:** Advanced presence-aware control
            ‚Ä¢ **Override:** (Auto-set) User manually changed AC settings - automation paused

            **Example:** `input_select.climate_control_mode_living_room`

            **Note:** "Override" mode is automatically activated when the blueprint detects manual AC control via HA UI or remote. It will revert to your previous mode after the configured timeout.
          selector:
            entity:
              domain: input_select
        
        helper_presence_detected:
          name: Last Presence Helper Entity
          description: |
            **Input DateTime helper** to track when presence was last detected.

            ‚Ä¢ **Used for** presence timeout calculations
            ‚Ä¢ **Updated automatically** by the system
            ‚Ä¢ **Required** for Smart Mode functionality

            **Example:** `input_datetime.presence_last_detected_living_room`
          selector:
            entity:
              domain: input_datetime
        
        helper_proximity_override:
          name: Proximity Override Helper Entity
          description: |
            **Input Boolean helper** for emergency temperature override.

            ‚Ä¢ **Bypasses all automation** when enabled
            ‚Ä¢ **Allows manual control** during emergencies
            ‚Ä¢ **Auto-resets** after specified duration

            **Example:** `input_boolean.climate_proximity_override_living_room`
          selector:
            entity:
              domain: input_boolean

        helper_presence_validation_active:
          name: Presence Validation State Helper Entity
          description: |
            **Input Boolean helper** to track presence validation state transitions.

            ‚Ä¢ **Tracks** when room_presence_detected changes from FALSE to TRUE
            ‚Ä¢ **Prevents** false timer accumulation from partial sensor triggers
            ‚Ä¢ **Required** for accurate presence confirmation delays
            ‚Ä¢ **NEW in v3.16.0** - fixes timer accumulation bug

            **Example:** `input_boolean.climate_presence_validation_active_master_bedroom`
          selector:
            entity:
              domain: input_boolean

        presence_timeout_minutes:
          name: Presence Timeout
          description: |
            **Minutes to wait** after leaving room before taking action.

            ‚Ä¢ **Prevents shutdown** during brief departures
            ‚Ä¢ **Common scenarios:** bathroom breaks, quick errands
            ‚Ä¢ **Recommended:** 15-30 minutes for comfort balance

            **Trade-off:** Lower values save more energy but may cause comfort issues.
          default: 15
          selector:
            number:
              min: 5
              max: 60
              step: 5
              unit_of_measurement: minutes

        presence_confirmation_delay:
          name: Presence Confirmation Delay (Smart Mode)
          description: |
            **How long presence must be continuously detected** before turning AC ON in Smart mode.

            ‚Ä¢ **0 minutes:** Immediate response (default, current behavior)
            ‚Ä¢ **2-5 minutes:** Filter brief visits and BLE sensor flickers
            ‚Ä¢ **10-15 minutes:** Moderate filtering for high-traffic areas
            ‚Ä¢ **20-30 minutes:** Only activate for confirmed extended stays

            **Use cases:**
            ‚Ä¢ **Bedrooms with BLE:** 3-5 min to filter boundary flickers
            ‚Ä¢ **High-traffic rooms:** 10-20 min to avoid activating when passing through
            ‚Ä¢ **Guest rooms:** 20-30 min to ensure actual occupancy
            ‚Ä¢ **Dedicated rooms (office, gaming):** 0 min for immediate comfort

            **Note:** This only affects initial turn-on. Once running, AC stays on for the full `presence_timeout` period after you leave.
          default: 0
          selector:
            number:
              min: 0
              max: 30
              step: 1
              unit_of_measurement: minutes
              mode: slider

        room_presence_sensors:
          name: Room Presence Sensors (Optional)
          description: |
            **BLE, PIR or other sensors** for room-specific presence detection.

            **Supported sensor types:**

            ‚Ä¢ **BLE area sensors:** Reports room names (e.g., "Office", "Living Room")
            ‚Ä¢ **PIR sensors:** Binary sensors reporting on/off
            ‚Ä¢ **mmWave sensors:** Human presence detection
            ‚Ä¢ **Smart device sensors:** Phone/device presence

            **Example:** `sensor.phone_ble_area`, `binary_sensor.living_room_motion`
          default: []
          selector:
            entity:
              multiple: true
              domain: 
                - binary_sensor
                - sensor
        
        presence_validation_mode:
          name: Presence Validation Mode
          description: |
            **How presence sensors work together** to detect room occupancy:

            **üéØ RECOMMENDED MODES:**
            ‚Ä¢ **BLE_MOTION** - BLE + Motion (BOTH required) - Best for bedrooms, prevents motion blips ‚≠ê
            ‚Ä¢ **BLE_BED** - BLE + Bed sensor (BOTH required) - Best for sleep-only detection
            ‚Ä¢ **BLE_SMART** - BLE + (Motion OR Bed) - Intelligent: awake=motion, sleeping=bed sensor

            **‚ö†Ô∏è SINGLE SENSOR MODES (Use with caution):**
            ‚Ä¢ **MOTION_ONLY** - Motion sensor only ‚ö†Ô∏è WARNING: Random motion blips will turn on AC!
            ‚Ä¢ **BLE_ONLY** - BLE sensor only ‚ö†Ô∏è WARNING: Phone in adjacent room will turn on AC!
            ‚Ä¢ **BED_ONLY** - Bed/occupancy sensor only - Reliable for beds with weight sensors

            **üîß FLEXIBLE MODES:**
            ‚Ä¢ **ANY** - Any sensor triggers (most responsive, may have false positives)
            ‚Ä¢ **ALL** - All sensors must agree (most accurate, may miss presence)
            ‚Ä¢ **MAJORITY** - Most sensors must agree (3+ sensors recommended)
            ‚Ä¢ **BLE_PLUS** - BLE + at least one other sensor

            **üìã Mode Details:**

            **BLE_MOTION** (Recommended for bedrooms with motion sensors):
            ‚úÖ Requires: BLE detected AND Motion detected
            ‚úÖ Prevents: Motion blips from turning on AC without you in room
            ‚úÖ Prevents: BLE in adjacent room from turning on AC
            ‚ùå Won't detect: If phone is charging elsewhere while you're in bed

            **BLE_BED** (Recommended for bedrooms with bed sensors):
            ‚úÖ Requires: BLE detected AND Bed sensor active
            ‚úÖ Best for: Sleep detection with bed occupancy sensors
            ‚úÖ Prevents: False triggers from motion or BLE alone
            ‚ùå Won't detect: If you're awake in room but not in bed

            **BLE_SMART** (Best for bedrooms with motion AND bed sensors):
            ‚úÖ Requires: BLE detected AND (Motion OR Bed sensor)
            ‚úÖ Detects: Awake (BLE+motion) or Sleeping (BLE+bed)
            ‚úÖ Flexible: Works whether you're moving around or in bed
            ‚ùå Won't detect: If phone is charging elsewhere

            **MOTION_ONLY** ‚ö†Ô∏è WARNING:
            ‚ùå Random motion blips trigger AC even when room is empty
            ‚ùå Shadows, pets, fans can cause false activation
            ‚ö†Ô∏è Use presence_confirmation_delay (5+ min) to reduce false positives
            ‚úÖ Only use if: No other sensors available and you understand the risk

            **BLE_ONLY** ‚ö†Ô∏è WARNING:
            ‚ùå Phone in adjacent room will turn on AC
            ‚ùå Phone left in room will keep AC running when you leave
            ‚úÖ Only use if: Room has thick walls/good BLE isolation

            **BED_ONLY** (Reliable if you have a good bed sensor):
            ‚úÖ Requires: Bed occupancy sensor active
            ‚úÖ Reliable: Weight-based bed sensors rarely have false positives
            ‚ùå Won't detect: Presence when not in bed (awake in room)
            ‚úÖ Use for: Bedrooms where AC should ONLY run while sleeping

            **üí° Recommendations:**
            ‚Ä¢ **Master Bedroom**: BLE_MOTION or BLE_SMART (prevents motion blips) ‚≠ê
            ‚Ä¢ **Guest Bedroom**: BED_ONLY (only cool while sleeping)
            ‚Ä¢ **Living Room**: BLE_MOTION or BLE_PLUS (prevent false triggers)
            ‚Ä¢ **Office**: BLE_MOTION (ensures you're actually there)
            ‚Ä¢ **Single Sensor Setup**: Use MOTION_ONLY/BLE_ONLY with 5+ min confirmation delay ‚ö†Ô∏è

            **üõ°Ô∏è False Trigger Protection:**
            All modes work with `presence_confirmation_delay` to prevent brief sensor blips from activating AC.
            Recommended: 2-5 minutes for motion-based modes, 0-1 minute for BLE+combination modes.
          default: "any"
          selector:
            select:
              options:
                - label: "üéØ BLE_MOTION - BLE + Motion (BOTH required) ‚≠ê Recommended"
                  value: "ble_motion"
                - label: "üéØ BLE_BED - BLE + Bed sensor (BOTH required)"
                  value: "ble_bed"
                - label: "üéØ BLE_SMART - BLE + (Motion OR Bed) - Intelligent"
                  value: "ble_smart"
                - label: "‚ö†Ô∏è MOTION_ONLY - Motion only (WARNING: Random blips trigger AC!)"
                  value: "motion_only"
                - label: "‚ö†Ô∏è BLE_ONLY - BLE only (WARNING: Adjacent room triggers!)"
                  value: "ble_only"
                - label: "BED_ONLY - Bed/occupancy sensor only (Reliable)"
                  value: "bed_only"
                - label: "ANY - Any sensor triggers (Default, responsive but may have false positives)"
                  value: "any"
                - label: "ALL - All sensors must agree"
                  value: "all"
                - label: "MAJORITY - Most sensors must agree"
                  value: "majority"
                - label: "BLE_PLUS - BLE + at least one other"
                  value: "ble_plus"
        
        # Room name is now configured at the top as a required field
        
        adjacent_room_names:
          name: Adjacent Room Names (Open-Plan Spaces)
          description: |
            **For open-plan spaces**, specify adjacent room names that should also trigger this AC.
            
            **Use case:** Your Living Room AC covers an open Kitchen/Living/Dining area, but BLE 
            sensors report specific room names. This allows the AC to activate when you're detected
            in ANY of these connected spaces.
            
            **‚ö†Ô∏è CRITICAL: Check Your BLE Sensor Format First!**
            Before configuring, check **Developer Tools ‚Üí States** to see exactly how your BLE sensor reports room names:
            
            ‚Ä¢ **If sensor shows:** `living room` ‚Üí **Enter:** `Living Room`

            ‚Ä¢ **If sensor shows:** `living_room` (with underscores) ‚Üí **Enter:** `living_room`

            ‚Ä¢ **If sensor shows:** `livingroom` ‚Üí **Enter:** `livingroom`
            
            **Format must match exactly** (case-insensitive but spaces/underscores matter).
            
            **Examples based on your BLE sensor format:**
            ‚Ä¢ **Spaces format:** Kitchen, Dining Room, Living Room
            ‚Ä¢ **Underscore format:** kitchen, dining_room, living_room
            ‚Ä¢ **No spaces format:** kitchen, diningroom, livingroom
            
            **Example Configuration (assuming spaces format):**
            ‚Ä¢ **Room Name:** Living Room (main room from top of config)
            ‚Ä¢ **Adjacent Rooms:** Kitchen, Dining Room, Family Room
            ‚Ä¢ **Result:** AC activates when BLE detects Living Room, Kitchen, Dining Room, OR Family Room
            
            **‚ö†Ô∏è IMPORTANT for SMART/BLE_PLUS modes:**
            When using validation modes that require motion + BLE, you MUST also add the motion 
            sensors from adjacent rooms to the "Room Presence Sensors" list above.
            
            **Example for SMART mode (spaces format):**
            ‚Ä¢ **Adjacent Room Names:** Kitchen, Family Room  (match BLE sensor format)
            ‚Ä¢ **Room Presence Sensors must include:**
              - `sensor.phone_ble_area` (BLE sensor)

              - `binary_sensor.living_room_motion` (main room)

              - `binary_sensor.kitchen_motion` (adjacent room motion)
              
              - `binary_sensor.family_room_motion` (adjacent room motion)
            
            **Leave empty if not using open-plan space detection.**
          default: ""
          selector:
            text:
        
        smart_mode_behavior:
          name: Smart Mode Room Absence Behavior
          description: |
            What to do when **room presence sensors detect absence** (after timeout):

            ‚Ä¢ **ECO:** Reduce to eco mode (saves power, maintains some comfort)
            ‚Ä¢ **MAINTAIN:** Keep current temperature (comfort over efficiency)
            ‚Ä¢ **OFF:** Turn off completely (maximum power savings)

            **Note:** Only applies when still home but room is empty.
          default: "eco"
          selector:
            select:
              options:
                - "eco"
                - "maintain"
                - "off"

        temp_stability_enabled:
          name: Temperature Stability Auto-Off
          description: |
            **Automatically turn off AC** when temperature remains stable for specified duration.

            **How it works:** Detects when AC job is complete (thermal equilibrium reached) to save energy.

            **Note:** Works even when people are still in room. **Requires** temperature history helper.
          default: false
          selector:
            boolean:

        stability_tolerance:
          name: Stability Temperature Tolerance
          description: |
            Temperature range considered **"stable"** for auto-off detection.

            **Sensitivity levels:**

            ‚Ä¢ **¬±0.3¬∞C:** High sensitivity (recommended for most users)
            ‚Ä¢ **¬±0.5¬∞C:** Moderate sensitivity (balanced approach)
            ‚Ä¢ **¬±1.0¬∞C:** Low sensitivity (less aggressive)

            **Rule:** Smaller values trigger auto-off sooner, larger values wait longer.
          default: 0.3
          selector:
            number:
              min: 0.1
              max: 5.0
              step: 0.1
              unit_of_measurement: "¬∞C"

        stability_duration:
          name: Stability Duration
          description: |
            **Minutes** temperature must remain stable before auto-off triggers.

            **Timing strategies:**

            ‚Ä¢ **10-15 minutes:** Aggressive energy savings
            ‚Ä¢ **20-25 minutes:** Balanced efficiency and comfort
            ‚Ä¢ **25-30 minutes:** Conservative, prioritizes comfort

            **Trade-off:** Shorter duration saves more energy but may cause temperature fluctuations.
          default: 15
          selector:
            number:
              min: 10
              max: 30
              step: 5
              unit_of_measurement: "min"

        stability_behavior:
          name: Stability Auto-Off Action
          description: |
            **Triggered when temperature becomes STABLE** (¬±1¬∞C for 15+ minutes):

            **Purpose:** Recognizes AC achieved its goal and temperature isn't changing

            ‚Ä¢ **OFF:** Turn off completely (maximum energy savings)
            ‚Ä¢ **ECO:** Switch to eco mode (moderate energy savings, maintains some comfort)
            ‚Ä¢ **FAN_ONLY:** Switch to fan-only mode (85% power savings, better comfort than OFF) ‚≠ê Recommended

            **Fan-Only Benefits:**
            - Compressor OFF (major power savings ~85%)
            - Fan circulates air (maintains comfort better than OFF)
            - Returns to cooling/heating when temp exits comfort zone
            - AC stays "on" but uses minimal power

            **Different from Eco Mode:** This responds to temperature **stability**, not comfort zone
          default: "off"
          selector:
            select:
              options:
                - label: "OFF - Turn off completely (maximum savings)"
                  value: "off"
                - label: "ECO - Eco mode (moderate savings)"
                  value: "eco"
                - label: "FAN_ONLY - Fan-only mode (85% savings) ‚≠ê Recommended"
                  value: "fan_only"

        fan_only_fan_speed:
          name: "Fan-Only Mode Fan Speed"
          description: |
            **Fan speed to use when in fan-only mode** (stability or overshoot target reached).

            **Select the exact fan mode available on your AC:**
            ‚Ä¢ **Silence / Quiet:** Quietest operation ‚≠ê Recommended for sleep (‚âà20-30W)
            ‚Ä¢ **1:** Ultra-quiet (‚âà30-50W)
            ‚Ä¢ **2:** Low speed (‚âà50-70W)
            ‚Ä¢ **3:** Medium speed (‚âà70-100W)
            ‚Ä¢ **4:** Medium-high speed (‚âà100-120W)
            ‚Ä¢ **5:** Maximum fan speed (‚âà120-150W)

            **Check your AC's available fan modes** in Developer Tools ‚Üí States ‚Üí climate.your_ac ‚Üí fan_modes attribute.
            Different AC models have different options (e.g., one may have "Silence", another may have "Quiet").

            **Power Impact:** All fan speeds use significantly less power than compressor (800W+)
          default: "silence"
          selector:
            select:
              options:
                - label: "Silence ‚≠ê Recommended (quietest)"
                  value: "silence"
                - label: "Quiet ‚≠ê Recommended (quietest)"
                  value: "quiet"
                - label: "1 (ultra-quiet)"
                  value: "1"
                - label: "2 (low speed)"
                  value: "2"
                - label: "3 (medium speed)"
                  value: "3"
                - label: "4 (medium-high speed)"
                  value: "4"
                - label: "5 (maximum fan)"
                  value: "5"

    # Bed/Sleep Comfort Settings (Optional)
    bed_comfort_settings:
      name: "Bed/Sleep Comfort Settings"
      icon: mdi:bed
      collapsed: true
      input:
        bed_comfort_mode:
          name: "Bed Comfort Mode"
          description: |
            **Triggered when bed sensor detects occupancy** (requires bed sensor configured below):

            **Purpose:** Ultra-quiet, sleep-optimized climate control when in bed

            ‚Ä¢ **OFF:** Normal behavior (no special bed mode)
            ‚Ä¢ **QUIET:** Ultra-quiet fan only (Level 1/Quiet/Silence) when in bed ‚≠ê Recommended
            ‚Ä¢ **ECO:** Full eco mode (low power + quiet fan) when in bed

            **Different from Eco Mode:** This responds to **bed occupancy**, not comfort zone
            **Different from Stability:** This responds to **being in bed**, not temperature stability

            **Benefits:**
            ‚Ä¢ Ultra-quiet operation for better sleep
            ‚Ä¢ Energy savings while maintaining comfort
            ‚Ä¢ Automatic activation when entering bed

            **Safe:** Only activates after temperature targets reached, never interrupts active cooling/heating
          default: "off"
          selector:
            select:
              options:
                - label: "Off - Normal behavior (no special bed mode)"
                  value: "off"
                - label: "Quiet - Ultra-quiet fan when in bed ‚≠ê Recommended"
                  value: "quiet"
                - label: "Eco - Full eco mode when in bed"
                  value: "eco"

        bed_sensor_manual:
          name: "Bed Occupancy Sensor"
          description: |
            Select the bed occupancy sensor (binary_sensor).

            **Examples:**
            - Bed pressure sensor
            - ESPresense bed presence sensor
            - mmWave bed occupancy sensor
            - Weight-based bed sensor

            **Leave empty to disable bed comfort mode.**
          default: ""
          selector:
            entity:
              domain: binary_sensor

        bed_absence_grace_period:
          name: "Bed Absence Grace Period"
          description: |
            **Minutes to keep bed ECO mode running** after bed becomes unoccupied.

            Perfect for bathroom trips - prevents AC from exiting bed ECO mode during short absences.

            **Common Scenarios:**
            - **1-5 minutes:** Quick bathroom breaks
            - **5-10 minutes:** Standard bathroom routine
            - **10-15 minutes:** Longer absences
            - **15-30 minutes:** Very forgiving (getting water, checking on kids, etc.)
            - **0 minutes:** Exit immediately when bed unoccupied (old behavior)

            **Recommended:** 5-10 minutes for optimal comfort/efficiency balance.

            **How it works:** If you return to bed within the grace period, bed ECO mode seamlessly continues. If grace period expires, AC exits to normal cooling logic.

            **Trade-off:** Higher values maintain comfort during absences but may waste energy if you don't return to bed.
          default: 5
          selector:
            number:
              min: 0
              max: 30
              step: 1
              unit_of_measurement: minutes

        bed_eco_fan_only_mode:
          name: "Bed ECO Fan-Only Mode"
          description: |
            **Enable smart fan-only mode** when temperature stable at target.

            **How it works:**
            1. Bed ECO cools to target temperature (23¬∞C)
            2. Detects when temperature **stable** (change < 0.05¬∞C/min for 3+ minutes)
            3. Switches to **FAN_ONLY** to save power (~85% reduction)
            4. Returns to cooling if temp rises >0.5¬∞C above target

            **Handles overshooting:** If room keeps cooling below target (e.g., 22.7¬∞C),
            still switches to fan_only when stable (AC too effective, wasting power).

            **Power savings:** ~75-85% reduction over 8 hours sleep

            **Compatibility:** Automatically disabled if AC doesn't support fan_only mode
          default: "disabled"
          selector:
            select:
              options:
                - label: "Disabled - Always use cooling"
                  value: "disabled"
                - label: "Enabled - Switch to fan-only when stable"
                  value: "enabled"

        bed_eco_stability_minutes:
          name: "Bed ECO Stability Duration"
          description: |
            **Minutes temperature must be stable** before switching to fan-only.

            **What is "stable"?** Change rate < 0.05¬∞C/min (configurable below)

            ‚Ä¢ **1-2 minutes:** Quick switch (may cycle more frequently)
            ‚Ä¢ **3-5 minutes:** Balanced (recommended) ‚≠ê
            ‚Ä¢ **5-10 minutes:** Conservative (very stable before switching)

            **Recommended:** 3 minutes for optimal balance
          default: 3
          selector:
            number:
              min: 1
              max: 10
              step: 1
              unit_of_measurement: minutes

        bed_eco_stability_rate:
          name: "Bed ECO Stability Rate Threshold"
          description: |
            **Maximum temperature change rate** to be considered "stable".

            **Lower value = stricter stability requirement**

            ‚Ä¢ **0.02¬∞C/min:** Very strict (almost no change)
            ‚Ä¢ **0.05¬∞C/min:** Balanced (recommended) ‚≠ê
            ‚Ä¢ **0.10¬∞C/min:** Relaxed (allows more variation)

            **Example:** At 0.05¬∞C/min, temp can change from 23.0 ‚Üí 23.1¬∞C over 2 minutes and still be "stable"

            **Recommended:** 0.05¬∞C/min for most scenarios
          default: 0.05
          selector:
            number:
              min: 0.02
              max: 0.15
              step: 0.01
              unit_of_measurement: "¬∞C/min"

        bed_eco_return_threshold:
          name: "Bed ECO Return Threshold"
          description: |
            **Temperature rise above target** to trigger return to cooling.

            **When in fan-only mode:**
            - Room naturally warms from fan-only operation
            - When temp exceeds (target + threshold), return to cooling

            ‚Ä¢ **0.2-0.3¬∞C:** Tight control (more cooling cycles, less savings)
            ‚Ä¢ **0.5¬∞C:** Balanced (recommended) ‚≠ê
            ‚Ä¢ **0.7-1.0¬∞C:** Relaxed (maximum savings, slight comfort trade-off)

            **Example:** Target 23¬∞C, threshold 0.5¬∞C
            - Fan-only while temp 23.0-23.5¬∞C
            - Return to cooling at 23.5¬∞C

            **Recommended:** 0.5¬∞C for most users
          default: 0.5
          selector:
            number:
              min: 0.2
              max: 1.5
              step: 0.1
              unit_of_measurement: "¬∞C"

        bed_eco_max_overshoot:
          name: "Bed ECO Maximum Overshoot Tolerance"
          description: |
            **Maximum undershoot below target** before forcing return to cooling.

            **Handles overshooting scenario:**
            - Bed ECO cools to 23¬∞C but keeps going to 22.5¬∞C
            - If temp stable at 22.5¬∞C ‚Üí Switch to fan_only (within tolerance)
            - If temp stable at 21.5¬∞C ‚Üí Stay in cooling (too cold!)

            ‚Ä¢ **0.5¬∞C:** Strict (stay close to target)
            ‚Ä¢ **1.0¬∞C:** Balanced (recommended) ‚≠ê
            ‚Ä¢ **1.5-2.0¬∞C:** Relaxed (allows significant undershoot)

            **Example:** Target 23¬∞C, overshoot 1.0¬∞C
            - Stable at 22.5¬∞C ‚Üí Switch to fan_only ‚úÖ
            - Stable at 21.8¬∞C ‚Üí Stay in cooling ‚ùå

            **Recommended:** 1.0¬∞C for most scenarios
          default: 1.0
          selector:
            number:
              min: 0.5
              max: 2.5
              step: 0.1
              unit_of_measurement: "¬∞C"

    # Scheduling Settings (Optional)
    scheduling_settings:
      name: "Time-Based Scheduling"
      icon: mdi:calendar-clock
      collapsed: true
      input:
        enable_scheduling:
          name: Enable Time-Based Scheduling
          description: |
            **Automatically adjust temperatures** based on time of day.

            **Benefits:**

            ‚Ä¢ **Optimized comfort** for different activities
            ‚Ä¢ **Energy savings** during sleeping hours
            ‚Ä¢ Cooler mornings, warmer evenings as needed
            ‚Ä¢ Separate weekend schedule option

            **Note:** Overrides base target temperature when enabled.
          default: false
          selector:
            boolean:
        
        morning_temp:
          name: Morning Temperature (6am-9am)
          description: |
            **Temperature target** for morning hours **(6am-9am)**.

            ‚Ä¢ **Typically cooler** for waking up comfort
            ‚Ä¢ Good for productivity during morning routines
            ‚Ä¢ Consider personal preferences and climate
          default: 22
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        day_temp:
          name: Day Temperature (9am-6pm)
          description: |
            **Temperature target** for daytime hours **(9am-6pm)**.

            ‚Ä¢ **Optimize** for work/activity comfort
            ‚Ä¢ Balance productivity and energy efficiency
            ‚Ä¢ Consider sunlight and heat gain during day
          default: 23
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        evening_temp:
          name: Evening Temperature (6pm-10pm)
          description: |
            **Temperature target** for evening hours **(6pm-10pm)**.

            ‚Ä¢ **Relaxation** and family time comfort
            ‚Ä¢ May prefer slightly warmer for leisure
            ‚Ä¢ Accounts for reduced outdoor temperatures
          default: 23
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        night_temp:
          name: Night Temperature (10pm-6am)
          description: |
            **Temperature target** for sleeping hours **(10pm-6am)**.

            ‚Ä¢ **Sleep research** recommends 18-21¬∞C for best rest
            ‚Ä¢ **Cooler temperatures** promote deeper sleep
            ‚Ä¢ **Energy savings** during extended periods
          default: 24
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        enable_weekend_schedule:
          name: Different Weekend Schedule
          description: |
            Use **different temperature schedule** on weekends.

            ‚Ä¢ **Later wake times** with extended morning periods
            ‚Ä¢ Different activity patterns and comfort needs
            ‚Ä¢ More flexible scheduling for leisure days

            **Note:** Weekend morning period: 6am-10am (vs weekday 6am-9am)
          default: false
          selector:
            boolean:
        
        weekend_morning_temp:
          name: Weekend Morning Temperature
          description: |
            **Weekend morning temperature** **(6am-10am)**.

            ‚Ä¢ **Extended morning period** for leisurely weekends
            ‚Ä¢ May prefer warmer for relaxed mornings
            ‚Ä¢ Adjust based on weekend routines and preferences
          default: 23
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        weekend_day_temp:
          name: Weekend Day Temperature
          description: |
            **Weekend daytime temperature** **(10am-10pm)**.

            ‚Ä¢ **Extended day period** for weekend activities
            ‚Ä¢ Covers both day and evening in one setting
            ‚Ä¢ Simplifies weekend scheduling

            **Note:** Single temperature for entire active weekend period.
          default: 23
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        weekend_night_temp:
          name: Weekend Night Temperature
          description: |
            **Weekend night temperature** **(10pm-6am)**.

            ‚Ä¢ **Same sleep optimization** as weeknight temperature
            ‚Ä¢ May differ if weekend bedtime routines vary
            ‚Ä¢ Maintains consistent sleep comfort

            Consider if weekend sleep patterns require different settings.
          default: 24
          selector:
            number:
              min: 18
              max: 28
              step: 0.5
              unit_of_measurement: "¬∞C"

    # Window Detection Settings (Optional)
    window_detection_settings:
      name: "Window Detection"
      icon: mdi:window-open
      collapsed: true
      input:
        enable_window_detection:
          name: Enable Window Detection
          description: |
            **Automatically turn off AC** when windows or doors are opened.

            **Benefits:**

            ‚Ä¢ **Prevents** cooling/heating the outdoors
            ‚Ä¢ **Significant energy savings**
            ‚Ä¢ Protects AC equipment from overwork
            ‚Ä¢ **Automatic resumption** when closed

            **Requirement:** Binary sensors on doors/windows.
          default: false
          selector:
            boolean:
        
        window_sensors:
          name: Window/Door Sensors
          description: |
            Select sensors that should **turn off AC** when opened.

            **Compatible sensors:**

            ‚Ä¢ **Door contact sensors**
            ‚Ä¢ **Window opening sensors**
            ‚Ä¢ **Magnetic reed switches**
            ‚Ä¢ **Smart window/door sensors**

            **Behavior:** All selected sensors will trigger AC shutdown when opened.
          default: []
          selector:
            entity:
              multiple: true
              domain: binary_sensor
        
        window_open_delay:
          name: Window Open Delay
          description: |
            **Minutes to wait** after window opens before turning off AC.

            ‚Ä¢ **Prevents false triggers** from brief openings
            ‚Ä¢ **0 minutes:** Immediate shutdown (most responsive)
            ‚Ä¢ **1-2 minutes:** Balanced (recommended)
            ‚Ä¢ **3+ minutes:** Delayed response

            **Result:** Brief openings won't unnecessarily stop your AC.
          default: 2
          selector:
            number:
              min: 0
              max: 10
              step: 1
              unit_of_measurement: "minutes"
        
        window_close_delay:
          name: Window Close Delay
          description: |
            **Minutes to wait** after window closes before resuming AC.

            ‚Ä¢ **Ensures window** is properly closed before restarting
            ‚Ä¢ Allows time for air exchange to stabilize
            ‚Ä¢ **Prevents rapid on/off cycling**

            **Recommendation:** Short delay to confirm sensor stability.
          default: 1
          selector:
            number:
              min: 0
              max: 10
              step: 1
              unit_of_measurement: "minutes"

    # Outside Temperature Compensation Settings (Optional)
    outside_temp_compensation_settings:
      name: "Outside Temperature Compensation"
      icon: mdi:sun-thermometer
      collapsed: true
      input:
        enable_outside_temp_compensation:
          name: Enable Outside Temperature Compensation
          description: |
            **Make AC work HARDER on extreme outdoor temperature days** to achieve your target.

            **How it works:**

            ‚Ä¢ **Hot outdoor weather (Cooling):** Set AC cooler than target + boost fan speed to counteract heat influx
            ‚Ä¢ **Cold outdoor weather (Heating):** Set heater warmer than target + boost fan speed to counteract cold influx
            ‚Ä¢ **Mild outdoor weather:** Use normal settings

            **Example:** 35¬∞C outside, 22¬∞C target ‚Üí AC set to 20.5¬∞C with Fan 4 start (undershoots to maintain 22¬∞C)

            **Result:** Your target temperature is ACHIEVED faster and MAINTAINED even on extreme days.
          default: false
          selector:
            boolean:

        weather_entity:
          name: Weather Entity
          description: |
            **Weather integration** for outdoor temperature data.

            ‚Ä¢ **Provides base** outdoor temperature readings
            ‚Ä¢ Usually `weather.home` or `weather.forecast_home`
            ‚Ä¢ **Fallback** if no dedicated outdoor sensor available

            **Recommendation:** Most users should start with their default weather integration.
          default: weather.home
          selector:
            entity:
              domain: weather

        outdoor_temp_sensor:
          name: Outdoor Temperature Sensor (Optional)
          description: |
            **External temperature sensor** for more accurate readings.

            ‚Ä¢ **More precise** than weather service data
            ‚Ä¢ **Real-time local conditions** vs forecast data
            ‚Ä¢ **Optional:** Falls back to weather entity if not set

            **Recommended** for users with outdoor temperature sensors (e.g., Daikin outdoor units).
          default: []
          selector:
            entity:
              domain: sensor
              device_class: temperature

        outside_compensation_factor:
          name: Outside Compensation Factor
          description: |
            **How aggressively to compensate for outdoor temperature** (0-1).

            **Factor levels:**

            ‚Ä¢ **0.0:** No compensation (disabled)
            ‚Ä¢ **0.1-0.2:** Mild compensation (recommended for most climates)
            ‚Ä¢ **0.3-0.5:** Moderate compensation (hot/cold climates)
            ‚Ä¢ **0.6-1.0:** Aggressive compensation (extreme climates)

            **Example:** 0.2 factor with 35¬∞C outside (10¬∞C above neutral) ‚Üí 2¬∞C undershoot (AC set to 20¬∞C for 22¬∞C target)
          default: 0.2
          selector:
            number:
              min: 0
              max: 1
              step: 0.1

        max_outside_compensation:
          name: Maximum Outside Compensation
          description: |
            **Maximum degrees** to undershoot/overshoot AC setpoint.

            ‚Ä¢ **Safety limit** to prevent extreme AC settings
            ‚Ä¢ **1-2¬∞C:** Conservative, small adjustments
            ‚Ä¢ **3-4¬∞C:** Moderate, noticeable compensation
            ‚Ä¢ **5¬∞C:** Aggressive, maximum compensation

            **Example:** 2¬∞C max ‚Üí AC won't go below 20¬∞C for 22¬∞C cooling target, or above 24¬∞C for 22¬∞C heating target.
          default: 2
          selector:
            number:
              min: 1
              max: 5
              step: 0.5
              unit_of_measurement: "¬∞C"

        outside_compensation_base_temp:
          name: Outside Compensation Base Temperature
          description: |
            **Outdoor temperature** considered "neutral" (no compensation needed).

            ‚Ä¢ **Temperature where outdoor conditions don't fight your AC**
            ‚Ä¢ **25¬∞C:** Good baseline for most climates
            ‚Ä¢ **Above baseline (cooling):** AC undershoots to counteract heat influx
            ‚Ä¢ **Below baseline (heating):** Heater overshoots to counteract cold influx

            **Recommendation:** Adjust based on your local climate and comfort preferences.
          default: 25
          selector:
            number:
              min: 20
              max: 30
              step: 1
              unit_of_measurement: "¬∞C"

    # Fan & Swing Settings
    fan_settings:
      name: "Fan & Swing Settings"
      icon: mdi:fan
      collapsed: true
      input:
        fan_speed_max:
          name: Maximum Fan Speed
          description: |
            **Fan speed** for maximum cooling/heating conditions.

            ‚Ä¢ **Auto:** Let AC system manage fan speed
            ‚Ä¢ **Level 5/5:** Maximum airflow for rapid temperature changes
            ‚Ä¢ System auto-detects your AC's fan speed format

            **Used when:** Temperature is far from target or during initial conditioning.
          default: "Level 5"
          selector:
            select:
              options:
                - "Auto"
                - "auto"
                - "Quiet"
                - "Silence"
                - "Level 1"
                - "Level 2"
                - "Level 3"
                - "Level 4"
                - "Level 5"
                - "1"
                - "2"
                - "3"
                - "4"
                - "5"
                - "high"
                - "medium"
                - "low"
        
        fan_speed_medium:
          name: Medium Fan Speed
          description: |
            **Fan speed** for medium cooling/heating conditions.

            ‚Ä¢ **Balanced airflow** for moderate temperature adjustments
            ‚Ä¢ Good for maintaining temperatures within comfort zone
            ‚Ä¢ System auto-detects your AC's fan speed format

            **Used when:** Temperature is moderately outside target range.
          default: "Level 3"
          selector:
            select:
              options:
                - "Auto"
                - "auto"
                - "Quiet"
                - "Silence"
                - "Level 1"
                - "Level 2"
                - "Level 3"
                - "Level 4"
                - "Level 5"
                - "1"
                - "2"
                - "3"
                - "4"
                - "5"
                - "high"
                - "medium"
                - "low"
        
        fan_speed_eco:
          name: Eco Fan Speed
          description: |
            **Fan speed** for eco mode and comfort zone operation.

            ‚Ä¢ **Quiet, energy-efficient operation**
            ‚Ä¢ Used when temperature is within comfort zone
            ‚Ä¢ **Minimal noise** for continuous operation
            ‚Ä¢ System auto-detects your AC's fan speed format

            **Purpose:** Balances comfort with energy efficiency and noise levels.
          default: "Level 1"
          selector:
            select:
              options:
                - "Auto"
                - "auto"
                - "Quiet"
                - "Silence"
                - "Level 1"
                - "Level 2"
                - "Level 3"
                - "Level 4"
                - "Level 5"
                - "1"
                - "2"
                - "3"
                - "4"
                - "5"
                - "high"
                - "medium"
                - "low"
        
        swing_mode_active:
          name: Active Swing Mode
          description: |
            **Swing mode** when actively cooling/heating.

            ‚Ä¢ **both:** Full directional coverage (recommended)
            ‚Ä¢ **horizontal:** Left-right movement only
            ‚Ä¢ **vertical:** Up-down movement only
            ‚Ä¢ **off:** Fixed direction

            **Benefit:** Better air circulation helps achieve target temperatures faster.
          default: "both"
          selector:
            select:
              options:
                - "off"
                - "both"
                - "vertical"
                - "horizontal"

    # Power Efficiency Settings
    efficiency_settings:
      name: "Power Efficiency Settings"
      icon: mdi:leaf
      collapsed: true
      input:
        comfort_zone_action:
          name: "Action When Comfort Zone Edge Reached"
          description: |
            **Triggered when temperature reaches COMFORT ZONE EDGE:**
            - **Cooling:** Activates when temp drops to comfort_max (e.g., 24.5¬∞C if target 23¬∞C ¬± 1.5¬∞C)
            - **Heating:** Activates when temp rises to comfort_min (e.g., 21.5¬∞C if target 23¬∞C ¬± 1.5¬∞C)

            **Purpose:** Control what AC does after reaching the comfort zone edge (target achieved)

            ‚Ä¢ **OFF:** Turn off completely (maximum savings, temp may drift)
            ‚Ä¢ **ECO:** Eco mode (low power ~150-250W, maintains edge with setpoint offset)
            ‚Ä¢ **FAN_ONLY:** Fan-only mode (85% savings, maintains comfort better than OFF) ‚≠ê Recommended

            **How It Works (Fan-Only Example):**
            1. Cooling: Reaches 24.5¬∞C (comfort_max) ‚Üí Switches to FAN-ONLY
            2. Room naturally warms from 24.5¬∞C ‚Üí 25¬∞C ‚Üí 25.5¬∞C
            3. Exits comfort zone (> 24.5¬∞C) ‚Üí Returns to cooling

            **Fan-Only Benefits:**
            - Compressor OFF (major power savings ~85%)
            - Fan circulates air (prevents hot/cold spots)
            - Better comfort than OFF mode
            - Automatically returns to cooling/heating if temp exits comfort zone

            **Different from Stability:** This triggers at **comfort zone edge**, not temperature stability

            **Recommended:** FAN_ONLY for best comfort/efficiency balance
          default: "off"
          selector:
            select:
              options:
                - label: "OFF - Turn off completely (maximum savings)"
                  value: "off"
                - label: "ECO - Eco mode (moderate savings, maintains target)"
                  value: "eco"
                - label: "FAN_ONLY - Fan-only mode (85% savings) ‚≠ê Recommended"
                  value: "fan_only"
        
        eco_mode_setpoint_offset:
          name: Eco Mode Setpoint Offset
          description: |
            **Degrees to adjust setpoint** in eco mode to reduce cycling.

            ‚Ä¢ **0¬∞C:** Standard eco mode (maintains exact target)
            ‚Ä¢ **1¬∞C:** Relaxed eco mode (recommended)
            ‚Ä¢ **2-3¬∞C:** Very relaxed (maximum efficiency)

            **Rule:** Higher values reduce compressor cycling and save more energy.
          default: 1
          selector:
            number:
              min: 0
              max: 3
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        min_runtime_minutes:
          name: Minimum Runtime
          description: |
            **Minimum minutes** A/C must run before allowing mode change.

            ‚Ä¢ **Prevents rapid on/off cycling** (protects compressor)
            ‚Ä¢ **5-10 minutes:** Aggressive efficiency
            ‚Ä¢ **15-20 minutes:** Balanced approach (recommended)
            ‚Ä¢ **25-30 minutes:** Conservative, equipment protection

            **Benefit:** Extends compressor lifespan and improves efficiency.
          default: 15
          selector:
            number:
              min: 5
              max: 30
              unit_of_measurement: minutes
        
        min_off_time_minutes:
          name: Minimum Off Time
          description: |
            **Minimum minutes** A/C must be off before restarting.

            ‚Ä¢ **Allows compressor pressure** to equalize
            ‚Ä¢ **3-5 minutes:** Minimum for compressor safety
            ‚Ä¢ **10 minutes:** Recommended balance
            ‚Ä¢ **15 minutes:** Conservative protection

            **Note:** Modern AC units (2015+) often have built-in 3-5 minute delay timers.
            If your AC has hardware protection, you can disable enforcement below
            or reduce this to 3 minutes.

            **Critical** for compressor longevity and energy efficiency.
          default: 10
          selector:
            number:
              min: 3
              max: 15
              unit_of_measurement: minutes

        enforce_off_time_protection:
          name: Enforce Off-Time Protection
          description: |
            **Enable off-time protection** when restarting AC from OFF state.

            ‚Ä¢ **ON (Recommended):** Enforces `min_off_time_minutes` delay before restart
            ‚Ä¢ **OFF:** Allows immediate restart (use if AC has built-in protection)

            **When to disable:**
            - Modern AC with built-in 3-5 minute delay timer
            - Testing/debugging automation behavior
            - Rapid response scenarios (at your own risk)

            **When to keep enabled:**
            - Older AC units without built-in protection
            - Extending compressor lifespan
            - Conservative safety approach
          default: true
          selector:
            boolean:

        extreme_temp_override:
          name: Extreme Temperature Override
          description: |
            **Temperature thresholds** that override Manual mode for safety.

            **Emergency override:** Above high or below low will activate climate even in Manual mode.
          default: true
          selector:
            boolean:
        
        extreme_high_temp:
          name: Extreme High Temperature
          description: |
            **Safety threshold** - activate cooling even in Manual mode.

            ‚Ä¢ **Emergency override** for extremely hot conditions
            ‚Ä¢ **Protects health** and equipment from overheating
            ‚Ä¢ Only activates when indoor temperature exceeds threshold
            ‚Ä¢ **Returns to Manual mode** once temperature normalizes

            **Recommendation:** Set based on your comfort limits and local climate conditions.
          default: 30
          selector:
            number:
              min: 28
              max: 35
              step: 0.5
              unit_of_measurement: "¬∞C"
        
        extreme_low_temp:
          name: Extreme Low Temperature
          description: |
            **Safety threshold** - activate heating even in Manual mode.

            ‚Ä¢ **Emergency override** for extremely cold conditions
            ‚Ä¢ **Prevents pipes freezing** and health risks
            ‚Ä¢ Only activates when indoor temperature falls below threshold
            ‚Ä¢ **Returns to Manual mode** once temperature normalizes

            **Recommendation:** Set based on your heating needs and local climate conditions.
          default: 15
          selector:
            number:
              min: 10
              max: 18
              step: 0.5
              unit_of_measurement: "¬∞C"

    # Advanced Settings
    advanced_settings:
      name: "Advanced Settings"
      icon: mdi:cog
      collapsed: true
      input:
        enable_dynamic_adaptation:
          name: Enable Dynamic Adaptation
          description: |
            **Automatically escalate/de-escalate** cooling/heating power based on effectiveness.

            **How it works:**

            ‚Ä¢ **Monitors temperature progress** toward target
            ‚Ä¢ **Increases power** when progress stalls
            ‚Ä¢ **Reduces power** when target is approaching
            ‚Ä¢ **Learns** your AC's effectiveness over time

            **Requirement:** Helper entities for temperature tracking and analysis.
          default: true
          selector:
            boolean:
        
        effectiveness_check_minutes:
          name: Effectiveness Check Interval
          description: |
            **Minutes to wait** before checking if current mode is working.

            ‚Ä¢ **1-3 minutes:** Very aggressive adaptation (gaming rooms, high heat load)
            ‚Ä¢ **5-10 minutes:** Responsive adaptation
            ‚Ä¢ **15 minutes:** Balanced approach (recommended)
            ‚Ä¢ **20-30 minutes:** Conservative, gives more time for AC to work

            **Trade-off:** Too short may cause excessive mode switching; too long delays optimization.
          default: 10
          selector:
            number:
              min: 1
              max: 30
              unit_of_measurement: minutes

        stall_escalation_time:
          name: Stall Escalation Time
          description: |
            **Minutes of poor progress** before forcing escalation regardless of distance from target.

            **How it works:**
            ‚Ä¢ Monitors temperature change rate (¬∞C/min)
            ‚Ä¢ If progress is too slow for this duration ‚Üí escalates immediately
            ‚Ä¢ Prevents AC getting stuck with minimal progress for hours

            **Time settings:**
            ‚Ä¢ **5-10 minutes:** Quick response to stalled progress
            ‚Ä¢ **15 minutes:** Balanced approach (recommended)
            ‚Ä¢ **30-60 minutes:** Patient, allows AC more time to work

            **Note:** Works with "Minimum Progress Rate" setting below.
          default: 15
          selector:
            number:
              min: 1
              max: 60
              step: 1
              unit_of_measurement: minutes

        minimum_progress_rate:
          name: Minimum Progress Rate
          description: |
            **Minimum acceptable temperature change rate** (¬∞C per minute) before triggering escalation.

            **How it works:**
            ‚Ä¢ System calculates: (current_temp - previous_temp) / time_elapsed
            ‚Ä¢ If rate is below this threshold for the "Stall Escalation Time" ‚Üí escalates power
            ‚Ä¢ Customizable for your AC's capabilities and room characteristics

            **Rate examples:**
            ‚Ä¢ **0.10-0.20¬∞C/min:** Very aggressive (gaming rooms, high-power ACs)
            ‚Ä¢ **0.05-0.10¬∞C/min:** Aggressive (fast AC, small room, tight control)
            ‚Ä¢ **0.02-0.05¬∞C/min:** Responsive (fast AC, good insulation)
            ‚Ä¢ **0.01-0.02¬∞C/min:** Average AC, medium room (recommended)
            ‚Ä¢ **0.005-0.01¬∞C/min:** Slow AC, large room, patient control
            ‚Ä¢ **0.001-0.005¬∞C/min:** Very slow AC or poorly insulated room

            **Example scenarios:**
            ‚Ä¢ **Very Aggressive:** 0.15¬∞C/min = expects 9¬∞C drop per hour (gaming rooms)
            ‚Ä¢ **Aggressive:** 0.08¬∞C/min = expects 4.8¬∞C drop per hour
            ‚Ä¢ **Balanced:** 0.01¬∞C/min = expects 0.6¬∞C drop per hour (recommended)
            ‚Ä¢ **Patient:** 0.005¬∞C/min = expects 0.3¬∞C drop per hour

            **Tip:** Monitor your logs to see typical cooling/heating rates, then set threshold slightly below that.
          default: 0.01
          selector:
            number:
              min: 0.001
              max: 0.5
              step: 0.001
              unit_of_measurement: "¬∞C/min"

        escalation_temp_tolerance:
          name: Temperature Stall Tolerance
          description: |
            **Maximum distance from target** before triggering stall escalation.

            **How it works:**
            ‚Ä¢ **Near-Target Stall:** Escalates if distance ‚â§ this value AND stalled for 15+ min
            ‚Ä¢ **Time-Based Stall:** Escalates if distance > half this value AND poor progress for configured time

            **Tolerance levels:**
            ‚Ä¢ **0.5-1.0¬∞C:** Aggressive response (tight control, escalates early)
            ‚Ä¢ **1.0-2.0¬∞C:** Balanced approach (recommended - default 1.0¬∞C)
            ‚Ä¢ **2.0-3.0¬∞C:** Patient response (allows more drift before escalating)

            **Example (1.0¬∞C setting):**
            ‚Ä¢ If 0.9¬∞C from target and stalled ‚Üí Gentle escalation (Level 1)
            ‚Ä¢ If 0.6¬∞C from target and poor progress ‚Üí Strong escalation (Level 3)

            **Trade-off:** Lower values provide tighter control but may increase power cycling.
          default: 1.0
          selector:
            number:
              min: 0.1
              max: 3.0
              step: 0.1
              unit_of_measurement: "¬∞C"

        extended_stall_multiplier:
          name: Extended Stall Multiplier
          description: |
            **How many times the stall time** before triggering maximum escalation (Level 4/Fan 5).

            **How it works:**
            When AC has been running with poor progress for `stall_escalation_time √ó multiplier`,
            escalation jumps to Level 4 (emergency/maximum power).

            **Examples with stall_escalation_time = 2 minutes:**
            ‚Ä¢ **10x:** Emergency after 20 minutes stuck ‚Üí Very aggressive
            ‚Ä¢ **20x:** Emergency after 40 minutes stuck ‚Üí Aggressive (recommended)
            ‚Ä¢ **30x:** Emergency after 60 minutes stuck ‚Üí Balanced
            ‚Ä¢ **50x:** Emergency after 100 minutes stuck ‚Üí Patient
            ‚Ä¢ **100x:** Emergency after 200 minutes stuck ‚Üí Very patient

            **User scenario (20x multiplier, 2min stall time):**
            ```
            Time 0: AC starts cooling, 25¬∞C ‚Üí 22¬∞C target
            Time 2: Still 25¬∞C, slow progress ‚Üí Level 3 (time-based stall)
            Time 10: Still 24.8¬∞C, poor progress ‚Üí Level 3 (waiting)
            Time 40: Still 24.5¬∞C after 40 min ‚Üí Level 4! (emergency)
            Result: Maximum fan power after extended stalling
            ```

            **When to use lower values (aggressive):**
            ‚Ä¢ Gaming rooms with high, variable heat loads
            ‚Ä¢ Rooms that need fast temperature correction
            ‚Ä¢ Poor insulation or external heat sources
            ‚Ä¢ Testing/debugging escalation behavior

            **When to use higher values (patient):**
            ‚Ä¢ Bedrooms (avoid sudden fan noise increases)
            ‚Ä¢ Well-insulated rooms with stable temps
            ‚Ä¢ Efficient AC units that eventually catch up
            ‚Ä¢ Rooms where you rarely need maximum power

            **Recommendation:** Start with 20x-30x, adjust based on how long your AC typically takes to reach target.
          default: 30
          selector:
            number:
              min: 5
              max: 100
              step: 5
              mode: slider

        enable_dynamic_target_adjustment:
          name: Enable Dynamic Target Adjustment
          description: |
            **SMART ESCALATION BOOST:** Automatically adjust AC target temperature when escalation is active to help struggling AC reach your desired temperature faster.

            **How it works:**
            - **Cooling mode:** Lowers AC target below your desired temp (e.g., 24¬∞C ‚Üí 21¬∞C at Level 3)
            - **Heating mode:** Raises AC target above your desired temp (e.g., 22¬∞C ‚Üí 25¬∞C at Level 3)
            - **Creates buffer zone:** Prevents temp from immediately drifting back
            - **Auto-reverts:** Returns to normal target once temperature stable

            **Why this helps:**
            - AC compressor works harder with more aggressive target
            - Combined with higher fan speed = maximum effectiveness
            - Faster cooling/heating when system detects struggle
            - Prevents getting stuck near target without reaching it

            **Example (cooling with 1.0¬∞C offset):**
            - Level 0: Target 24¬∞C (normal)
            - Level 1: Target 23¬∞C (slightly lower)
            - Level 2: Target 22¬∞C (more aggressive)
            - Level 3: Target 21¬∞C (very aggressive)
            - Level 4: Target 20¬∞C (maximum)

            **Recommended:** Enable for rooms where AC struggles to reach target. Disable for oversized AC units or if you want precise temperature control only.
          default: false
          selector:
            boolean:

        escalation_target_offset:
          name: Escalation Target Offset (per level)
          description: |
            **How much to adjust target temperature PER escalation level** when dynamic target adjustment is enabled.

            **The offset multiplies by escalation level:**
            - **0.5¬∞C/level:** Gentle adjustment (Level 4 = ¬±2¬∞C from desired)
            - **1.0¬∞C/level:** Balanced (Level 4 = ¬±4¬∞C from desired) ‚Üê **Recommended**
            - **1.5¬∞C/level:** Aggressive (Level 4 = ¬±6¬∞C from desired)
            - **2.0¬∞C/level:** Very aggressive (Level 4 = ¬±8¬∞C from desired)

            **Examples with 1.0¬∞C offset:**

            **Cooling (desired: 24¬∞C):**
            - Level 1: 24¬∞C - 1¬∞C = 23¬∞C
            - Level 2: 24¬∞C - 2¬∞C = 22¬∞C
            - Level 3: 24¬∞C - 3¬∞C = 21¬∞C
            - Level 4: 24¬∞C - 4¬∞C = 20¬∞C

            **Heating (desired: 22¬∞C):**
            - Level 1: 22¬∞C + 1¬∞C = 23¬∞C
            - Level 2: 22¬∞C + 2¬∞C = 24¬∞C
            - Level 3: 22¬∞C + 3¬∞C = 25¬∞C
            - Level 4: 22¬∞C + 4¬∞C = 26¬∞C

            **Safety limits:** System will never adjust beyond 10¬∞C (cooling) or 35¬∞C (heating) regardless of offset.

            **Tuning guide:**
            - **Bedroom/quiet rooms:** 0.5¬∞C (gentle, minimal overshoot)
            - **Office/living room:** 1.0¬∞C (balanced)
            - **Gaming room/high heat loads:** 1.5-2.0¬∞C (aggressive, fast recovery)
          default: 1.0
          selector:
            number:
              min: 0.0
              max: 3.0
              step: 0.1
              unit_of_measurement: "¬∞C"

        deescalation_approach_threshold:
          name: De-escalation Approach Threshold
          description: |
            **Degrees from target** when system can de-escalate power.

            ‚Ä¢ **Prevents overshooting** target temperature
            ‚Ä¢ **1.0-2.0¬∞C:** Aggressive de-escalation
            ‚Ä¢ **2.0-3.0¬∞C:** Balanced approach (recommended)
            ‚Ä¢ **3.0-4.0¬∞C:** Conservative, maintains power longer

            **Note:** Works when temperature is trending correctly toward target.
          default: 2.0
          selector:
            number:
              min: 0.1
              max: 4.0
              step: 0.1
              unit_of_measurement: "¬∞C"
        
        helper_temp_history:
          name: Temperature History Helper (Optional)
          description: |
            **Input Number helper** to store previous temperature reading.

            ‚Ä¢ **Tracks temperature changes** over time
            ‚Ä¢ **Required** for dynamic adaptation features
            ‚Ä¢ **Automatically updated** by the system
            ‚Ä¢ **Range:** 0-50¬∞C with 0.1¬∞C steps

            **Example:** `input_number.climate_temp_history_living_room`
          default: []
          selector:
            entity:
              domain: input_number
        
        helper_trend_direction:
          name: Trend Direction Helper (Optional)
          description: |
            **Input Text helper** to track temperature trend direction.

            ‚Ä¢ **Stores:** rising, falling, or stable
            ‚Ä¢ **Required** for dynamic adaptation logic
            ‚Ä¢ **Automatically updated** by the system
            ‚Ä¢ **Used to determine** when to escalate/de-escalate

            **Example:** `input_text.climate_trend_direction_living_room`
          default: []
          selector:
            entity:
              domain: input_text
        
        helper_mode_start_time:
          name: Mode Start Time Helper (Optional)
          description: |
            **Input DateTime helper** to track when current mode started.

            ‚Ä¢ **Timestamp** when current AC mode began
            ‚Ä¢ **Required** for effectiveness calculations
            ‚Ä¢ **Used to determine** how long to wait before changes
            ‚Ä¢ **Automatically updated** by the system

            **Example:** `input_datetime.climate_mode_start_time_living_room`
          default: []
          selector:
            entity:
              domain: input_datetime
        
        helper_effectiveness_score:
          name: Effectiveness Score Helper (Optional)
          description: |
            **Input Number helper** to track how well current mode is working (0-100%).

            ‚Ä¢ **0%:** Mode not working (temperature getting worse)
            ‚Ä¢ **50%:** Mode working slowly
            ‚Ä¢ **100%:** Mode working effectively
            ‚Ä¢ **Used to decide** escalation/de-escalation

            **Example:** `input_number.climate_effectiveness_score_living_room`
          default: []
          selector:
            entity:
              domain: input_number
        
        helper_temp_stable_since:
          name: Temperature Stable Since Helper (Optional)
          description: |
            **Input DateTime helper** to track when temperature became stable.

            ‚Ä¢ **Timestamp** when temperature entered stable range
            ‚Ä¢ **Required** for stability auto-off feature
            ‚Ä¢ **Used to calculate** how long temperature has been stable
            ‚Ä¢ **Automatically updated** by the system

            **Example:** `input_datetime.temp_stable_since_living_room`
          default: []
          selector:
            entity:
              domain: input_datetime
        
        helper_last_transition:
          name: Last Transition Helper (Optional)
          description: |
            **Input Text helper** to track last temperature zone transition.

            ‚Ä¢ **Stores:** to_cooling, to_heating, to_comfort, etc.
            ‚Ä¢ **Used for hysteresis** to prevent rapid switching
            ‚Ä¢ **Prevents oscillation** at temperature boundaries
            ‚Ä¢ **Automatically updated** by the system

            **Example:** `input_text.climate_last_transition_living_room`
          default: []
          selector:
            entity:
              domain: input_text
        
        hysteresis_tolerance:
          name: Hysteresis Tolerance
          description: |
            **Temperature tolerance** for preventing rapid switching (¬±¬∞C).

            ‚Ä¢ **Prevents oscillation** at temperature boundaries
            ‚Ä¢ **0.05-0.15¬∞C:** Very tight control (gaming rooms, precise control)
            ‚Ä¢ **0.15-0.30¬∞C:** Sensitive (may cause more switching)
            ‚Ä¢ **0.30-0.50¬∞C:** Balanced approach (recommended)
            ‚Ä¢ **0.50-1.00¬∞C:** Conservative (less switching)

            **Rule:** System won't change modes unless temperature exceeds threshold by this amount.
          default: 0.3
          selector:
            number:
              min: 0.05
              max: 1.0
              step: 0.01
              unit_of_measurement: "¬∞C"

        ac_minimum_temp:
          name: AC Minimum Temperature Override
          description: |
            **Your AC's actual minimum temperature** (leave at 0 to use AC's reported minimum).

            ‚Ä¢ **Use this if your AC integration reports incorrect limits**
            ‚Ä¢ **Example:** AC reports 7¬∞C minimum but physically can't go below 18¬∞C
            ‚Ä¢ **Leave at 0:** Use the temperature reported by your AC integration (default)
            ‚Ä¢ **Set to actual:** Prevent automation from setting impossible temperatures

            **Why needed:** Some AC integrations report incorrect min/max values. This ensures dynamic targeting respects your AC's physical limits.
          default: 0
          selector:
            number:
              min: 0
              max: 25
              step: 1
              unit_of_measurement: "¬∞C"
              mode: box

        ac_maximum_temp:
          name: AC Maximum Temperature Override
          description: |
            **Your AC's actual maximum temperature** (leave at 0 to use AC's reported maximum).

            ‚Ä¢ **Use this if your AC integration reports incorrect limits**
            ‚Ä¢ **Example:** AC reports 35¬∞C maximum but physically can't go above 30¬∞C
            ‚Ä¢ **Leave at 0:** Use the temperature reported by your AC integration (default)
            ‚Ä¢ **Set to actual:** Prevent automation from setting impossible temperatures

            **Why needed:** Some AC integrations report incorrect min/max values. This ensures dynamic targeting respects your AC's physical limits.
          default: 0
          selector:
            number:
              min: 0
              max: 40
              step: 1
              unit_of_measurement: "¬∞C"
              mode: box

        check_interval_minutes:
          name: Check Interval
          description: |
            **How often to check conditions** and evaluate temperature (in minutes).

            ‚Ä¢ **1-3 minutes:** Very responsive (more CPU usage)
            ‚Ä¢ **5 minutes:** Balanced approach (recommended)
            ‚Ä¢ **10+ minutes:** Conservative (less responsive)

            **Trade-off:** Lower intervals provide tighter control but increase system load.
          default: 5
          selector:
            number:
              min: 1
              max: 30
              step: 1
              unit_of_measurement: minutes
              mode: slider

        enable_wrong_direction_escalation:
          name: Enable Stall & Wrong Direction Escalation
          description: |
            **Incrementally escalate power when temperature stalls or moves the wrong way.**

            **How it works:**
            ‚Ä¢ Checks temperature trend at every effectiveness check (e.g., every 2 minutes)
            ‚Ä¢ **Cooling mode:** If temperature RISING (wrong direction) OR cooling TOO SLOWLY (stalling) ‚Üí add escalation levels
            ‚Ä¢ **Heating mode:** If temperature FALLING (wrong direction) OR heating TOO SLOWLY (stalling) ‚Üí add escalation levels
            ‚Ä¢ Adds levels incrementally until temperature stabilizes or reaches maximum

            **Example (with +1 per check, checking every 2 minutes):**
            ```
            Wrong Direction (temp rising during cooling):
            Time 0: 25.6¬∞C ‚Üí Fan 1 (Base Level 0)
            Time 2: 25.7¬∞C rising ‚Üí Fan 2 (Level 0+1)
            Time 4: 25.8¬∞C rising ‚Üí Fan 3 (Level 0+2)
            Time 6: 25.9¬∞C rising ‚Üí Fan 4 (Level 0+3)

            Stalling (temp falling but TOO slowly):
            Time 0: 23.6¬∞C ‚Üí Fan 2 (cooling at -0.02¬∞C/min - too slow!)
            Time 2: 23.5¬∞C ‚Üí Fan 3 (still -0.02¬∞C/min - add +1 level)
            Time 4: 23.3¬∞C ‚Üí Fan 4 (now -0.1¬∞C/min - fast enough, stops escalating)
            ```

            **When useful:**
            ‚Ä¢ Gaming rooms with variable heat load (PCs, consoles)
            ‚Ä¢ Rooms with external heat sources (sun, appliances, cooking)
            ‚Ä¢ Rooms that stall near target temperature (cooling too slowly)
            ‚Ä¢ Fast response to unexpected temperature changes
            ‚Ä¢ High-occupancy rooms with variable people count

            **Safe to disable if:**
            ‚Ä¢ Your room has stable temperature patterns
            ‚Ä¢ You prefer slower, more conservative escalation
            ‚Ä¢ Testing/debugging automation behavior

            **Advantages over time-based boost:**
            ‚Ä¢ Responds immediately at first effectiveness check
            ‚Ä¢ Smooth, gradual escalation instead of sudden jumps
            ‚Ä¢ Self-correcting (stops when temp stabilizes)
            ‚Ä¢ Simpler to configure and understand

            **Safety:** Disabled by default. Won't affect existing automations.
          default: false
          selector:
            boolean:

        wrong_direction_escalation_per_check:
          name: Stall & Wrong Direction Escalation Per Check
          description: |
            **How many escalation levels to add per effectiveness check when temperature stalls or moves wrong direction.**

            ‚Ä¢ **0:** Disabled (ignore stall/wrong direction, even if feature enabled)
            ‚Ä¢ **+1:** Gentle incremental response (‚≠ê recommended for most rooms)
            ‚Ä¢ **+2:** Aggressive incremental response (for extreme heat loads or persistent stalling)

            **How it works:**
            At each effectiveness check (e.g., every 2 minutes), if temperature is stalling (moving too slowly)
            or moving the wrong direction, this many levels are added to escalation.

            **Example with +1 per check:**
            ```
            Check 1: Base L0, rising ‚Üí L0+1 = Fan 2
            Check 2: Base L0, rising ‚Üí L0+2 = Fan 3
            Check 3: Base L0, rising ‚Üí L0+3 = Fan 4
            Check 4: Base L0, rising ‚Üí L0+4 = Fan 5 (maximum)
            Result: Smooth escalation over 6-8 minutes
            ```

            **Example with +2 per check (aggressive):**
            ```
            Check 1: Base L0, rising ‚Üí L0+2 = Fan 3
            Check 2: Base L0, rising ‚Üí L0+4 = Fan 5 (maximum)
            Result: Reaches maximum in 4 minutes
            ```

            **Recommendation:**
            ‚Ä¢ **Gaming rooms:** +1 (balanced, reaches max in 8 min)
            ‚Ä¢ **Extreme heat loads:** +2 (aggressive, reaches max in 4 min)
            ‚Ä¢ **Stable rooms:** 0 or disable feature entirely
          default: 1
          selector:
            number:
              min: 0
              max: 2
              step: 1

        wrong_direction_min_rate:
          name: Wrong Direction Minimum Rate
          description: |
            Minimum temperature change rate to trigger WRONG DIRECTION escalation (¬∞C/min).

            This detects when temperature moves the OPPOSITE direction (rising during cooling, falling during heating).
            Filters out sensor noise, only triggering when temperature is meaningfully moving the wrong way.

            **Note:** Slow progress (stalling) is detected separately using your "Minimum Progress Rate" setting.

            **Examples:**
            ‚Ä¢ **0.02¬∞C/min:** Very sensitive (1.2¬∞C/hour) - catches slight wrong direction trends
            ‚Ä¢ **0.03¬∞C/min:** Balanced (1.8¬∞C/hour) - filters noise, catches real wrong direction issues
            ‚Ä¢ **0.05¬∞C/min:** Conservative (3¬∞C/hour) - only triggers on clear wrong direction

            **Recommendation:**
            ‚Ä¢ **Most rooms:** 0.02¬∞C/min (detect wrong direction early)
            ‚Ä¢ **Noisy sensors:** 0.03-0.05¬∞C/min (reduce false triggers)
            ‚Ä¢ **Very stable sensors:** 0.01¬∞C/min (maximum sensitivity)
          default: 0.05
          selector:
            number:
              min: 0.01
              max: 0.20
              step: 0.01
              unit_of_measurement: "¬∞C/min"
              mode: slider

    # Notification Settings
    notifications:
      name: "Notification Settings"
      icon: mdi:bell
      collapsed: true
      input:
        enable_notifications:
          name: Enable Notifications
          description: |
            **Enable push notifications** when the climate control system makes changes.

            **Notifications include:** Mode switches, temperature adjustments, and system status updates.
          default: true
          selector:
            boolean:
        
        notification_service:
          name: Notification Service
          description: |
            **Primary notification service** to send alerts to.

            **Common options:** `notify.notify`, `notify.mobile_app_yourphone`, `notify.pushbullet`
          default: notify.notify
          selector:
            text:
        
        additional_notify_services:
          name: Additional Notification Services
          description: |
            Additional services to notify beyond the primary service.

            ‚Ä¢ One service per line
            ‚Ä¢ Useful for multiple people or notification methods
            ‚Ä¢ Examples: notify.mobile_app_phone2, notify.telegram

            Leave empty if only one notification service is needed.
          default: []
          selector:
            text:
              multiple: true

        
        override_timeout:
          name: Manual Override Timeout (hours)
          description: |
            **How long to respect small adjustments** you make while automation is running.

            **WHAT THIS DOES:** When you tweak temperature/fan settings while in Auto/Smart mode,
            automation pauses its adjustments for this duration but **stays in the same mode**.

            **WHEN IT ACTIVATES:** Any manual adjustment while automation is active
            **WHAT CONTINUES:** Presence detection, mode switching, all other automation
            **WHAT PAUSES:** Temperature and fan speed adjustments only

            **Examples:**
            ‚Ä¢ You adjust 23¬∞C ‚Üí 25¬∞C for comfort ‚Üí System won't change it back for X hours
            ‚Ä¢ You turn off AC for pets ‚Üí System won't turn it back on for X hours
            ‚Ä¢ You change fan from Auto to Level 3 ‚Üí System respects your fan choice

            **This is NOT for remote pre-conditioning** - use Manual Mode for that.

            **Recommended:** 2 hours for most situations.
          default: 2
          selector:
            number:
              min: 0
              max: 24
              step: 0.5
              unit_of_measurement: hours
              mode: slider

        manual_mode_timeout:
          name: üéÆ Manual Mode Timeout
          description: |
            **How long to completely bypass ALL automation** when you switch to Manual mode.

            **WHAT THIS DOES:** Manual mode = 100% user control with ZERO automation interference.
            Perfect for **remote pre-conditioning** before arriving home.

            **WHEN IT ACTIVATES:** Only when you switch the control mode to "Manual"
            **WHAT STOPS:** ALL automation - presence detection, temperature control, everything
            **WHAT YOU GET:** Complete control to set any temperature/fan remotely

            **Examples:**
            ‚Ä¢ Set AC to 18¬∞C cold before coming home ‚Üí No presence sensors turn it off
            ‚Ä¢ Heat room to 26¬∞C while away ‚Üí System won't adjust based on "empty room"
            ‚Ä¢ Set specific fan speed for noise ‚Üí Automation won't change it

            **After timeout:** Switches back to Smart mode (AC keeps running at your settings)
            **Then:** Normal automation resumes with presence detection

            **This IS for remote pre-conditioning** - different from Override above!
          default: "4_hours"
          selector:
            select:
              options:
                - label: "Never (Pure Manual - runs until manually changed)"
                  value: "never"
                - label: "1 Hour"
                  value: "1_hour"
                - label: "2 Hours"
                  value: "2_hours"
                - label: "4 Hours (Recommended)"
                  value: "4_hours"
                - label: "8 Hours"
                  value: "8_hours"
                - label: "12 Hours"
                  value: "12_hours"
                - label: "24 Hours"
                  value: "24_hours"


variables:
  climate_list: !input climate_entities
  persons: !input presence_persons
  devices: !input presence_devices
  comfort_zone_action: !input comfort_zone_action
  enable_heating: !input enable_heating_mode
  enable_cooling: !input enable_cooling_mode
  away_action: !input away_mode_action
  temp_sensor: !input temperature_sensor
  use_avg: !input use_average_temperature
  helper_mode: !input helper_last_mode
  helper_change: !input helper_last_change
  helper_mode_before_override: !input helper_mode_before_override
  helper_override_timestamp: !input helper_override_time
  helper_override_flag: !input helper_override_active
  helper_override_timeout_storage: !input helper_override_timeout
  helper_expected_temp: !input helper_expected_temp
  helper_expected_fan: !input helper_expected_fan
  helper_expected_swing: !input helper_expected_swing
  helper_expected_hvac: !input helper_expected_hvac

  # v5.0.0: State Machine helpers
  helper_state_machine: !input helper_state_machine
  helper_state_start: !input helper_state_start
  helper_last_command: !input helper_last_command
  helper_state_checksum: !input helper_state_checksum

  proximity_sensor_input: !input proximity_sensor
  direction_sensor_input: !input direction_sensor
  
  # Simple temperature inputs
  target_temp: !input target_temperature
  comfort_width: !input comfort_zone_width
  aggressiveness: !input temperature_aggressiveness
  advanced_enabled: !input enable_advanced_temp
  
  # Store advanced inputs if enabled
  comfort_min_input: !input comfort_min_temp
  comfort_max_input: !input comfort_max_temp
  cooling_target_input: !input cooling_target_temp
  heating_target_input: !input heating_target_temp

  # Calculate comfort zones based on base target (before weather adjustment)
  base_comfort_min: "{{ comfort_min_input if advanced_enabled else (target_temp - comfort_width) | float }}"
  base_comfort_max: "{{ comfort_max_input if advanced_enabled else (target_temp + comfort_width) | float }}"
  base_cooling_target: "{{ cooling_target_input if advanced_enabled else target_temp | float }}"
  base_heating_target: "{{ heating_target_input if advanced_enabled else target_temp | float }}"

  # v4.0.0: Simplified activation thresholds (no more tiers)
  # Unified cooling/heating activates when temperature exits comfort zone
  cooling_on_threshold: "{{ base_comfort_max }}"     # Turn ON when temp exceeds comfort max
  cooling_off_threshold: "{{ target_temp }}"         # Turn OFF when temp reaches target
  heating_on_threshold: "{{ base_comfort_min }}"     # Turn ON when temp drops below comfort min
  heating_off_threshold: "{{ target_temp }}"         # Turn OFF when temp reaches target
  
  enable_pre_conditioning: !input enable_pre_conditioning
  enable_away_mode: !input enable_away_mode
  enable_notifications: !input enable_notifications
  eco_mode_setpoint_offset: !input eco_mode_setpoint_offset
  # Fan speed settings
  fan_speed_max: !input fan_speed_max
  fan_speed_medium: !input fan_speed_medium
  fan_speed_eco: !input fan_speed_eco
  # Dynamic adaptation settings
  dynamic_enabled: !input enable_dynamic_adaptation
  effectiveness_check_mins: !input effectiveness_check_minutes
  stall_time_threshold: !input stall_escalation_time
  extended_stall_multiplier: !input extended_stall_multiplier
  min_progress_rate: !input minimum_progress_rate
  temp_tolerance: !input escalation_temp_tolerance
  deescalation_threshold: !input deescalation_approach_threshold
  enable_dynamic_target: !input enable_dynamic_target_adjustment
  escalation_offset: !input escalation_target_offset
  helper_temp_history: !input helper_temp_history
  helper_trend: !input helper_trend_direction
  helper_mode_time: !input helper_mode_start_time
  helper_effectiveness: !input helper_effectiveness_score
  last_mode: "{{ states(helper_mode) | default('off') }}"

  # Manual Override Detection settings
  enable_manual_override_detection: !input enable_manual_override_detection

  # Time since last helper change (used for state tracking)
  time_since_change: >
    {% if helper_change and states(helper_change) not in ['unknown', 'unavailable', ''] %}
      {{ ((as_timestamp(now()) - as_timestamp(states(helper_change))) if states(helper_change) | as_timestamp else 0) }}
    {% else %}
      999
    {% endif %}

  # Check actual AC state using hvac_action (compressor activity), not just HVAC mode
  # CRITICAL: An AC in "cool" mode at 18¬∞C target with 28¬∞C current = IDLE (not running)
  # We need to check if compressor is actually running, not just if mode is set
  # v3.19.23 FIX: Prioritize entity state over hvac_action to prevent manual override detection failure
  # Check if any AC entities are unavailable (disconnected)
  # v4.0.2 FIX: Prevent manual override false positive when AC randomly disconnects
  any_ac_unavailable: >
    {% set unavailable_count = namespace(count=0) %}
    {% for entity in climate_list %}
      {% set entity_state = states(entity) %}
      {% if entity_state in ['unavailable', 'unknown'] %}
        {% set unavailable_count.count = unavailable_count.count + 1 %}
      {% endif %}
    {% endfor %}
    {{ unavailable_count.count > 0 }}

  actual_ac_state: >
    {% set ac_states = namespace(any_running=false) %}
    {% for entity in climate_list %}
      {% set entity_state = states(entity) | default('off') %}
      {% set hvac_action = state_attr(entity, 'hvac_action') | default('off') %}

      {# v3.19.23 CRITICAL FIX: Trust entity state FIRST - if state='off', AC is off regardless of hvac_action #}
      {# Problem: User clicks OFF ‚Üí state='off' immediately, but hvac_action lags 30-45s (Daikin delay) #}
      {# Old logic: checked hvac_action first ‚Üí false 'on' reading ‚Üí manual override blocked ‚Üí AC turns back on! #}
      {# Solution: If entity_state='off', skip this entity entirely (it's truly off) #}
      {% if entity_state not in ['off', 'unavailable', 'unknown'] %}
        {# Entity state shows AC is on - confirm with hvac_action OR trust the state #}
        {# Check hvac_action for actual compressor activity when entity is in cooling/heating mode #}
        {% if hvac_action in ['cooling', 'heating', 'drying', 'fan'] or entity_state in ['cool', 'heat', 'heat_cool', 'auto', 'dry', 'fan_only'] %}
          {% set ac_states.any_running = true %}
        {% endif %}
      {% endif %}
    {% endfor %}
    {{ 'on' if ac_states.any_running else 'off' }}
  last_change: "{{ states(helper_change) | default(now()) }}"
  runtime_min: !input min_runtime_minutes
  offtime_min: !input min_off_time_minutes
  enforce_offtime: !input enforce_off_time_protection
  # Smart mode settings
  control_mode_helper: !input helper_control_mode
  presence_detected_helper: !input helper_presence_detected
  presence_validation_helper: !input helper_presence_validation_active
  proximity_override_helper: !input helper_proximity_override
  presence_timeout: !input presence_timeout_minutes
  presence_confirmation_delay: !input presence_confirmation_delay
  home_zone_distance: !input home_zone_distance
  room_sensors: !input room_presence_sensors
  room_name: !input room_name
  room_ble_name: !input room_name
  adjacent_rooms_input: !input adjacent_room_names
  # Parse adjacent room names into a list for BLE detection
  adjacent_room_list: >
    {% if adjacent_rooms_input and adjacent_rooms_input != '' %}
      {% set rooms = [] %}
      {% for room in adjacent_rooms_input.split(',') %}
        {% set rooms = rooms + [room.strip()] %}
      {% endfor %}
      {{ rooms }}
    {% else %}
      []
    {% endif %}
  smart_behavior: !input smart_mode_behavior
  presence_validation: !input presence_validation_mode
  temp_stability_enabled: !input temp_stability_enabled
  stability_tolerance: !input stability_tolerance
  stability_duration: !input stability_duration
  stability_behavior: !input stability_behavior

  # Fan-only mode configuration (v3.18.0)
  fan_only_fan_speed_setting: !input fan_only_fan_speed

  # Fan-only mode detection - use exact fan mode names with capitalization fallbacks
  selected_fan_only_fan_mode: >
    {% set user_choice = fan_only_fan_speed_setting | default('silence') %}
    {% set entity = climate_list[0] if climate_list | length > 0 else none %}
    {% set available_fans = state_attr(entity, 'fan_modes') | list if entity else [] %}

    {% if user_choice == 'silence' %}
      {% if 'silence' in available_fans %}
        silence
      {% elif 'Silence' in available_fans %}
        Silence
      {% elif 'quiet' in available_fans %}
        quiet
      {% elif 'Quiet' in available_fans %}
        Quiet
      {% elif '1' in available_fans %}
        1
      {% elif 'Level 1' in available_fans %}
        Level 1
      {% else %}
        {{ available_fans[0] if available_fans else 'silence' }}
      {% endif %}

    {% elif user_choice == 'quiet' %}
      {% if 'quiet' in available_fans %}
        quiet
      {% elif 'Quiet' in available_fans %}
        Quiet
      {% elif 'silence' in available_fans %}
        silence
      {% elif 'Silence' in available_fans %}
        Silence
      {% elif '1' in available_fans %}
        1
      {% elif 'Level 1' in available_fans %}
        Level 1
      {% else %}
        {{ available_fans[0] if available_fans else 'quiet' }}
      {% endif %}

    {% elif user_choice == '1' %}
      {% if '1' in available_fans %}
        1
      {% elif 'Level 1' in available_fans %}
        Level 1
      {% elif 'silence' in available_fans %}
        silence
      {% elif 'Silence' in available_fans %}
        Silence
      {% elif 'quiet' in available_fans %}
        quiet
      {% elif 'Quiet' in available_fans %}
        Quiet
      {% else %}
        {{ available_fans[0] if available_fans else '1' }}
      {% endif %}

    {% elif user_choice == '2' %}
      {% if '2' in available_fans %}
        2
      {% elif 'Level 2' in available_fans %}
        Level 2
      {% else %}
        {{ available_fans[0] if available_fans else '2' }}
      {% endif %}

    {% elif user_choice == '3' %}
      {% if '3' in available_fans %}
        3
      {% elif 'Level 3' in available_fans %}
        Level 3
      {% else %}
        {{ available_fans[0] if available_fans else '3' }}
      {% endif %}

    {% elif user_choice == '4' %}
      {% if '4' in available_fans %}
        4
      {% elif 'Level 4' in available_fans %}
        Level 4
      {% else %}
        {{ available_fans[0] if available_fans else '4' }}
      {% endif %}

    {% elif user_choice == '5' %}
      {% if '5' in available_fans %}
        5
      {% elif 'Level 5' in available_fans %}
        Level 5
      {% else %}
        {{ available_fans[0] if available_fans else '5' }}
      {% endif %}

    {% else %}
      {{ available_fans[0] if available_fans else 'silence' }}
    {% endif %}

  # Bed comfort mode (v3.12.0)
  bed_comfort_mode: !input bed_comfort_mode
  bed_sensor_manual: !input bed_sensor_manual
  bed_occupied: >
    {{ bed_comfort_mode != 'off' and bed_sensor_manual and is_state(bed_sensor_manual, 'on') }}
  # Bed absence grace period (v3.15.0)
  bed_absence_grace: !input bed_absence_grace_period
  minutes_since_bed_off: >
    {% if bed_sensor_manual and not is_state(bed_sensor_manual, 'on') %}
      {% set last_change = state_attr(bed_sensor_manual, 'last_changed') %}
      {% if last_change %}
        {{ ((as_timestamp(now()) - as_timestamp(last_change)) / 60) | round(0) }}
      {% else %}
        999
      {% endif %}
    {% else %}
      0
    {% endif %}
  # Bed ECO fan-only mode (v3.17.0)
  bed_eco_fan_only_mode: !input bed_eco_fan_only_mode
  bed_eco_stability_minutes: !input bed_eco_stability_minutes
  bed_eco_stability_rate: !input bed_eco_stability_rate
  bed_eco_return_threshold: !input bed_eco_return_threshold
  bed_eco_max_overshoot: !input bed_eco_max_overshoot

  extreme_override: !input extreme_temp_override
  extreme_high: !input extreme_high_temp
  extreme_low: !input extreme_low_temp
  # New v2.1+ features - Scheduling
  enable_scheduling: !input enable_scheduling
  morning_temp: !input morning_temp
  day_temp: !input day_temp
  evening_temp: !input evening_temp
  night_temp: !input night_temp
  enable_weekend_schedule: !input enable_weekend_schedule
  weekend_morning_temp: !input weekend_morning_temp
  weekend_day_temp: !input weekend_day_temp
  weekend_night_temp: !input weekend_night_temp
  # New v2.1+ features - Window Detection
  enable_window_detection: !input enable_window_detection
  window_sensors: !input window_sensors
  window_open_delay: !input window_open_delay
  window_close_delay: !input window_close_delay
  # New v3.2.0 features - Outside Temperature Compensation (replaces old weather compensation)
  enable_outside_temp_compensation: !input enable_outside_temp_compensation
  weather_entity: !input weather_entity
  outdoor_temp_sensor: !input outdoor_temp_sensor
  outside_compensation_factor: !input outside_compensation_factor
  max_outside_compensation: !input max_outside_compensation
  outside_compensation_base_temp: !input outside_compensation_base_temp
  # New v2.1+ helpers - Stability and Hysteresis
  helper_temp_stable_since: !input helper_temp_stable_since
  helper_last_transition: !input helper_last_transition
  hysteresis_tolerance: !input hysteresis_tolerance
  overshoot_strategy: !input target_overshoot_strategy

  # v3.9.22: Calculate target overshoot based on strategy
  # v3.9.29: Added 'none' option for 0¬∞C overshoot
  target_overshoot: >
    {% set strategy = overshoot_strategy | default('moderate') %}
    {% set zone_width = comfort_width | float(1.5) %}

    {% if strategy == 'none' %}
      0.0
    {% elif strategy == 'minimal' %}
      0.5
    {% elif strategy == 'moderate' %}
      {{ (zone_width / 2) | round(2) }}
    {% elif strategy == 'maximum' %}
      {{ zone_width | round(2) }}
    {% else %}
      0.75
    {% endif %}

  ac_minimum_temp: !input ac_minimum_temp
  ac_maximum_temp: !input ac_maximum_temp

  # Override Mode timeout (renamed from adaptive_override_timeout)
  override_timeout: !input override_timeout

  # Manual Mode timeout (standalone feature)
  manual_mode_timeout: !input manual_mode_timeout

  # Convert timeout selection to hours for calculations
  manual_timeout_hours: >
    {% set timeout = manual_mode_timeout %}
    {% if timeout == 'never' %}
      0
    {% elif timeout == '1_hour' %}
      1
    {% elif timeout == '2_hours' %}
      2
    {% elif timeout == '4_hours' %}
      4
    {% elif timeout == '8_hours' %}
      8
    {% elif timeout == '12_hours' %}
      12
    {% elif timeout == '24_hours' %}
      24
    {% else %}
      4
    {% endif %}

  # v4.4.1: Global mode lists for manual override detection and state validation
  # These must be defined here (not in templates) to be accessible throughout the blueprint
  active_modes:
    - cooling
    - heating
    - eco
    - bed_comfort_eco
    - bed_comfort_quiet
    - bed_eco_fan_only
    - comfort_fan_only
    - stability_fan_only

  off_modes:
    - off
    - adaptive_off
    - stability_off
    - smart_off

trigger:
  - platform: state
    entity_id: !input climate_entities
    attribute: current_temperature
    id: temp_change

  # v3.9.35: Fire immediately when climate entity state changes (for instant manual override detection)
  - platform: state
    entity_id: !input climate_entities
    id: climate_state_change

  - platform: state
    entity_id: !input temperature_sensor
    id: external_temp_change

  # Single time pattern trigger based on selected interval
  - platform: time_pattern
    minutes: "/1"
    id: periodic_check

  - platform: state
    entity_id: !input direction_sensor
    to: "towards"
    id: heading_home

  - platform: state
    entity_id: !input direction_sensor
    to: "arrived"
    id: arrived

  - platform: state
    entity_id: !input presence_persons
    id: presence_change

  - platform: state
    entity_id: !input presence_devices
    id: device_change

  # Fire immediately when room presence sensors change (motion, BLE, etc.)
  - platform: state
    entity_id: !input room_presence_sensors
    id: room_presence_change

  # Fire immediately when control mode changes (Manual/Smart/Auto/Override)
  - platform: state
    entity_id: !input helper_control_mode
    id: mode_change

  # Fire when user clicks "Clear Override" button in dashboard
  - platform: state
    entity_id: !input helper_override_active
    from: "on"
    to: "off"
    id: override_cleared_by_user

condition: []

action:
  # v3.11.0: Safety guard - don't run on automation reload/restart (no trigger exists)
  - condition: template
    value_template: "{{ trigger is defined and trigger.id is defined }}"

  # v3.18.13: Sync override timeout helper with blueprint config on every run
  # This ensures dashboard countdown shows correct value even if config changed
  - if:
      - condition: template
        value_template: "{{ helper_override_timeout_storage not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - service: input_number.set_value
        target:
          entity_id: !input helper_override_timeout
        data:
          value: !input override_timeout
        continue_on_error: true

  # v5.0.0: Initialize state machine helpers on first run (if they exist)
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ helper_state_machine not in [none, '', 'unavailable', 'unknown'] and
                 states(helper_state_machine) in ['unknown', 'unavailable', ''] }}
        sequence:
          - service: input_select.select_option
            target:
              entity_id: "{{ helper_state_machine }}"
            data:
              option: "AUTOMATION_OFF"
            continue_on_error: true

          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_state_start }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          - service: input_text.set_value
            target:
              entity_id: "{{ helper_last_command }}"
            data:
              value: ""
            continue_on_error: true

          - service: input_number.set_value
            target:
              entity_id: "{{ helper_state_checksum }}"
            data:
              value: 0
            continue_on_error: true
    default: []

  - if:
      - condition: template
        value_template: "{{ trigger.id == 'mode_change' and helper_mode not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - service: input_text.set_value
        target:
          entity_id: "{{ helper_mode }}"
        data:
          value: "off"
        continue_on_error: true

      # Update mode start time for off-time protection tracking
      - service: input_datetime.set_datetime
        target:
          entity_id: !input helper_mode_start_time
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

  # Store inputs as variables first
  - variables:
      check_interval: !input check_interval_minutes
      # v3.14.0: Two-tier debug system
      event_logging_enabled: !input enable_event_logging
      debug_enabled: !input enable_full_debug_logging
      proximity_sensor: >
        {% if proximity_sensor_input and proximity_sensor_input not in [none, '', 'unavailable', 'unknown'] and proximity_sensor_input is string and proximity_sensor_input != '' %}
          {{ proximity_sensor_input }}
        {% else %}
          none
        {% endif %}
      direction_sensor: >
        {% if direction_sensor_input and direction_sensor_input not in [none, '', 'unavailable', 'unknown'] and direction_sensor_input is string and direction_sensor_input != '' %}
          {{ direction_sensor_input }}
        {% else %}
          none
        {% endif %}
      # Dynamic adaptation variables
      previous_temp: >
        {% if helper_temp_history %}
          {{ states(helper_temp_history) | float(0) }}
        {% else %}
          0
        {% endif %}
      current_trend: >
        {% if helper_trend %}
          {{ states(helper_trend) | default('stable') }}
        {% else %}
          stable
        {% endif %}
      mode_start_time: >
        {% if helper_mode_time %}
          {{ states(helper_mode_time) | default(now()) | as_datetime }}
        {% else %}
          {{ now() }}
        {% endif %}
      should_proceed: >
        {% if trigger.id == 'periodic_check' %}
          {% set mins = now().minute %}
          {% set interval = check_interval | int(1) %}
          {% if interval > 0 %}
            {{ (mins % interval) == 0 }}
          {% else %}
            true
          {% endif %}
        {% else %}
          true
        {% endif %}
  
  # Continue with automation if conditions are met
  - condition: template
    value_template: "{{ should_proceed }}"

  # v3.14.3: Removed spam activation log - event logs already include trigger info

  # Mode change detected - handle transitions between Auto/Smart/Manual/Override modes
  - if:
      - condition: template
        value_template: "{{ trigger.id == 'mode_change' and helper_change not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      # Override is the 4th control mode - no separate flag needed
      # When mode changes, record timestamp for Override timeout tracking

      - variables:
          from_mode: "{{ trigger.from_state.state if trigger.from_state is defined and trigger.from_state else 'unknown' }}"
          to_mode: "{{ trigger.to_state.state if trigger.to_state is defined and trigger.to_state else 'unknown' }}"

      # Record when Override mode was activated (for timeout)
      - if:
          - condition: template
            value_template: "{{ to_mode == 'Override' and helper_override_timestamp not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_override_timestamp }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          # v3.11.16 FIX: Store timeout duration for dashboard countdown timer
          # Without this, manual mode switch to Override shows stale timeout value
          - if:
              - condition: template
                value_template: "{{ helper_override_timeout_storage not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_override_timeout_storage }}"
                data:
                  value: "{{ override_timeout }}"
                continue_on_error: true

          # Store which mode we were in before Override (so we can return to it)
          - if:
              - condition: template
                value_template: "{{ from_mode in ['Auto', 'Smart'] and helper_mode_before_override not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_mode_before_override }}"
                data:
                  value: "{{ from_mode }}"
                continue_on_error: true

      # Clear last_mode when switching modes (fresh start)
      - service: input_text.set_value
        target:
          entity_id: "{{ helper_mode }}"
        data:
          value: "off"
        continue_on_error: true

      # Update mode start time
      - service: input_datetime.set_datetime
        target:
          entity_id: !input helper_mode_start_time
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

      # v3.11.13 FIX: Update helper_change timestamp when mode changes
      # Without this, Manual mode timeout uses stale timestamp from previous AC operation
      # causing immediate/premature timeout and revert to Smart mode
      - condition: template
        value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
      - service: input_datetime.set_datetime
        target:
          entity_id: "{{ helper_change }}"
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

      # NOTE: Can't check debug_enabled here - variables not defined yet
      # This log shows for ALL rooms
      - service: system_log.write
        data:
          message: >
            üéÆ {{ room_name | upper }} MODE CHANGE: {{ from_mode }} ‚Üí {{ to_mode }}
            {% if to_mode == 'Override' %}
            ‚Ä¢ Override activated - automation paused
            ‚Ä¢ Will return to: {{ from_mode if from_mode in ['Auto', 'Smart'] else 'Auto' }}
            ‚Ä¢ Timeout: {{ override_timeout }}h
            {% elif from_mode == 'Override' %}
            ‚Ä¢ Override cleared - automation resuming
            ‚Ä¢ Previous mode was: {{ states(helper_mode_before_override) if helper_mode_before_override else 'unknown' }}
            {% else %}
            ‚Ä¢ Standard mode switch
            {% endif %}
          level: warning

  # v3.11.0: Handle user clicking "Clear Override" button in dashboard
  # v5.0.4: Removed control_mode == 'Override' check - timing issue where mode already changed to Smart
  - if:
      - condition: template
        value_template: "{{ trigger.id == 'override_cleared_by_user' }}"
      - condition: template
        value_template: "{{ control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - variables:
          return_to_mode: "{{ states(helper_mode_before_override) if helper_mode_before_override and states(helper_mode_before_override) in ['Auto', 'Smart'] else 'Auto' }}"

      # Return to previous mode
      - service: input_select.select_option
        target:
          entity_id: "{{ control_mode_helper }}"
        data:
          option: "{{ return_to_mode }}"
        continue_on_error: true

      # v3.11.0 FIX: Sync expected values with actual AC state to prevent re-detection
      # When clearing override, accept the current AC settings as the new baseline
      # This prevents immediate re-detection on next periodic check
      - if:
          - condition: template
            value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ state_attr(climate_list[0], 'temperature') | float(22) }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: "{{ states(climate_list[0]) }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_fan }}"
            data:
              value: "{{ state_attr(climate_list[0], 'fan_mode') | default('unknown') }}"
            continue_on_error: true

      # v5.0.0: Sync NEW snapshot helpers (last_command and state_checksum)
      # This prevents new override detection from re-triggering immediately
      - if:
          - condition: template
            value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - variables:
              actual_temp: "{{ state_attr(climate_list[0], 'temperature') | float(22) | round(1) }}"
              actual_fan: "{{ state_attr(climate_list[0], 'fan_mode') | default('unknown') }}"
              actual_swing: "{{ state_attr(climate_list[0], 'swing_mode') | default('unknown') }}"
              actual_hvac: "{{ states(climate_list[0]) }}"
              sync_snapshot: "hvac={{ actual_hvac }},temp={{ actual_temp }},fan={{ actual_fan }},swing={{ actual_swing }}"
              sync_checksum: >
                {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
                {{ ((actual_temp * 1000) + (actual_fan | string | length) + (actual_swing | string | length) + hvac_codes.get(actual_hvac, 99)) | int(0) }}

          - service: input_text.set_value
            target:
              entity_id: "{{ helper_last_command }}"
            data:
              value: "{{ sync_snapshot }}"
            continue_on_error: true

          - service: input_number.set_value
            target:
              entity_id: "{{ helper_state_checksum }}"
            data:
              value: "{{ sync_checksum }}"
            continue_on_error: true

      # v5.0.4: Also sync helper_last_mode to prevent OLD detection from triggering
      # When clearing override, accept current AC state as baseline for OLD detection too
      - if:
          - condition: template
            value_template: "{{ helper_mode not in [none, 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - variables:
              sync_last_mode: >
                {% set hvac = states(climate_list[0]) %}
                {% if hvac == 'cool' %}
                  cooling_medium
                {% elif hvac == 'heat' %}
                  heating_medium
                {% elif hvac == 'fan_only' %}
                  fan_only
                {% elif hvac == 'dry' %}
                  eco
                {% else %}
                  off
                {% endif %}

          - service: input_text.set_value
            target:
              entity_id: "{{ helper_mode }}"
            data:
              value: "{{ sync_last_mode }}"
            continue_on_error: true

      # Debug log
      # NOTE: Can't check debug_enabled here - variables not defined yet
      # This log shows for ALL rooms
      - service: system_log.write
        data:
          message: >
            ‚úÖ {{ room_name | upper }} OVERRIDE CLEARED BY USER
            ‚Ä¢ User clicked "Clear Override" button
            ‚Ä¢ Returning to: {{ return_to_mode }} mode
            ‚Ä¢ Synced snapshot to actual AC state
            ‚Ä¢ Automation will resume on next trigger
          level: warning

      - stop: "Override cleared - stopping to prevent immediate re-detection on this cycle"

  - variables:
      # v3.12.5 FIX: Store helper_last_mode at START before any updates (moved from line 2975)
      # Must be in THIS variables block so override detection can access it
      helper_last_mode_at_start: "{{ states(helper_mode) | default('off') }}"

      # v4.3.3 FIX: Make main variables available to action templates
      current_temp: >
        {% if temp_sensor %}
          {# v3.9.0: Multi-sensor support for rooms cooled/heated by one AC unit #}
          {% if temp_sensor is string %}
            {# Single sensor (backward compatibility) #}
            {{ states(temp_sensor) | float(25) }}
          {% else %}
            {# Multiple sensors - use min/max/avg strategy based on HVAC mode #}
            {% set temps = namespace(values=[]) %}
            {% for sensor in temp_sensor %}
              {% set temp_value = states(sensor) | float(0) %}
              {% if temp_value > 0 %}
                {% set temps.values = temps.values + [temp_value] %}
              {% endif %}
            {% endfor %}

            {% if temps.values | length > 0 %}
              {% if enable_cooling and not enable_heating %}
                {# Cooling: Use MAX temp (warmest room drives cooling) #}
                {{ temps.values | max | round(1) }}
              {% elif enable_heating and not enable_cooling %}
                {# Heating: Use MIN temp (coldest room drives heating) #}
                {{ temps.values | min | round(1) }}
              {% else %}
                {# Both or neither: Use AVERAGE #}
                {{ (temps.values | sum / temps.values | length) | round(1) }}
              {% endif %}
            {% else %}
              25
            {% endif %}
          {% endif %}
        {% elif use_avg %}
          {% set temps = namespace(values=[]) %}
          {% for entity in climate_list %}
            {% set temp_value = state_attr(entity, 'current_temperature') | float(0) %}
            {% if temp_value > 0 %}
              {% set temps.values = temps.values + [temp_value] %}
            {% endif %}
          {% endfor %}
          {% if temps.values | length > 0 %}
            {{ (temps.values | sum / temps.values | length) | round(1) }}
          {% else %}
            25
          {% endif %}
        {% else %}
          {{ state_attr(climate_list[0], 'current_temperature') | float(25) }}
        {% endif %}
      
      # Calculate base target temperature with scheduling
      scheduled_target_temp: >
        {% if enable_scheduling %}
          {% set hour = now().hour %}
          {% set is_weekend = now().weekday() >= 5 %}
          {% if is_weekend and enable_weekend_schedule %}
            {% if 6 <= hour < 10 %}
              {{ weekend_morning_temp }}
            {% elif 10 <= hour < 22 %}
              {{ weekend_day_temp }}
            {% else %}
              {{ weekend_night_temp }}
            {% endif %}
          {% else %}
            {% if 6 <= hour < 9 %}
              {{ morning_temp }}
            {% elif 9 <= hour < 18 %}
              {{ day_temp }}
            {% elif 18 <= hour < 22 %}
              {{ evening_temp }}
            {% else %}
              {{ night_temp }}
            {% endif %}
          {% endif %}
        {% else %}
          {{ target_temp }}
        {% endif %}
      
      # Get outdoor temperature for outside temperature compensation
      outdoor_temperature: >
        {% if enable_outside_temp_compensation %}
          {% if outdoor_temp_sensor %}
            {{ states(outdoor_temp_sensor) | float(25) }}
          {% else %}
            {{ state_attr(weather_entity, 'temperature') | float(25) }}
          {% endif %}
        {% else %}
          25
        {% endif %}

      # Calculate outside temperature compensation (undershoot for cooling, overshoot for heating)
      # This makes AC work HARDER on extreme days to ACHIEVE the target, not change it
      outside_temp_compensation_amount: >
        {% if enable_outside_temp_compensation %}
          {% set outdoor = outdoor_temperature | float(25) %}
          {% set temp_delta = outdoor - outside_compensation_base_temp %}
          {% set raw_compensation = (temp_delta * outside_compensation_factor) | abs %}
          {{ [[0, raw_compensation] | max, max_outside_compensation] | min | round(1) }}
        {% else %}
          0
        {% endif %}

      # v4.0.0: Comfort zones (tier thresholds removed)
      comfort_min_temp: "{{ base_comfort_min | round(1) }}"
      comfort_max_temp: "{{ base_comfort_max | round(1) }}"
      cooling_target_temp: "{{ base_cooling_target | round(1) }}"
      heating_target_temp: "{{ base_heating_target | round(1) }}"
      
      # Check window sensors
      window_open: >
        {% if enable_window_detection %}
          {% set open = namespace(value=false) %}
          {% for sensor in window_sensors %}
            {% if is_state(sensor, 'on') %}
              {% set open.value = true %}
            {% endif %}
          {% endfor %}
          {{ open.value }}
        {% else %}
          false
        {% endif %}
      
      anyone_home: >
        {% set home = namespace(value=false) %}
        {% for person in persons %}
          {% if is_state(person, 'home') %}
            {% set home.value = true %}
          {% endif %}
        {% endfor %}
        {% if not home.value %}
          {% for device in devices %}
            {% if is_state(device, 'on') or is_state(device, 'PowerOn') %}
              {% set home.value = true %}
            {% endif %}
          {% endfor %}
        {% endif %}
        {{ home.value }}
      
      approaching_home: >
        {% if direction_sensor and proximity_sensor %}
          {{ (is_state(direction_sensor, 'towards') or is_state(direction_sensor, 'arrived')) and
             states(proximity_sensor) | float(10000) < home_zone_distance }}
        {% else %}
          false
        {% endif %}
      
      time_since_change: >
        {% if helper_change and states(helper_change) not in ['unknown', 'unavailable', ''] %}
          {% set change_timestamp = as_timestamp(states(helper_change)) %}
          {% if change_timestamp %}
            {{ (as_timestamp(now()) - change_timestamp) / 60 }}
          {% else %}
            999
          {% endif %}
        {% else %}
          999
        {% endif %}
      
      # Dynamic adaptation calculations
      time_in_current_mode: >
        {% set mode_time_val = states(helper_mode_time) if helper_mode_time else 'unknown' %}
        {% if mode_time_val not in ['unknown', 'unavailable', '', None] %}
          {% set mode_timestamp = as_timestamp(mode_time_val) %}
          {% if mode_timestamp %}
            {{ ((as_timestamp(now()) - mode_timestamp) / 60) | round(1) | abs }}
          {% else %}
            0
          {% endif %}
        {% else %}
          0
        {% endif %}


      # Calculate actual temperature stability time (when temp last changed significantly)
      temp_stability_time: >
        {% if helper_temp_history and helper_temp_stable_since %}
          {% set temp_diff = (current_temp - previous_temp) | abs %}
          {% if temp_diff <= stability_tolerance %}
            {% set stable_since = states(helper_temp_stable_since) %}
            {% if stable_since not in ['unknown', 'unavailable', '', None] %}
              {% set stable_timestamp = as_timestamp(stable_since) %}
              {% if stable_timestamp %}
                {{ ((as_timestamp(now()) - stable_timestamp) / 60) | round(1) }}
              {% else %}
                0
              {% endif %}
            {% else %}
              {# Stable since not set, assume just became stable #}
              0
            {% endif %}
          {% else %}
            {# Temperature changed significantly, stability time is 0 #}
            0
          {% endif %}
        {% else %}
          0
        {% endif %}
      
      temp_change_rate: >
        {% if previous_temp > 0 and current_temp != previous_temp and time_in_current_mode > 0 %}
          {% set actual_elapsed_time = time_in_current_mode | float(1) %}
          {% if actual_elapsed_time > 0 %}
            {{ ((current_temp - previous_temp) / actual_elapsed_time) | round(3) }}
          {% else %}
            0
          {% endif %}
        {% else %}
          0
        {% endif %}

      # v4.3.0: Bed ECO fan-only stability detection
      bed_eco_temp_stable: >
        {{ (temp_change_rate | abs) < bed_eco_stability_rate }}

      bed_eco_at_target: >
        {% set at_or_below = current_temp <= target_temp %}
        {% set not_too_cold = current_temp >= (target_temp - bed_eco_max_overshoot) %}
        {% set above_target = current_temp > target_temp %}
        {% set slightly_above = above_target and current_temp <= (target_temp + bed_eco_return_threshold) %}
        {{ (at_or_below and not_too_cold) or slightly_above }}

      bed_eco_should_fan_only: >
        {% if bed_eco_fan_only_mode != 'enabled' %}
          false
        {% elif last_mode != 'bed_comfort_eco' %}
          false
        {% elif not bed_eco_temp_stable %}
          false
        {% elif time_in_current_mode < bed_eco_stability_minutes %}
          false
        {% elif not bed_eco_at_target %}
          false
        {% else %}
          true
        {% endif %}

      bed_eco_should_return: >
        {{ last_mode == 'bed_eco_fan_only' and current_temp > (target_temp + bed_eco_return_threshold) }}

      calculated_trend: >
        {% if temp_change_rate > 0.2 %}
          rising
        {% elif temp_change_rate < -0.2 %}
          falling  
        {% else %}
          stable
        {% endif %}
      
      temp_stability_detected: >
        {% if temp_stability_enabled and helper_temp_history %}
          {% set temp_diff = (current_temp - previous_temp) | abs %}
          {% set time_threshold = stability_duration | float %}
          {# CRITICAL: Only consider stable if temp is stable AND within comfort zone #}
          {% set in_comfort_zone = current_temp >= comfort_min_temp and current_temp <= comfort_max_temp %}
          {# REMOVED close_to_target hardcoded check - use user-configured stability_tolerance instead #}
          {# REMOVED not_in_continue_mode check - other conditions are sufficient to prevent premature shutoff #}
          {% if temp_diff <= stability_tolerance and calculated_trend == 'stable' and in_comfort_zone %}
            {% if temp_stability_time >= time_threshold %}
              {% if last_mode not in ['off', 'stability_off', 'stability_eco', 'stability_fan_only', 'unavailable', 'unknown', none] %}
                true
              {% else %}
                false
              {% endif %}
            {% else %}
              false
            {% endif %}
          {% else %}
            false
          {% endif %}
        {% else %}
          false
        {% endif %}
      
      distance_from_target: >
        {# v3.9.25 FIX: Calculate distance from OVERSHOOT target, not user target #}
        {# De-escalation must allow AC to reach overshoot target (e.g., 21.8¬∞C) not just user target (22.5¬∞C) #}
        {% set effective_target = target_temp %}
        {% if last_mode == 'cooling' %}
          {% set effective_target = target_temp - target_overshoot %}
        {% elif last_mode == 'heating' %}
          {% set effective_target = target_temp + target_overshoot %}
        {% endif %}
        {{ (current_temp - effective_target) | abs }}

      # Calculate current effectiveness based on temperature progress
      current_effectiveness: >
        {# Always calculate effectiveness automatically #}
        {% if time_in_current_mode < 2 %}
          50
        {% elif last_mode in ['cooling', 'heating'] %}
          {% set target = target_temp %}
          {% set initial_distance = (previous_temp - target) | abs if previous_temp and previous_temp > 0 else distance_from_target %}
          {% set current_distance = distance_from_target | float(0) %}

          {% if initial_distance == 0 or current_distance >= initial_distance %}
            40  {# Active pursuit baseline - making effort even if not improving yet #}
          {% else %}
            {% set progress = ((initial_distance - current_distance) / initial_distance) * 100 %}
            {% set effectiveness = ([progress + 40, 95] | min) | round(0) %}
            {{ effectiveness }}
          {% endif %}
        {% else %}
          50  {# Default effectiveness #}
        {% endif %}

      # Enhanced escalation logic with multiple triggers and graduated response
      escalation_level: >
        {% if not dynamic_enabled %}
          0
        {% else %}
          {% set min_check_time = 5 %}  {# v4.2.1: Increased from 3 to 5 minutes - more patient initial evaluation #}
          {% set emergency_threshold = 5.0 %}  {# v4.2.1: Increased from 4.0 to 5.0¬∞C - true emergencies only #}
          {% set stall_threshold = 2.5 %}  {# v4.2.1: Increased from 2.0 to 2.5¬∞C - less sensitive to stalling #}

          {# Level 0: No escalation needed - minimum checks only #}
          {% if last_mode in ['off', 'eco'] or time_in_current_mode < min_check_time %}
            0  {# Too early to evaluate #}

          {# Level 4: EMERGENCY - Immediate maximum power #}
          {% elif distance_from_target > emergency_threshold and time_in_current_mode >= min_check_time %}
            4  {# Far from target - emergency escalation #}
          {% elif current_effectiveness <= 10 and time_in_current_mode >= 10 %}
            4  {# v4.2.1: Increased from 5 to 10 min - completely ineffective for extended time #}
          {% elif last_mode == 'cooling' and calculated_trend == 'rising' and current_temp > (comfort_max_temp + 1.5) %}
            4  {# v4.2.1: Increased threshold from +1.0 to +1.5¬∞C - cooling but temperature rising significantly #}
          {% elif last_mode == 'heating' and calculated_trend == 'falling' and current_temp < (comfort_min_temp - 1.5) %}
            4  {# v4.2.1: Increased threshold from -1.0 to -1.5¬∞C - heating but temperature falling significantly #}
          {% elif time_in_current_mode >= (stall_time_threshold * extended_stall_multiplier) and temp_change_rate | abs < (min_progress_rate * 0.5) and distance_from_target > 2.0 %}
            4  {# v4.2.1: Changed progress check to 50% of min_progress_rate, distance from 1.5 to 2.0¬∞C - extended stall with truly no progress #}

          {# Level 0: VERY CLOSE TO TARGET - Don't escalate, maintain only #}
          {% elif distance_from_target <= 0.5 and current_effectiveness >= 50 %}
            0  {# v4.2.1: Reduced from 85% to 50% - realistic effectiveness threshold for maintaining comfort #}

          {# Level 1: NEAR-TARGET STALL - Gentle push when close but stalling #}
          {% elif distance_from_target > 0.5 and distance_from_target <= 1.0 and time_in_current_mode >= 20 and (calculated_trend == 'stable' or temp_change_rate | abs < 0.05) %}
            1  {# v4.2.1: Increased from 15 to 20 min - more patience near target #}

          {# Level 3: HIGH - Strong escalation needed #}
          {% elif distance_from_target > 3.5 and time_in_current_mode >= 8 %}
            3  {# v4.2.1: Increased distance from 3.0 to 3.5¬∞C, time from 5 to 8 min - reserve for truly far from target #}
          {% elif current_effectiveness <= 15 and time_in_current_mode >= 12 %}
            3  {# v4.2.1: Reduced from 25% to 15%, increased time from 7 to 12 min - poor effectiveness for extended time #}
          {% elif distance_from_target > stall_threshold and calculated_trend == 'stable' and time_in_current_mode >= 15 %}
            3  {# v4.2.1: Increased from 8 to 15 min - allow more time before declaring stall #}
          {% elif time_in_current_mode >= stall_time_threshold and temp_change_rate | abs < (min_progress_rate * 0.6) and distance_from_target > 1.5 %}
            3  {# v4.2.1: Changed progress check to 60% of min_progress_rate, increased distance from temp_tolerance/2 - time-based stall detection #}

          {# Level 2: MEDIUM - Moderate escalation #}
          {% elif distance_from_target > 2.5 and time_in_current_mode >= 12 %}
            2  {# v4.2.1: Increased distance from 2.0 to 2.5¬∞C, time from 8 to 12 min - moderate distance after reasonable time #}
          {% elif current_effectiveness <= 20 and time_in_current_mode >= 15 %}
            2  {# v4.2.1: CRITICAL FIX - Reduced from 40% to 20%, increased time from 10 to 15 min - realistic effectiveness threshold #}
          {% elif distance_from_target > 2.0 and time_in_current_mode >= (effectiveness_check_mins + 5) %}
            2  {# v4.2.1: Increased distance from 1.5 to 2.0¬∞C, added +5 min to check time - more conservative #}
          {% elif time_in_current_mode >= (stall_time_threshold * 0.75) and temp_change_rate | abs < (min_progress_rate * 0.4) and distance_from_target > 1.0 %}
            2  {# v4.2.1: Changed from stall_time/2 to stall_time*0.75, progress to 40% of min_rate, distance from 0.3 to 1.0¬∞C - early stall warning less aggressive #}

          {# Level 1: LOW - Minor escalation #}
          {% elif distance_from_target > 1.5 and time_in_current_mode >= (effectiveness_check_mins + 8) %}
            1  {# v4.2.1: Increased distance from 1.0 to 1.5¬∞C, added +8 min instead of +2 - gentle escalation only when needed #}
          {% elif current_effectiveness <= 35 and time_in_current_mode >= (effectiveness_check_mins + 10) %}
            1  {# v4.2.1: CRITICAL FIX - Reduced from 60% to 35%, increased time from +5 to +10 min - realistic effectiveness threshold #}

          {% else %}
            0  {# No escalation needed #}
          {% endif %}
        {% endif %}

      # Stall & Wrong-direction incremental escalation (optional feature)
      # v3.8.0: Enhanced to detect BOTH wrong direction AND slow progress (stalling)
      wrong_direction_enabled: !input enable_wrong_direction_escalation
      wrong_direction_per_check: !input wrong_direction_escalation_per_check
      wrong_direction_min_rate: !input wrong_direction_min_rate

      # Detect stall or wrong direction
      # Wrong direction: temp moving opposite way (rising during cooling, falling during heating)
      # Stalling: temp moving right way but TOO slowly (slower than min_progress_rate)
      # v3.16.26 FIX: Stalling detection broken - excluded flat 0.0¬∞C/min case
      # v4.2.1: Made stalling detection less aggressive - use 50% of min_progress_rate as threshold
      # COOLING stalling: temp_change_rate between -(min_progress_rate * 0.5) and 0 (inclusive of 0)
      # HEATING stalling: temp_change_rate between 0 and +(min_progress_rate * 0.5) (inclusive of 0)
      wrong_direction_detected: >
        {{
          (wrong_direction_enabled and wrong_direction_per_check > 0) and
          (
            (last_mode == 'cooling' and
             (temp_change_rate > wrong_direction_min_rate or (temp_change_rate >= -(min_progress_rate * 0.5) and temp_change_rate <= 0))) or
            (last_mode == 'heating' and
             (temp_change_rate < -wrong_direction_min_rate or (temp_change_rate <= (min_progress_rate * 0.5) and temp_change_rate >= 0)))
          )
        }}

      # Helper to track consecutive stall/wrong-direction checks
      # NOTE: This needs a helper entity to persist between runs
      # For now, we'll use a simpler approach: add escalation based on current check only
      wrong_direction_escalation_add: >
        {% if wrong_direction_detected %}
          {{ wrong_direction_per_check | int(1) }}
        {% else %}
          0
        {% endif %}

      # Outside temperature escalation boost - start with higher fan speed on extreme days
      outside_temp_escalation_boost: >
        {% if enable_outside_temp_compensation %}
          {% set outdoor = outdoor_temperature | float(25) %}
          {% set outdoor_delta = outdoor - outside_compensation_base_temp %}
          {% set is_cooling = last_mode == 'cooling' %}
          {% set is_heating = last_mode == 'heating' %}

          {% if is_cooling and outdoor_delta > 0 %}
            {# Hot outside - boost fan speed for cooling #}
            {% if outdoor_delta >= 10 %}
              2  {# 35¬∞C+ outside ‚Üí Start at Fan 3 (escalation +2) #}
            {% elif outdoor_delta >= 5 %}
              1  {# 30¬∞C+ outside ‚Üí Start at Fan 2 (escalation +1) #}
            {% else %}
              0
            {% endif %}
          {% elif is_heating and outdoor_delta < 0 %}
            {# Cold outside - boost fan speed for heating #}
            {% if outdoor_delta <= -10 %}
              2  {# 15¬∞C or colder outside ‚Üí Start at Fan 3 (escalation +2) #}
            {% elif outdoor_delta <= -5 %}
              1  {# 20¬∞C or colder outside ‚Üí Start at Fan 2 (escalation +1) #}
            {% else %}
              0
            {% endif %}
          {% else %}
            0
          {% endif %}
        {% else %}
          0
        {% endif %}

      # Final escalation level includes: normal escalation + wrong-direction + outside temp boost
      # NOTE: All fan speed logic should reference final_escalation_level instead of escalation_level
      # v3.14.2: Bed ECO mode resets escalation to 0 when maintaining in comfort zone
      final_escalation_level: >
        {# v4.3.5 CRITICAL FIX: Don't force escalation to 0 for bed ECO mode #}
        {# Problem: Bed ECO mode has its own escalation tracking, but this was overriding it to 0 #}
        {# This prevented bed ECO from escalating fan speed when room not cooling/heating effectively #}
        {# Solution: Let bed ECO mode use the normal escalation_level from effectiveness tracking #}
        {% set base_level = escalation_level | int(0) %}
        {% set wrong_dir_add = wrong_direction_escalation_add | int(0) %}
        {% set outside_boost = outside_temp_escalation_boost | int(0) %}
        {% set total_level = base_level + wrong_dir_add + outside_boost %}
        {{ [total_level, 4] | min }}

      # Combined AC setpoint adjustment:
      # 1. Outside Temperature Compensation (initial strategy based on outdoor conditions)
      # 2. Dynamic Escalation (performance monitoring adjustments)
      # This gives AC the best starting point AND adjusts based on actual performance
      adjusted_target: >
        {% set base = target_temp %}
        {# v4.0.0 FIX: Simplified mode detection for unified cooling/heating modes #}
        {# When OFF, use current temp to predict which mode will activate #}
        {% set mode_is_cooling = last_mode == 'cooling' %}
        {% set mode_is_heating = last_mode == 'heating' %}
        {% set temp_needs_cooling = current_temp > comfort_max_temp %}
        {% set temp_needs_heating = current_temp < comfort_min_temp %}
        {% set is_cooling = mode_is_cooling or (not mode_is_heating and temp_needs_cooling) %}
        {% set is_heating = mode_is_heating or (not mode_is_cooling and temp_needs_heating) %}

        {# Step 1: Apply outside temperature compensation if enabled #}
        {% if enable_outside_temp_compensation and (is_cooling or is_heating) %}
          {% set outdoor = outdoor_temperature | float(25) %}
          {% set outdoor_delta = outdoor - outside_compensation_base_temp %}

          {% if is_cooling and outdoor_delta > 0 %}
            {# Hot outside - undershoot target to counteract heat influx #}
            {% set base = base - outside_temp_compensation_amount %}
          {% elif is_heating and outdoor_delta < 0 %}
            {# Cold outside - overshoot target to counteract cold influx #}
            {% set base = base + outside_temp_compensation_amount %}
          {% endif %}
        {% endif %}

        {# Step 2: Apply dynamic escalation adjustment if enabled #}
        {% if enable_dynamic_target and final_escalation_level > 0 and (is_cooling or is_heating) %}
          {% set escalation_adj = final_escalation_level * escalation_offset %}
          {% if is_cooling %}
            {% set base = base - escalation_adj %}
          {% elif is_heating %}
            {% set base = base + escalation_adj %}
          {% endif %}
        {% endif %}

        {# Get AC's actual temperature limits with smart fallbacks #}
        {% set user_min = ac_minimum_temp | float(0) %}
        {% set user_max = ac_maximum_temp | float(0) %}
        {% set reported_min = state_attr(climate_list[0], 'min_temp') | float(16) %}
        {% set reported_max = state_attr(climate_list[0], 'max_temp') | float(30) %}

        {# Priority: User override (if non-zero) ‚Üí Reported values ‚Üí Safe defaults #}
        {% set ac_min_temp = user_min if user_min > 0 else reported_min %}
        {% set ac_max_temp = user_max if user_max > 0 else reported_max %}

        {# Safety limits: Respect AC hardware limits while allowing escalation adjustments #}
        {% if is_cooling %}
          {# Allow cooling below target_temp when escalated, but respect AC minimum temp #}
          {{ [ac_min_temp, base] | max | round(1) }}
        {% elif is_heating %}
          {# Allow heating above target_temp when escalated, but respect AC maximum temp #}
          {{ [base, ac_max_temp] | min | round(1) }}
        {% else %}
          {{ target_temp }}
        {% endif %}

      # Hysteresis logic - prevent rapid switching at temperature boundaries
      last_transition: >
        {% if helper_last_transition %}
          {% set transition_state = states(helper_last_transition) | default('none') %}
          {{ 'none' if transition_state in ['unknown', 'unavailable', ''] else transition_state }}
        {% else %}
          none
        {% endif %}
      
      cooling_with_hysteresis: >
        {% if last_transition == 'heating' %}
          {# Coming from heating - need extra margin to switch to cooling #}
          {{ current_temp > (comfort_max_temp + hysteresis_tolerance) }}
        {% else %}
          {# Standard cooling threshold #}
          {{ current_temp > comfort_max_temp }}
        {% endif %}
      
      heating_with_hysteresis: >
        {% if last_transition == 'cooling' %}
          {# Coming from cooling - need extra margin to switch to heating #}
          {{ current_temp < (comfort_min_temp - hysteresis_tolerance) }}
        {% else %}
          {# Standard heating threshold #}
          {{ current_temp < comfort_min_temp }}
        {% endif %}
      
      # Enhanced escalation logic with multiple triggers and graduated response
      should_escalate: >
        {{ final_escalation_level > 0 }}
      
      # Smart mode calculations
      control_mode: >
        {% if control_mode_helper %}
          {{ states(control_mode_helper) | default('Auto') }}
        {% else %}
          Auto
        {% endif %}

      # ===================================
      # v5.0.0: STATE MACHINE VARIABLES
      # ===================================

      current_state_machine: >
        {% if control_mode == 'Manual' %}
          MANUAL_CONTROL
        {% elif control_mode == 'Override' %}
          MANUAL_OVERRIDE_ACTIVE
        {% elif actual_ac_state == 'unavailable' %}
          LOCKED
        {% elif last_mode == 'cooling_high' or last_mode == 'cooling_medium' or last_mode == 'cooling_low' %}
          AUTOMATION_COOLING
        {% elif last_mode == 'heating_high' or last_mode == 'heating_medium' or last_mode == 'heating_low' %}
          AUTOMATION_HEATING
        {% elif last_mode == 'eco' or last_mode == 'bed_comfort_eco' %}
          AUTOMATION_ECO
        {% elif last_mode == 'stability_fan_only' %}
          AUTOMATION_FAN_ONLY
        {% elif last_mode == 'off' %}
          AUTOMATION_OFF
        {% else %}
          AUTOMATION_OFF
        {% endif %}

      actual_state_checksum: >
        {% if climate_list | length > 0 %}
          {% set entity = climate_list[0] %}
          {% set temp = state_attr(entity, 'temperature') | float(0) | round(1) %}
          {% set fan = state_attr(entity, 'fan_mode') | default('unknown') %}
          {% set swing = state_attr(entity, 'swing_mode') | default('unknown') %}
          {% set hvac = states(entity) | default('unknown') %}

          {# Simple checksum: temp*1000 + fan length + swing length + hvac code #}
          {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
          {% set checksum = (temp * 1000) + (fan | string | length) + (swing | string | length) + hvac_codes.get(hvac, 99) %}
          {{ checksum | int(0) }}
        {% else %}
          0
        {% endif %}

      expected_state_from_snapshot: >
        {% set cmd = states(helper_last_command) | default('') %}
        {% if cmd == '' or cmd == 'unknown' %}
          none
        {% else %}
          {% set parsed = namespace(hvac='unknown', temp=0, fan='unknown', swing='unknown') %}
          {% for part in cmd.split(',') %}
            {% set kv = part.split('=') %}
            {% if kv | length == 2 %}
              {% if kv[0] == 'hvac' %}
                {% set parsed.hvac = kv[1] %}
              {% elif kv[0] == 'temp' %}
                {% set parsed.temp = kv[1] | float(0) %}
              {% elif kv[0] == 'fan' %}
                {% set parsed.fan = kv[1] %}
              {% elif kv[0] == 'swing' %}
                {% set parsed.swing = kv[1] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ parsed }}
        {% endif %}

      room_presence_detected: >
        {% set validation_mode = presence_validation | default('any') | lower %}
        {% set sensor_count = room_sensors | length %}
        
        {# If no sensors configured, always return false #}
        {% if sensor_count == 0 %}
          false
        {% else %}
          {# Categorize sensors and check their states #}
          {% set sensors_triggered = namespace(count=0) %}
          {% set ble_detected = namespace(value=false) %}
          {% set motion_detected = namespace(value=false) %}
          {% set other_detected = namespace(value=false) %}
          {% set motion_sensor_count = namespace(count=0) %}
          {% set ble_sensor_count = namespace(count=0) %}
          
          {% for sensor in room_sensors %}
            {% set sensor_state = states(sensor) | lower %}
            {% set is_triggered = false %}
            
            {# Check if this is a BLE/area sensor #}
            {% if sensor.startswith('sensor.') and room_ble_name %}
              {% set ble_sensor_count.count = ble_sensor_count.count + 1 %}
              {% if sensor_state == room_ble_name | lower %}
                {% set ble_detected.value = true %}
                {% set is_triggered = true %}
              {# Check if BLE detected in adjacent rooms #}
              {% elif adjacent_room_list | length > 0 %}
                {% for adjacent_room in adjacent_room_list %}
                  {% if sensor_state == adjacent_room | lower %}
                    {% set ble_detected.value = true %}
                    {% set is_triggered = true %}
                  {% endif %}
                {% endfor %}
              {% endif %}
            
            {# Check if this is a motion/binary sensor #}
            {% elif sensor.startswith('binary_sensor.') %}
              {% set motion_sensor_count.count = motion_sensor_count.count + 1 %}
              {% if is_state(sensor, 'on') or is_state(sensor, 'detected') or is_state(sensor, 'occupied') %}
                {% set motion_detected.value = true %}
                {% set is_triggered = true %}
              {% endif %}
            
            {# Check other sensor types #}
            {% elif is_state(sensor, 'on') or sensor_state in ['home', 'present', 'detected', 'occupied'] %}
              {% set other_detected.value = true %}
              {% set is_triggered = true %}
            {% endif %}
            
            {# Count triggered sensors #}
            {% if is_triggered %}
              {% set sensors_triggered.count = sensors_triggered.count + 1 %}
            {% endif %}
          {% endfor %}
          
          {# Apply validation mode logic #}
          {% if validation_mode == 'all' %}
            {# ALL mode - all sensors must be triggered #}
            {{ sensors_triggered.count == sensor_count }}
            
          {% elif validation_mode == 'majority' %}
            {# MAJORITY mode - more than half must be triggered #}
            {{ sensors_triggered.count > (sensor_count / 2) }}
            
          {% elif validation_mode == 'ble_motion' %}
            {# BLE_MOTION mode - BOTH BLE and motion required (strict, no fallback) #}
            {# Prevents motion blips from triggering without you in room #}
            {# Prevents BLE in adjacent room from triggering without motion #}
            {{ ble_detected.value and motion_detected.value }}

          {% elif validation_mode == 'ble_bed' %}
            {# BLE_BED mode - BOTH BLE and bed sensor required (strict, no fallback) #}
            {# Perfect for bedrooms - only activates when you're in bed with phone #}
            {# Prevents motion blips and BLE-only false triggers #}
            {{ ble_detected.value and other_detected.value }}

          {% elif validation_mode == 'ble_smart' %}
            {# BLE_SMART mode - BLE required + (motion OR bed sensor) #}
            {# Intelligent: detects awake (BLE+motion) OR sleeping (BLE+bed) #}
            {# Still requires BLE to prevent false motion/bed triggers #}
            {{ ble_detected.value and (motion_detected.value or other_detected.value) }}

          {% elif validation_mode == 'motion_only' %}
            {# MOTION_ONLY mode - motion sensor only (WARNING: prone to false triggers) #}
            {# Use presence_confirmation_delay to reduce false positives #}
            {{ motion_detected.value }}

          {% elif validation_mode == 'ble_only' %}
            {# BLE_ONLY mode - BLE sensor only (WARNING: adjacent room detection) #}
            {# Will trigger if phone detected anywhere BLE reaches #}
            {{ ble_detected.value }}

          {% elif validation_mode == 'bed_only' %}
            {# BED_ONLY mode - bed/occupancy sensor only #}
            {# Reliable for weight-based bed sensors #}
            {# Only activates AC when actually in bed #}
            {{ other_detected.value }}

          {% elif validation_mode == 'ble_plus' %}
            {# BLE_PLUS mode - require BLE + at least one other sensor #}
            {% if ble_sensor_count.count > 0 %}
              {{ ble_detected.value and (motion_detected.value or other_detected.value) }}
            {% else %}
              {# No BLE sensors - fallback to ANY mode #}
              {{ sensors_triggered.count > 0 }}
            {% endif %}
            
          {% else %}
            {# ANY mode (default) - any sensor triggered #}
            {{ sensors_triggered.count > 0 }}
          {% endif %}
        {% endif %}
      
      last_presence_time: >
        {% if presence_detected_helper and states(presence_detected_helper) not in ['unknown', 'unavailable', ''] %}
          {{ states(presence_detected_helper) | as_datetime }}
        {% else %}
          {{ now() }}
        {% endif %}
      
      minutes_since_presence: >
        {% if room_presence_detected %}
          0
        {% else %}
          {% set presence_time_val = states(presence_detected_helper) if presence_detected_helper else 'unknown' %}
          {% if presence_time_val not in ['unknown', 'unavailable', '', None] %}
            {% set presence_timestamp = as_timestamp(presence_time_val) %}
            {% if presence_timestamp %}
              {# v4.0.4: Calculate minutes since presence was last detected (for grace period) #}
              {{ ((as_timestamp(now()) - presence_timestamp) / 60) | round(0) | abs }}
            {% else %}
              999
            {% endif %}
          {% else %}
            999
          {% endif %}
        {% endif %}

      minutes_with_presence: >
        {% if room_presence_detected %}
          {# v4.1.0 BULLETPROOF FIX: Trust timer when validation helper actively tracking #}
          {% set has_validation = presence_validation_helper not in [none, '', 'unavailable', 'unknown'] %}
          {% set validation_is_on = is_state(presence_validation_helper, 'on') if has_validation else false %}

          {% set presence_time_val = states(presence_detected_helper) if presence_detected_helper else 'unknown' %}
          {% if presence_time_val not in ['unknown', 'unavailable', '', None] %}
            {% set presence_timestamp = as_timestamp(presence_time_val) %}
            {% if presence_timestamp %}
              {% set minutes = ((as_timestamp(now()) - presence_timestamp) / 60) | round(1) %}

              {# When validation ON, timer is fresh (set at OFF‚ÜíON transition) - trust it completely #}
              {% if has_validation and validation_is_on %}
                {% if minutes < 0 %}
                  0  {# Future timestamp - clock skew #}
                {% else %}
                  {{ minutes }}  {# Trust timer completely - no 2-hour limit #}
                {% endif %}

              {# Legacy mode or validation OFF: apply 2-hour safety threshold #}
              {% else %}
                {% if minutes > 120 %}
                  0  {# Stale timestamp in legacy mode (> 2 hours old) #}
                {% elif minutes < 0 %}
                  0  {# Future timestamp (invalid) #}
                {% else %}
                  {{ minutes }}  {# Valid recent timestamp #}
                {% endif %}
              {% endif %}
            {% else %}
              0
            {% endif %}
          {% else %}
            0
          {% endif %}
        {% else %}
          0
        {% endif %}
      
      current_distance: >
        {% if proximity_sensor %}
          {{ states(proximity_sensor) | float(99999) }}
        {% else %}
          99999
        {% endif %}
      
      proximity_zone: >
        {% if current_distance < home_zone_distance %}
          home
        {% else %}
          away
        {% endif %}
      
      smart_presence_active: >
        {% set effective_mode = control_mode if control_mode != 'Override' else (states(helper_mode_before_override) if helper_mode_before_override else 'Auto') %}
        {# v3.19.2 FIX: Check if AC is running to allow instant re-entry confirmation #}
        {% set ac_currently_running = namespace(value=false) %}
        {% for entity in climate_list %}
          {% if states(entity) not in ['off', 'unavailable', 'unknown'] %}
            {% set ac_currently_running.value = true %}
          {% endif %}
        {% endfor %}
        {# Only bypass delay if validation is TRUE right now (prevents dog/adjacent room false positives) #}
        {% set can_bypass_delay = ac_currently_running.value and room_presence_detected %}
        {% if control_mode == 'Manual' %}
          false
        {% elif effective_mode == 'Smart' %}
          {# v4.3.0: Bed sensor counts as confirmed presence for Smart mode #}
          {# This prevents Smart mode from turning off AC while person is sleeping #}
          {% if bed_occupied %}
            true
          {# v4.3.0: Bed absence grace period - bathroom breaks during sleep #}
          {# Only applies when bed sensor was previously active (last_mode was bed_comfort) #}
          {% elif bed_sensor_manual and not is_state(bed_sensor_manual, 'on') and minutes_since_bed_off < bed_absence_grace and last_mode in ['bed_comfort_quiet', 'bed_comfort_eco', 'bed_eco_fan_only'] %}
            true
          {# Smart mode with grace period for short absences (bathroom trips, etc.) #}
          {# v3.19.2 FIX: Bypass delay if validation TRUE + AC running (instant re-entry) #}
          {% elif room_presence_detected and (minutes_with_presence >= presence_confirmation_delay or can_bypass_delay) %}
            true
          {% elif not room_presence_detected and minutes_since_presence < presence_timeout %}
            {# Grace period applies when: #}
            {# 1. Instant activation (no confirmation delay) - always applies #}
            {# 2. Had prior confirmed presence - left after AC was already running #}
            {# v3.8.2 FIX: Check if last presence timer shows we HAD accumulated enough time #}
            {# This prevents grace period from keeping AC on if someone just walked in briefly #}
            {# v3.11.8 FIX (Option C): Split logic based on AC state #}
            {# - AC OFF: Don't START it when BLE shows you in different room #}
            {# - AC ON: Keep it running (grace period works normally) #}
            {# v4.0.4 FIX: Multi-person BLE detection - check if ANYONE is in this room #}
            {% set ble_sensors = namespace(in_room=[], different_room=[], unknown=[]) %}
            {% if room_ble_name %}
              {% for sensor in room_sensors %}
                {% if sensor.startswith('sensor.') and '_ble_area' in sensor %}
                  {% set current_ble_state = states(sensor) | lower %}
                  {% if current_ble_state == room_ble_name | lower %}
                    {# BLE sensor shows THIS room #}
                    {% set ble_sensors.in_room = ble_sensors.in_room + [sensor] %}
                  {% elif current_ble_state not in ['unknown', 'unavailable', ''] %}
                    {# BLE sensor shows a specific DIFFERENT room #}
                    {% set ble_sensors.different_room = ble_sensors.different_room + [sensor] %}
                  {% else %}
                    {# BLE sensor state is unknown/unavailable #}
                    {% set ble_sensors.unknown = ble_sensors.unknown + [sensor] %}
                  {% endif %}
                {% endif %}
              {% endfor %}
            {% endif %}
            {# ALL BLE sensors in different rooms = nobody here (ignore unknown states) #}
            {% set all_ble_in_different_room = (ble_sensors.in_room | length == 0) and (ble_sensors.different_room | length > 0) %}
            {# Check if AC is currently running (any climate entity in cooling/heating mode) #}
            {% set ac_currently_running = namespace(value=false) %}
            {% for entity in climate_list %}
              {% if states(entity) in ['cool', 'heat', 'heat_cool', 'dry'] %}
                {% set ac_currently_running.value = true %}
              {% endif %}
            {% endfor %}
            {% if all_ble_in_different_room and not ac_currently_running.value %}
              {# ALL BLE sensors show different rooms AND AC is OFF - don't START it via grace period #}
              false
            {% else %}
              {# Either BLE ok, OR AC already running (preserve grace period functionality) #}
              {% set last_timer_val = states(presence_detected_helper) if presence_detected_helper else 'unknown' %}
              {% if last_timer_val not in ['unknown', 'unavailable', '', None] %}
                {% set time_when_left = as_timestamp(last_timer_val) %}
                {% set time_at_timeout = as_timestamp(now()) - (presence_timeout * 60) %}
                {# v4.0.3 FIX: Corrected comparison operator - presence within timeout if time_when_left > time_at_timeout #}
                {# time_at_timeout = "N minutes ago", time_when_left = last presence timestamp #}
                {# Grace period active if presence was detected AFTER the timeout boundary #}
                {{ (presence_confirmation_delay == 0) or (time_when_left > time_at_timeout) }}
              {% else %}
                false
              {% endif %}
            {% endif %}
          {% elif approaching_home and not anyone_home %}
            {# v3.11.7 FIX: Only use approaching_home if nobody is home yet (pre-conditioning) #}
            {# This prevents AC activating when you're already home in a different room #}
            true
          {% else %}
            false
          {% endif %}
        {% elif effective_mode == 'Auto' %}
          {# Auto mode - more permissive presence logic #}
          {% if room_presence_detected %}
            true
          {% elif minutes_since_presence < presence_timeout %}
            true
          {% elif proximity_zone == 'home' %}
            true
          {% elif anyone_home %}
            true
          {% else %}
            false
          {% endif %}
        {% else %}
          false
        {% endif %}
      
      extreme_temp_detected: >
        {% if not extreme_override %}
          false
        {% elif current_temp > extreme_high %}
          hot
        {% elif current_temp < extreme_low %}
          cold
        {% else %}
          false
        {% endif %}

      # ===================================
      # MANUAL OVERRIDE DETECTION (Snapshot/Checksum-Based)
      # ===================================
      manual_override_detection: >
        {% set debug = debug_enabled %}

        {# Step 0: Quick validation checks #}
        {% if not enable_manual_override_detection %}
          false
        {% elif control_mode in ['Override', 'Manual'] %}
          false
        {% elif states(helper_state_machine) == 'LOCKED' %}
          false
        {# v5.0.4 CRITICAL FIX: Skip detection when user just cleared override #}
        {# Problem: Clear handler syncs helpers, but detection runs before sync completes #}
        {# Solution: If trigger is override_cleared_by_user, NEVER detect - it's a deliberate user action #}
        {% elif trigger.id == 'override_cleared_by_user' %}
          false
        {% elif trigger.id != 'climate_state_change' %}
          false
        {% else %}

          {# Step 1: Get actual AC state #}
          {% set actual = namespace(
            hvac=state_attr(climate_list[0], 'hvac_mode')|default('unknown'),
            temp=state_attr(climate_list[0], 'temperature')|float(0),
            fan=state_attr(climate_list[0], 'fan_mode')|default('unknown'),
            swing=state_attr(climate_list[0], 'swing_mode')|default('unknown')
          ) %}

          {# Step 2: Parse expected state from snapshot (inline) #}
          {% set cmd = states(helper_last_command) | default('') %}
          {% if cmd == '' or cmd == 'unknown' %}
            false
          {% else %}
            {% set expected = namespace(hvac='unknown', temp=0, fan='unknown', swing='unknown') %}
            {% for part in cmd.split(',') %}
              {% set kv = part.split('=') %}
              {% if kv | length == 2 %}
                {% if kv[0] == 'hvac' %}
                  {% set expected.hvac = kv[1] %}
                {% elif kv[0] == 'temp' %}
                  {% set expected.temp = kv[1] | float(0) %}
                {% elif kv[0] == 'fan' %}
                  {% set expected.fan = kv[1] %}
                {% elif kv[0] == 'swing' %}
                  {% set expected.swing = kv[1] %}
                {% endif %}
              {% endif %}
            {% endfor %}

            {# Step 3: Fast checksum comparison #}
            {% set stored_checksum = states(helper_state_checksum) | int(0) %}
            {% if actual_state_checksum == stored_checksum %}
              false
            {% else %}

              {# Step 4: Detailed parameter comparison #}
              {% set hvac_diff = (expected.hvac | lower != actual.hvac | lower) %}
              {% set temp_diff = ((expected.temp - actual.temp) | abs > 0.5) %}
              {% set fan_diff = (expected.fan | lower != actual.fan | lower) %}
              {% set swing_diff = (expected.swing | lower != actual.swing | lower) %}

              {# Step 5: Filter safe operational changes #}
              {% set time_in_state = (as_timestamp(now()) - as_timestamp(states(helper_state_start))) %}

              {% if expected.hvac == 'off' and actual.hvac in ['cool','heat','auto'] and time_in_state < 30 %}
                false
              {% elif temp_diff and (expected.temp - target_temp)|abs < 0.3 %}
                false
              {% elif states(helper_state_machine) == 'LOCKED' and time_in_state < 120 %}
                false
              {% elif hvac_diff or temp_diff or fan_diff or swing_diff %}
                true
              {% else %}
                false
              {% endif %}

            {% endif %}
          {% endif %}
        {% endif %}

      # v3.11.0: Override is now a control mode, no separate flag needed

      should_activate: >
        {# v3.11.0: Override mode = automation paused, just like Manual mode #}
        {% if control_mode == 'Override' %}
          false
        {# v3.9.20 FIX: Runtime protection overrides ALL activation logic #}
        {# v3.11.8 FIX: Runtime protection should only apply when AC is actually still running #}
        {# If user manually turned off AC, respect that even if runtime_min not reached #}
        {% elif last_mode in ['cooling', 'heating'] and time_in_current_mode < runtime_min and actual_ac_state == 'on' %}
          {# ABSOLUTE RUNTIME PROTECTION: AC must stay on for minimum runtime regardless of presence, temperature, or mode #}
          true
        {% elif (last_mode == 'off' or actual_ac_state == 'off') and enforce_offtime and time_in_current_mode <= offtime_min %}
          {# ABSOLUTE OFF-TIME PROTECTION: AC must stay off for minimum off-time regardless of presence or temperature #}
          false
        {% elif control_mode == 'Manual' %}
          {# In manual mode, only activate for extreme temperatures with presence #}
          {% if extreme_temp_detected not in [false, 'false'] and (room_presence_detected or approaching_home) %}
            true
          {% else %}
            false
          {% endif %}
        {% elif control_mode == 'Smart' %}
          {# v4.7.2 FIX: Smart mode should ALWAYS respect smart_presence_active #}
          {# Removed redundant "AC running" check that prevented turn-off when presence lost #}
          {{ smart_presence_active }}
        {% else %}
          {{ anyone_home or approaching_home }}
        {% endif %}

      should_activate_reason: >
        {# DEBUG: Track which branch set should_activate #}
        {% if control_mode == 'Override' %}
          OVERRIDE_MODE
        {% elif last_mode in ['cooling', 'heating'] and time_in_current_mode < runtime_min and actual_ac_state == 'on' %}
          RUNTIME_PROTECTION (time={{ time_in_current_mode }}min < {{ runtime_min }}min)
        {% elif (last_mode == 'off' or actual_ac_state == 'off') and enforce_offtime and time_in_current_mode <= offtime_min %}
          OFFTIME_PROTECTION
        {% elif control_mode == 'Manual' %}
          MANUAL_MODE (extreme={{ extreme_temp_detected }}, presence={{ room_presence_detected }})
        {% elif control_mode == 'Smart' %}
          SMART_MODE (smart_presence_active={{ smart_presence_active }})
        {% else %}
          AUTO_MODE (anyone_home={{ anyone_home }}, approaching={{ approaching_home }})
        {% endif %}


  # Continue to next actions - variables calculated successfully

  # v3.9.35 DEBUG: Log after variables calculated
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [1/18] üîç {{ room_name | upper }} AUTOMATION FLOW DEBUG

            üìä Trigger & State:
                ‚Ä¢ Trigger ID: {{ trigger.id }}
                ‚Ä¢ Last Mode: {{ states(helper_mode) }}
                ‚Ä¢ Actual AC State: {{ actual_ac_state }}
                ‚Ä¢ Manual Override Detected: {{ manual_override_detection }}
          level: warning

  # v3.12.5 DEBUG: Detailed manual override detection trace
  # v4.2.0: Added context-based detection logging
  # v4.3.7: Enhanced to show WHY override was triggered
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [2/18] üîç {{ room_name | upper }} MANUAL OVERRIDE DEBUG

            üìä Trigger & Control:
                ‚Ä¢ Trigger ID: {{ trigger.id }}
                ‚Ä¢ Control Mode: {{ control_mode }}
                ‚Ä¢ Last Mode at Start: {{ helper_last_mode_at_start }}
                ‚Ä¢ Actual AC State: {{ actual_ac_state }}

            ‚è±Ô∏è Timing Detection:
                ‚Ä¢ Time Since Change: {{ time_since_change | round(1) }} seconds
            üå°Ô∏è Temperature Target Status:
                ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                ‚Ä¢ Target Temp: {{ target_temp }}¬∞C
                ‚Ä¢ Overshoot: {{ target_overshoot }}¬∞C

            üîç Context Detection:
                ‚Ä¢ Trigger Context User ID: {{ trigger.to_state.context.user_id if trigger.to_state is defined and trigger.to_state.context is defined else 'none' }}
                ‚Ä¢ Trigger Context Parent ID: {{ trigger.to_state.context.parent_id if trigger.to_state is defined and trigger.to_state.context is defined else 'none' }}

            üìã Helper States:
                ‚Ä¢ Expected HVAC: {{ states(helper_expected_hvac) if helper_expected_hvac else 'N/A' }}
                ‚Ä¢ Expected Temp: {{ states(helper_expected_temp) if helper_expected_temp else 'N/A' }}¬∞C
                ‚Ä¢ Expected Fan: {{ states(helper_expected_fan) if helper_expected_fan else 'N/A' }}

            üéØ Detection Results:
                ‚Ä¢ Manual Override Detected: {{ manual_override_detection }}
                ‚Ä¢ Override enabled: {{ enable_manual_override_detection }}
                ‚Ä¢ any_ac_unavailable: {{ any_ac_unavailable }}

            {% if manual_override_detection %}
            üö® OVERRIDE TRIGGERED - Snapshot Mismatch Detected
                ‚Ä¢ Last Snapshot: {{ states(helper_last_command) if helper_last_command else 'N/A' }}
                ‚Ä¢ State Machine: {{ states(helper_state_machine) if helper_state_machine else 'N/A' }}
            {% endif %}
          level: warning

  # v4.3.6 FIX: Removed problematic debug logging that accessed variables inside override detection template
  # Those variables (is_manual_off, needs_timing_fallback, etc.) are not in scope here

  # v3.12.5 DEBUG: Log should_activate value
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [3/18] üîç {{ room_name | upper }} SHOULD_ACTIVATE CHECK

            üìä Control Mode Analysis:
                ‚Ä¢ Control Mode (Variable): {{ control_mode }}
                ‚Ä¢ Control Mode Helper (Actual): {{ states(control_mode_helper) }}
                ‚Ä¢ Should Activate: {{ should_activate }}
                ‚Ä¢ Activation Reason: {{ should_activate_reason }}

            üîç Key Variables:
                ‚Ä¢ smart_presence_active: {{ smart_presence_active }}
                ‚Ä¢ room_presence_detected: {{ room_presence_detected }}
                ‚Ä¢ last_mode: {{ last_mode }}
                ‚Ä¢ actual_ac_state: {{ actual_ac_state }}
                ‚Ä¢ time_in_current_mode: {{ time_in_current_mode | round(1) }}min
                ‚Ä¢ anyone_home: {{ anyone_home }}
                ‚Ä¢ approaching_home: {{ approaching_home }}
          level: warning

  - condition: template
    value_template: "{{ true }}"  # Always continue

  # v4.3.2 FIX: DELETED premature helper_expected_hvac update that caused race condition
  # Problem: Updating helper BEFORE choose blocks execute causes manual detection to see stale state
  # Solution: The automation_intends_to_turn_off variable now handles this case without updating helpers prematurely

  # DISABLED: No longer auto-switching to Manual mode when manual changes detected
  # The automation will continue to work normally even if user manually adjusts AC

  # v3.16.0: NEW PRESENCE VALIDATION STATE TRANSITION TRACKING
  # =============================================================
  # This fixes the bug where presence timer accumulates time when only PARTIAL validation is met
  # (e.g., bed sensor + mmWave active but no BLE in ble_smart mode)
  #
  # OLD BEHAVIOR (BROKEN):
  # - Timer accumulated time whenever room_presence_detected was TRUE
  # - BLE_SMART: Bed + mmWave (no BLE) would set timer, then BLE arrival would use old timer
  # - Result: Confirmation delay bypassed, AC activates too early
  #
  # NEW BEHAVIOR (FIXED):
  # - Track validation state transitions (FALSE ‚Üí TRUE)
  # - Reset timer ONLY when validation state changes from OFF to ON
  # - Timer only accumulates when FULL validation continuously met
  #
  # EXAMPLE WITH BLE_SMART (your scenario):
  # 1. Julia in bed + mmWave (no BLE) ‚Üí validation_helper = OFF, timer expired
  # 2. Chris BLE enters ‚Üí validation changes OFF ‚Üí ON ‚Üí Timer RESETS to NOW
  # 3. 10 min later ‚Üí Timer shows 10 min ‚Üí AC can activate
  # 4. Chris BLE leaves ‚Üí validation changes ON ‚Üí OFF ‚Üí Timer expires
  # =============================================================

  # Update presence validation state helper when room_presence_detected changes
  - if:
      - condition: template
        value_template: "{{ presence_validation_helper not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - if:
          - condition: template
            value_template: "{{ room_presence_detected and is_state(presence_validation_helper, 'off') }}"
        then:
          # FALSE ‚Üí TRUE transition detected: Set validation helper to ON and reset timer
          - service: input_boolean.turn_on
            target:
              entity_id: "{{ presence_validation_helper }}"
            continue_on_error: true

          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ presence_detected_helper }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ not room_presence_detected and is_state(presence_validation_helper, 'on') }}"
        then:
          # TRUE ‚Üí FALSE transition detected: Set validation helper to OFF and expire timer
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ presence_validation_helper }}"
            continue_on_error: true

          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ presence_detected_helper }}"
            data:
              # v4.0.4 FIX: Set to NOW when presence lost (allows grace period to work)
              # Grace period counts minutes_since_presence from this timestamp
              # Sentinel value set later if user stays gone beyond threshold
              datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
            continue_on_error: true

  # LEGACY FALLBACK: For automations created before v3.16.0 without presence_validation_helper
  # This preserves the old (buggy) behavior for backward compatibility
  # Users should add the new helper to get the fixed behavior
  - if:
      - condition: template
        value_template: "{{ presence_validation_helper in [none, '', 'unavailable', 'unknown'] }}"
      - condition: template
        value_template: "{{ room_presence_detected and presence_detected_helper not in [none, '', 'unavailable', 'unknown'] }}"
      - condition: template
        value_template: >
          {% if presence_detected_helper and states(presence_detected_helper) not in ['unknown', 'unavailable', ''] %}
            {% set last_presence_timestamp = as_timestamp(states(presence_detected_helper)) %}
            {% set current_timestamp = as_timestamp(now()) %}
            {% set minutes_since_timer_set = (current_timestamp - last_presence_timestamp) / 60 %}
            {{ minutes_since_timer_set >= (presence_timeout + 1) }}
          {% else %}
            false
          {% endif %}
    then:
      - service: input_datetime.set_datetime
        target:
          entity_id: "{{ presence_detected_helper }}"
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

  # Legacy fallback for timer expiration when presence lost
  - if:
      - condition: template
        value_template: "{{ presence_validation_helper in [none, '', 'unavailable', 'unknown'] }}"
      - condition: template
        value_template: "{{ not room_presence_detected and presence_detected_helper not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - service: input_datetime.set_datetime
        target:
          entity_id: "{{ presence_detected_helper }}"
        data:
          datetime: "{{ (now() - timedelta(minutes=presence_timeout + 1)).strftime('%Y-%m-%d %H:%M:%S') }}"
        continue_on_error: true

  # v3.11.0: ACTIVATE Override Mode - Switch control_mode to "Override" when manual change detected
  # v3.12.5 DEBUG: Log Override activation conditions
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [4/18] üîç {{ room_name | upper }} OVERRIDE ACTIVATION CHECK

            üìä Override Conditions:
                ‚Ä¢ Manual Override Detected: {{ manual_override_detection }}
                ‚Ä¢ Control Mode: {{ control_mode }}
                ‚Ä¢ Not Manual/Override Mode: {{ control_mode not in ['Manual', 'Override'] }}
                ‚Ä¢ Override Timeout: {{ override_timeout }}

            üõ°Ô∏è Helper Validation:
                ‚Ä¢ Control Mode Helper: {{ control_mode_helper }}
                ‚Ä¢ Helper Valid: {{ control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}

            ‚úÖ Will Activate Override: {{ manual_override_detection and control_mode not in ['Manual', 'Override'] and override_timeout > 0 and control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}
          level: warning

  # v5.0.0: Snapshot-based override detection (only method)
  # v5.0.4 CRITICAL FIX: Don't activate override when user just clicked clear button OR when feature is disabled
  # v4.7.1 FIX: Don't re-detect override when mode_change trigger is FROM Override (clearing override)
  # v4.7.2 CRITICAL FIX: Only detect override when USER manually changed AC (check context.user_id)
  - if:
      - condition: template
        value_template: "{{ enable_manual_override_detection }}"
      - condition: template
        value_template: >
          {{
            manual_override_detection
            and control_mode not in ['Manual', 'Override']
            and override_timeout > 0
          }}
      - condition: template
        value_template: "{{ control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}"
      - condition: template
        value_template: >
          {{
            not (trigger.id == 'mode_change'
            and trigger.from_state is defined
            and trigger.from_state.state == 'Override')
          }}
      - condition: template
        value_template: >
          {% set has_user_context = trigger.to_state is defined and trigger.to_state.context is defined and trigger.to_state.context.user_id is not none %}
          {{ has_user_context }}
    then:
      # Change mode to Override
      - service: input_select.select_option
        target:
          entity_id: "{{ control_mode_helper }}"
        data:
          option: "Override"
        continue_on_error: true

      # Turn on visual indicator for dashboard
      - if:
          - condition: template
            value_template: "{{ helper_override_flag not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_boolean.turn_on
            target:
              entity_id: "{{ helper_override_flag }}"
            continue_on_error: true

      # Store timeout duration for dashboard countdown
      - if:
          - condition: template
            value_template: "{{ helper_override_timeout_storage not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_override_timeout_storage }}"
            data:
              value: "{{ override_timeout }}"
            continue_on_error: true

      # The mode_change trigger will handle recording timestamp and previous mode

      # Debug log
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üö® {{ room_name | upper }} MANUAL OVERRIDE ACTIVATED
                ‚Ä¢ Reason: Manual change detected (user turned AC {{ 'on' if actual_ac_state == 'on' else 'off' }} or changed settings)
                ‚Ä¢ Previous mode: {{ control_mode }}
                ‚Ä¢ Will timeout in {{ override_timeout }}h
                ‚Ä¢ Automation paused
              level: warning

      # v3.11.9 FIX: Stop automation immediately to prevent control logic from running with stale control_mode variable
      # The control_mode variable is calculated once at automation start. Even though we just changed
      # control_mode_helper to "Override", the variable still holds the old value (e.g., "Smart").
      # If we continue, the control logic will see control_mode="Smart" and turn AC back on!

      # v3.14.0: Always-on manual override event logging
      - if:

          - condition: template

            value_template: "{{ event_logging_enabled }}"

        then:
      - service: system_log.write
        data:
          message: >
            {% set within_hw_delay = ((as_timestamp(now()) - as_timestamp(states(helper_change))) < 30) if states(helper_change) not in ['unknown', 'unavailable', ''] else false %}
            {% set is_manual_off = (helper_last_mode_at_start in ['cooling', 'heating', 'eco', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] and actual_ac_state == 'off' and not within_hw_delay) %}
            {% set is_manual_on = (helper_last_mode_at_start in ['off', 'stability_off', 'smart_off'] and actual_ac_state == 'on' and not within_hw_delay) %}
            {% set expected_temp = states(helper_expected_temp) | float(0) %}
            {% set actual_temp = state_attr(climate_list[0], 'temperature') | float(0) if climate_list | length > 0 else 0 %}
            {% set is_temp_manual = (expected_temp > 0 and actual_temp > 0 and (expected_temp - actual_temp) | abs > 0.5 and not within_hw_delay and actual_ac_state == 'on') %}
            {% set expected_fan = states(helper_expected_fan) | default('unknown') %}
            {% set actual_fan = state_attr(climate_list[0], 'fan_mode') | default('unknown') if climate_list | length > 0 else 'unknown' %}
            {% set is_fan_manual = (expected_fan not in ['unknown', 'unavailable', '', 'none'] and actual_fan not in ['unknown', 'unavailable', '', 'none'] and expected_fan | lower != actual_fan | lower and not within_hw_delay and actual_ac_state == 'on') %}
            {% set expected_swing = states(helper_expected_swing) | default('unknown') %}
            {% set actual_swing = state_attr(climate_list[0], 'swing_mode') | default('unknown') if climate_list | length > 0 else 'unknown' %}
            {% set is_swing_manual = (expected_swing not in ['unknown', 'unavailable', '', 'none'] and actual_swing not in ['unknown', 'unavailable', '', 'none'] and expected_swing | lower != actual_swing | lower and not within_hw_delay and actual_ac_state == 'on') %}
            {% set expected_hvac = states(helper_expected_hvac) | default('unknown') %}
            {% set actual_hvac = states(climate_list[0]) | default('unknown') if climate_list | length > 0 else 'unknown' %}
            {% set is_hvac_manual = (expected_hvac not in ['unknown', 'unavailable', '', 'none', 'off'] and actual_hvac not in ['unknown', 'unavailable', '', 'none', 'off'] and expected_hvac != actual_hvac and not within_hw_delay and actual_ac_state == 'on') %}
            üü° {{ room_name | upper }} MANUAL OVERRIDE DETECTED

            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            üìä USER INFO:
            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            Changed Parameter: {% if is_manual_off %}HVAC Mode (ON ‚Üí OFF){% elif is_manual_on %}HVAC Mode (OFF ‚Üí ON){% elif is_temp_manual %}Temperature Setpoint{% elif is_fan_manual %}Fan Speed{% elif is_swing_manual %}Swing Mode{% elif is_hvac_manual %}HVAC Mode{% else %}Unknown{% endif %}

            Expected vs Actual:
            {% if is_manual_off or is_manual_on %}
                    ‚Ä¢ Expected HVAC: {{ states(helper_expected_hvac) | default('unknown') }}
                    ‚Ä¢ Actual HVAC: {{ states(climate_list[0]) if climate_list | length > 0 else 'unknown' }}
            {% elif is_temp_manual %}
                    ‚Ä¢ Expected Temp: {{ states(helper_expected_temp) | float(0) }}¬∞C
                    ‚Ä¢ Actual Temp: {{ state_attr(climate_list[0], 'temperature') | float(0) if climate_list | length > 0 else 'unknown' }}¬∞C
            {% elif is_fan_manual %}
                    ‚Ä¢ Expected Fan: {{ states(helper_expected_fan) | default('unknown') }}
                    ‚Ä¢ Actual Fan: {{ state_attr(climate_list[0], 'fan_mode') | default('unknown') if climate_list | length > 0 else 'unknown' }}
            {% elif is_swing_manual %}
                    ‚Ä¢ Expected Swing: {{ states(helper_expected_swing) | default('unknown') }}
                    ‚Ä¢ Actual Swing: {{ state_attr(climate_list[0], 'swing_mode') | default('unknown') if climate_list | length > 0 else 'unknown' }}
            {% endif %}

            Time Since Last Change: {{ time_since_change | round(1) }}s
            Control Mode: {{ control_mode }} ‚Üí Override Mode
            Override Duration: {{ override_timeout }}h (configurable timeout)

            üéÆ Automation Response:
            ‚Ä¢ Automation paused to respect your manual changes
            ‚Ä¢ Will automatically resume after {{ override_timeout }}h timeout
            ‚Ä¢ Or manually clear override via dashboard button

            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            üîç DEBUG DATA (for troubleshooting):
            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            v5.0.0 Manual Override Detection (Snapshot-Based):
                ‚Ä¢ Override Detected: {{ manual_override_detection }}
                ‚Ä¢ Detection Method: Snapshot/Checksum Comparison

            v5.0.0 State Machine Data:
                ‚Ä¢ Current state: {{ states(helper_state_machine) | default('not initialized') }}
                ‚Ä¢ Actual checksum: {{ actual_state_checksum }}
                ‚Ä¢ Stored checksum: {{ states(helper_state_checksum) | default('not initialized') }}
                ‚Ä¢ Checksum match: {{ actual_state_checksum == (states(helper_state_checksum) | int(0)) }}
                ‚Ä¢ Last command snapshot: {{ states(helper_last_command) | default('not initialized') }}
                ‚Ä¢ Expected from snapshot: {{ expected_state_from_snapshot if expected_state_from_snapshot is not none else 'none' }}

            Current State:
                ‚Ä¢ helper_last_mode: {{ states(helper_mode) | default('unknown') }}
                ‚Ä¢ actual_ac_state: {{ actual_ac_state }}

            Override Configuration:
                ‚Ä¢ control_mode_before: {{ control_mode }}
                ‚Ä¢ override_timeout: {{ override_timeout }}h
                ‚Ä¢ current_hour: {{ now().hour }}

            Trigger Info:
                ‚Ä¢ trigger.id: {{ trigger.id }}
                ‚Ä¢ trigger.entity_id: {{ trigger.entity_id if trigger.entity_id is defined else 'N/A' }}
                ‚Ä¢ trigger.from_state: {{ trigger.from_state if trigger.from_state is defined else 'N/A' }}
                ‚Ä¢ trigger.to_state: {{ trigger.to_state if trigger.to_state is defined else 'N/A' }}
          level: warning

      - stop: "Manual override detected - stopping automation to prevent interference with user's manual changes"

  # v3.11.0: CLEAR Override when button clicked (boolean turned off) - runs every automation cycle
  - if:
      - condition: template
        value_template: "{{ control_mode == 'Override' and helper_override_flag not in [none, '', 'unavailable', 'unknown'] and is_state(helper_override_flag, 'off') }}"
      - condition: template
        value_template: "{{ control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - variables:
          return_to_mode: "{{ states(helper_mode_before_override) if helper_mode_before_override and states(helper_mode_before_override) in ['Auto', 'Smart'] else 'Auto' }}"

      - service: input_select.select_option
        target:
          entity_id: "{{ control_mode_helper }}"
        data:
          option: "{{ return_to_mode }}"
        continue_on_error: true

      # Sync expected values to prevent re-detection
      - if:
          - condition: template
            value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ state_attr(climate_list[0], 'temperature') | float(22) }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: "{{ states(climate_list[0]) }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_fan }}"
            data:
              value: "{{ state_attr(climate_list[0], 'fan_mode') | default('unknown') }}"
            continue_on_error: true

  # v3.11.0: AUTO-CLEAR Override Mode - Return to previous mode when timeout expires
  - if:
      - condition: template
        value_template: "{{ control_mode == 'Override' and override_timeout > 0 }}"
      - condition: template
        value_template: >
          {% if helper_override_timestamp and states(helper_override_timestamp) not in ['unknown', 'unavailable', ''] %}
            {% set override_time = as_timestamp(states(helper_override_timestamp)) %}
            {% if override_time %}
              {% set time_since_override = (as_timestamp(now()) - override_time) / 3600 %}
              {{ time_since_override >= override_timeout }}
            {% else %}
              false
            {% endif %}
          {% else %}
            false
          {% endif %}
      - condition: template
        value_template: "{{ control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      # Return to previous mode
      - variables:
          return_to_mode: "{{ states(helper_mode_before_override) if helper_mode_before_override and states(helper_mode_before_override) in ['Auto', 'Smart'] else 'Auto' }}"

      # v3.11.17 FIX: Update helper_change timestamp BEFORE switching modes
      # This prevents false manual override detection if automation turns off AC after mode switch
      - condition: template
        value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
      - service: input_datetime.set_datetime
        target:
          entity_id: "{{ helper_change }}"
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

      - service: input_select.select_option
        target:
          entity_id: "{{ control_mode_helper }}"
        data:
          option: "{{ return_to_mode }}"
        continue_on_error: true

      # Turn off visual indicator
      - if:
          - condition: template
            value_template: "{{ helper_override_flag not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ helper_override_flag }}"
            continue_on_error: true

      # v3.11.0 FIX: Sync expected values with actual AC state to prevent re-detection
      # When timeout expires, accept the current AC settings as the new baseline
      - if:
          - condition: template
            value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ state_attr(climate_list[0], 'temperature') | float(22) }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: "{{ states(climate_list[0]) }}"
            continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] and climate_list | length > 0 }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_fan }}"
            data:
              value: "{{ state_attr(climate_list[0], 'fan_mode') | default('unknown') }}"
            continue_on_error: true

      # Debug log
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                ‚úÖ {{ room_name | upper }} OVERRIDE AUTO-CLEARED
                ‚Ä¢ Reason: Timeout expired ({{ override_timeout }}h)
                ‚Ä¢ Returning to: {{ return_to_mode }} mode
                ‚Ä¢ Automation resuming
              level: warning

  # Update temperature stability tracking - record when temp became stable
  - condition: template
    value_template: "{{ helper_temp_stable_since not in [none, '', 'unavailable', 'unknown'] and helper_temp_history not in [none, '', 'unavailable', 'unknown'] }}"
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {% set temp_diff = (current_temp - previous_temp) | abs %}
              {% set was_stable = states(helper_temp_stable_since) not in ['unknown', 'unavailable', '', None] %}
              {{ temp_diff <= stability_tolerance and not was_stable }}
        sequence:
          # Temperature just became stable - record the time
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_temp_stable_since }}"
            data:
              datetime: "{{ now() }}"
      
      - conditions:
          - condition: template
            value_template: >
              {% set temp_diff = (current_temp - previous_temp) | abs %}
              {{ temp_diff > stability_tolerance }}
        sequence:
          # Temperature is no longer stable - set to current time
          # This resets the stability timer without causing calculation issues
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_temp_stable_since }}"
            data:
              datetime: "{{ now() }}"
  
  # Exit immediately if windows are open (unless disabled)
  - condition: template
    value_template: "{{ not window_open or not enable_window_detection }}"
  
  - variables:
      # Enhanced predictive de-escalation with smooth transitions
      deescalation_level: >
        {% if not dynamic_enabled %}
          0
        {% else %}
          {% set approaching_threshold = deescalation_threshold %}  {# Distance to start de-escalating #}
          {% set close_threshold = approaching_threshold / 2 %}    {# Very close to target #}
          {% set rate_threshold = 0.3 %}  {# ¬∞C/min change rate for predictions #}
          
          {# Level 0: No de-escalation #}
          {% if distance_from_target > approaching_threshold %}
            0  {# Still far from target #}
          {% elif calculated_trend == 'stable' or calculated_trend == '' %}
            0  {# No clear trend to predict #}
          
          {# Level 3: MAXIMUM de-escalation - Switch to eco/maintenance mode #}
          {% elif distance_from_target <= close_threshold and current_effectiveness >= 90 %}
            3  {# Very close and working exceptionally well - switch to maintenance #}
          {% elif distance_from_target <= 0.3 %}
            3  {# Extremely close to target - final approach mode #}
          {% elif last_mode == 'cooling' and calculated_trend == 'falling' and (current_temp - cooling_target_temp) <= 1.0 %}
            3  {# Cooling and approaching target closely #}
          {% elif last_mode == 'heating' and calculated_trend == 'rising' and (heating_target_temp - current_temp) <= 1.0 %}
            3  {# Heating and approaching target closely #}
          
          {# Level 2: HIGH de-escalation - Reduce to medium power #}
          {% elif distance_from_target <= 0.8 and current_effectiveness >= 80 %}
            2  {# Very close and highly effective - reduce power but not to minimum #}
          {% elif distance_from_target <= approaching_threshold and current_effectiveness >= 60 %}
            2  {# Approaching and working reasonably well #}
          {% elif distance_from_target <= 1.5 and calculated_trend != 'stable' %}
            2  {# Getting close with clear progress #}
          {% elif temp_change_rate | abs >= rate_threshold and distance_from_target <= 2.0 %}
            2  {# Fast progress toward target - predict overshoot #}
          
          {# Level 1: LOW de-escalation - Minor power reduction #}
          {% elif distance_from_target <= approaching_threshold and current_effectiveness >= 40 %}
            1  {# Approaching with moderate effectiveness #}
          {% elif distance_from_target <= 2.5 and time_in_current_mode >= 10 %}
            1  {# Moderate distance after sufficient time #}
          
          {% else %}
            0  {# Continue current power level #}
          {% endif %}
        {% endif %}
      
      should_deescalate: >
        {{ deescalation_level > 0 }}

  
  # Debug: Log dynamic escalation timing configuration
  - if:
      - condition: template
        value_template: "{{ debug_enabled and dynamic_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [5/18] üîç {{ room_name | upper }} DYNAMIC ESCALATION TIMING DEBUG

            üìä User Configuration:
                ‚Ä¢ Effectiveness Check Interval: {{ effectiveness_check_mins }} minutes
                ‚Ä¢ Runtime: {{ time_in_current_mode | round(1) }} min ({{ (time_in_current_mode - effectiveness_check_mins) | round(1) }} min {{ 'over' if time_in_current_mode >= effectiveness_check_mins else 'under' }} threshold)

            ‚è∞ Escalation Time Thresholds:
                ‚Ä¢ Level 2 (1.5¬∞C distance): {{ effectiveness_check_mins }}min ‚Üí {{ 'READY' if time_in_current_mode >= effectiveness_check_mins else 'WAITING' }}
                ‚Ä¢ Level 1 (1.0¬∞C distance): {{ effectiveness_check_mins + 2 }}min ‚Üí {{ 'READY' if time_in_current_mode >= (effectiveness_check_mins + 2) else 'WAITING' }}
                ‚Ä¢ Level 1 (‚â§60% effectiveness): {{ effectiveness_check_mins + 5 }}min ‚Üí {{ 'READY' if time_in_current_mode >= (effectiveness_check_mins + 5) else 'WAITING' }}

            üìà Current Status:
                ‚Ä¢ Distance from target: {{ distance_from_target | round(1) }}¬∞C
                ‚Ä¢ Current effectiveness: {{ current_effectiveness }}%
                ‚Ä¢ Escalation level: {{ final_escalation_level }}/4
                ‚Ä¢ Should escalate: {{ should_escalate }}
          level: debug

  # Debug: Log presence validation details
  - if:
      - condition: template
        value_template: "{{ debug_enabled and room_sensors | length > 0 }}"
    then:
      - service: system_log.write
        data:
          message: >
            [6/18] üîç {{ room_name | upper }} PRESENCE VALIDATION DEBUG
            
            üìä Sensor Analysis:
            {% set validation_mode = presence_validation | default('any') | lower %}
            {% set sensors_triggered = namespace(count=0, list=[]) %}
            {% set ble_detected = namespace(value=false, sensors=[]) %}
            {% set motion_detected = namespace(value=false, sensors=[]) %}
            {% set other_detected = namespace(value=false, sensors=[]) %}
            
            {% for sensor in room_sensors %}
              {% set sensor_state = states(sensor) | lower %}
              {% set is_triggered = false %}
              
              {% if sensor.startswith('sensor.') and room_ble_name %}
                {% set detected_room = '' %}
                {% if sensor_state == room_ble_name | lower %}
                  {% set ble_detected.value = true %}
                  {% set ble_detected.sensors = ble_detected.sensors + [sensor] %}
                  {% set is_triggered = true %}
                  {% set detected_room = room_ble_name %}
                {% elif adjacent_room_list | length > 0 %}
                  {% for adjacent_room in adjacent_room_list %}
                    {% if sensor_state == adjacent_room | lower %}
                      {% set ble_detected.value = true %}
                      {% set ble_detected.sensors = ble_detected.sensors + [sensor] %}
                      {% set is_triggered = true %}
                      {% set detected_room = adjacent_room ~ ' (adjacent)' %}
                    {% endif %}
                  {% endfor %}
                {% endif %}
                ‚Ä¢ BLE: {{ sensor }} = "{{ sensor_state }}" ({{ 'TRIGGERED - ' ~ detected_room if is_triggered else 'not detected' }})
              {% elif sensor.startswith('binary_sensor.') %}
                {% if is_state(sensor, 'on') or is_state(sensor, 'detected') or is_state(sensor, 'occupied') %}
                  {% set motion_detected.value = true %}
                  {% set motion_detected.sensors = motion_detected.sensors + [sensor] %}
                  {% set is_triggered = true %}
                {% endif %}
                ‚Ä¢ Motion: {{ sensor }} = {{ states(sensor) }} ({{ 'TRIGGERED' if is_triggered else 'clear' }})
              {% else %}
                {% if is_state(sensor, 'on') or sensor_state in ['home', 'present', 'detected', 'occupied'] %}
                  {% set other_detected.value = true %}
                  {% set other_detected.sensors = other_detected.sensors + [sensor] %}
                  {% set is_triggered = true %}
                {% endif %}
                ‚Ä¢ Other: {{ sensor }} = {{ states(sensor) }} ({{ 'TRIGGERED' if is_triggered else 'inactive' }})
              {% endif %}
              
              {% if is_triggered %}
                {% set sensors_triggered.count = sensors_triggered.count + 1 %}
                {% set sensors_triggered.list = sensors_triggered.list + [sensor] %}
              {% endif %}
            {% endfor %}
            
            üéØ Validation Summary:
                ‚Ä¢ Mode: {{ validation_mode | upper }}
                ‚Ä¢ Total Sensors: {{ room_sensors | length }}
                ‚Ä¢ Triggered: {{ sensors_triggered.count }} ({{ sensors_triggered.list | join(', ') if sensors_triggered.list else 'none' }})
            
            üìä Detection Results:
                ‚Ä¢ BLE Detected: {{ ble_detected.value }} ({{ ble_detected.sensors | join(', ') if ble_detected.sensors else 'none' }})
                ‚Ä¢ Motion Detected: {{ motion_detected.value }} ({{ motion_detected.sensors | join(', ') if motion_detected.sensors else 'none' }})
                ‚Ä¢ Other Detected: {{ other_detected.value }} ({{ other_detected.sensors | join(', ') if other_detected.sensors else 'none' }})

            ‚úÖ Room Presence Result: {{ room_presence_detected }}
          level: warning

  # Debug: Log current conditions
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [7/18] üìä {{ room_name | upper }} CLIMATE CONTROL STATUS
            
            üå°Ô∏è Current Conditions:
                ‚Ä¢ Temperature: {{ current_temp }}¬∞C {% if calculated_trend == 'rising' %}‚ÜóÔ∏è Rising{% elif calculated_trend == 'falling' %}‚ÜòÔ∏è Falling{% else %}‚û°Ô∏è Stable{% endif %}
                ‚Ä¢ People: {% if room_presence_detected %}Room occupied{% elif anyone_home %}Home (elsewhere){% elif approaching_home %}Approaching{% else %}Away{% endif %}
                ‚Ä¢ Room Presence: {{ 'DETECTED' if room_presence_detected else 'Empty' }} (Mode: {{ presence_validation | default('any') | upper }})
                ‚Ä¢ Current Mode: {% if should_activate and (last_mode == 'cooling' or last_mode == 'heating') %}{{ last_mode|title }}{% if dynamic_enabled and final_escalation_level > 0 %} - ESCALATING L{{ final_escalation_level }} üîº{% elif dynamic_enabled and deescalation_level > 0 %} - DE-ESCALATING L{{ deescalation_level }} üîΩ{% elif dynamic_enabled and current_effectiveness >= 80 %} - EFFECTIVE ({{ current_effectiveness }}%) ‚öñÔ∏è{% endif %} (running {{ time_in_current_mode | round(0) }} min){% elif actual_ac_state == 'off' %}OFF ‚ö´{% elif current_temp >= comfort_min_temp and current_temp <= comfort_max_temp %}IDLE - COMFORT ZONE{% if dynamic_enabled and deescalation_level > 0 %} (DE-ESCALATED L{{ deescalation_level }}) üîΩ{% endif %} ‚úÖ{% elif should_activate %}MONITORING - CONDITIONS NOT MET ‚è∏Ô∏è{% else %}STANDBY - LAST: {{ last_mode|title }} ({{ time_in_current_mode | round(0) }} min ago){% endif %}
                ‚Ä¢ Fan Speed: {{ state_attr(climate_list[0], 'fan_mode') | default('Unknown') | title }}
                ‚Ä¢ Swing: {{ state_attr(climate_list[0], 'swing_mode') | default('Unknown') | title }}
                ‚Ä¢ Control Mode: {{ control_mode }} (from: {{ control_mode_helper if control_mode_helper else 'NO HELPER' }})
            
            üéØ System Status:
                {% if temp_stability_enabled and temp_stability_detected and last_mode not in ['stability_off', 'stability_eco', 'stability_fan_only'] %}‚Ä¢ Temperature stable for {{ temp_stability_time | round(0) }} min - ready for auto-off{% elif temp_stability_enabled and (last_mode == 'cooling' or last_mode == 'heating') %}‚Ä¢ Continue mode active - pursuing {{ target_temp }}¬∞C target ({{ (current_temp - target_temp) | round(1) }}¬∞C to go){% elif last_mode in ['stability_off', 'stability_eco', 'stability_fan_only'] %}‚Ä¢ AC in stability mode ({{ last_mode }}){% elif current_temp < comfort_min_temp %}‚Ä¢ Too cold - needs heating{% elif current_temp > comfort_max_temp %}‚Ä¢ Too hot - needs cooling{% else %}‚Ä¢ Perfect temperature{% endif %}
            
            üìã Technical Details:
                ‚Ä¢ Comfort Zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C
            {% if temp_stability_enabled %}    ‚Ä¢ Stability: {{ 'ACTIVE - ' + last_mode | upper if last_mode in ['stability_off', 'stability_eco', 'stability_fan_only'] else 'DETECTED' if temp_stability_detected else 'Continue mode - pursuing target' if last_mode == 'cooling' or last_mode == 'heating' else 'Monitoring - Outside comfort zone' if current_temp < comfort_min_temp or current_temp > comfort_max_temp else 'Monitoring' }} (¬±{{ stability_tolerance }}¬∞C for {{ stability_duration }}min, target ¬±0.5¬∞C){% endif %}
                ‚Ä¢ Trend: {{ temp_change_rate }}¬∞C/min, Distance: {{ distance_from_target | round(1) }}¬∞C, Effectiveness: {{ current_effectiveness }}%
            {% if dynamic_enabled %}    ‚Ä¢ Dynamic: Escalation Level {{ final_escalation_level }}/4, De-escalation Level {{ deescalation_level }}/3 (Check Interval: {{ effectiveness_check_mins }}min)
                ‚Ä¢ Stall Check: distance={{ distance_from_target | round(1) }}‚â§0.8? time={{ time_in_current_mode | round(1) }}‚â•15min? trend={{ calculated_trend }} rate={{ temp_change_rate | round(2) }}¬∞C/min{% endif %}
          level: warning
  
  # Update effectiveness score helper
  - if:
      - condition: template
        value_template: "{{ dynamic_enabled and helper_effectiveness not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - service: input_number.set_value
        target:
          entity_id: "{{ helper_effectiveness }}"
        data:
          value: "{{ current_effectiveness }}"

  - if:
      - condition: template
        value_template: "{{ dynamic_enabled and helper_trend not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - service: input_text.set_value
        target:
          entity_id: "{{ helper_trend }}"
        data:
          value: "{{ calculated_trend }}"

  # Debug: Log the actual last_mode value to see what's happening
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [8/18] üîç {{ room_name | upper }} CORE VARIABLES & STATE

            üìä Core Variables:
                ‚Ä¢ last_mode (internal): "{{ last_mode }}"
                ‚Ä¢ actual_ac_state: "{{ actual_ac_state }}"
                ‚Ä¢ should_activate: {{ should_activate }}
                ‚Ä¢ current_temp: {{ current_temp }}¬∞C
                ‚Ä¢ comfort_max_temp: {{ comfort_max_temp }}¬∞C
                ‚Ä¢ comfort_min_temp: {{ comfort_min_temp }}¬∞C
          level: warning

  - if:
      - condition: template
        value_template: "{{ debug_enabled and dynamic_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [9/18] üîç {{ room_name | upper }} ESCALATION DEBUG

            üìä Escalation Conditions:
                ‚Ä¢ distance_from_target: {{ distance_from_target | round(1) }}¬∞C
                ‚Ä¢ time_in_current_mode: {{ time_in_current_mode | round(1) }}min
                ‚Ä¢ current_effectiveness: {{ current_effectiveness }}%
                ‚Ä¢ calculated_trend: {{ calculated_trend }}
                ‚Ä¢ temp_change_rate: {{ temp_change_rate | round(3) }}¬∞C/min

            üéØ Near-Target Stall Detection (Level 1):
                ‚Ä¢ Distance ‚â§ {{ temp_tolerance }}¬∞C: {{ distance_from_target <= temp_tolerance }}
                ‚Ä¢ Time ‚â• 15min: {{ time_in_current_mode >= 15 }}
                ‚Ä¢ Stable/slow: {{ calculated_trend == 'stable' or temp_change_rate | abs < 0.1 }}
                ‚Ä¢ SHOULD TRIGGER: {{ distance_from_target <= temp_tolerance and time_in_current_mode >= 15 and (calculated_trend == 'stable' or temp_change_rate | abs < 0.1) }}

            ‚è±Ô∏è Time-Based Stall Detection (Level 3):
                ‚Ä¢ Time ‚â• {{ stall_time_threshold }}min: {{ time_in_current_mode >= stall_time_threshold }}
                ‚Ä¢ Progress rate < {{ min_progress_rate }}¬∞C/min: {{ temp_change_rate | abs < min_progress_rate }} (current: {{ temp_change_rate | abs | round(3) }}¬∞C/min)
                ‚Ä¢ Distance > {{ (temp_tolerance / 2) | round(1) }}¬∞C: {{ distance_from_target > (temp_tolerance / 2) }}
                ‚Ä¢ SHOULD TRIGGER: {{ time_in_current_mode >= stall_time_threshold and temp_change_rate | abs < min_progress_rate and distance_from_target > (temp_tolerance / 2) }}

            üö® Extended Stall Detection (Level 4 Emergency):
                ‚Ä¢ Extended threshold: {{ (stall_time_threshold * extended_stall_multiplier) | round(0) }}min ({{ stall_time_threshold }}min √ó {{ extended_stall_multiplier }})
                ‚Ä¢ Time in mode: {{ time_in_current_mode | round(1) }}min
                ‚Ä¢ Time ‚â• threshold: {{ time_in_current_mode >= (stall_time_threshold * extended_stall_multiplier) }}
                ‚Ä¢ Progress rate < {{ min_progress_rate }}¬∞C/min: {{ temp_change_rate | abs < min_progress_rate }} (current: {{ temp_change_rate | abs | round(3) }}¬∞C/min)
                ‚Ä¢ Distance > 1.5¬∞C: {{ distance_from_target > 1.5 }} (current: {{ distance_from_target | round(1) }}¬∞C)
                ‚Ä¢ SHOULD TRIGGER EMERGENCY: {{ time_in_current_mode >= (stall_time_threshold * extended_stall_multiplier) and temp_change_rate | abs < min_progress_rate and distance_from_target > 1.5 }}

            ‚ö° Result: Base Escalation Level = {{ escalation_level }}
          level: warning

  - if:
      - condition: template
        value_template: "{{ debug_enabled and dynamic_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [10/18] üîΩ {{ room_name | upper }} DE-ESCALATION DEBUG

            üìä De-escalation Conditions:
                ‚Ä¢ distance_from_target: {{ distance_from_target | round(1) }}¬∞C
                ‚Ä¢ deescalation_threshold: {{ deescalation_threshold }}¬∞C (start reducing power within this distance)
                ‚Ä¢ close_threshold: {{ deescalation_threshold / 2 }}¬∞C (very close to target)
                ‚Ä¢ current_effectiveness: {{ current_effectiveness }}%
                ‚Ä¢ calculated_trend: {{ calculated_trend }}
                ‚Ä¢ temp_change_rate: {{ temp_change_rate | round(3) }}¬∞C/min
                ‚Ä¢ time_in_current_mode: {{ time_in_current_mode | round(1) }}min

            üéØ De-escalation Level Analysis:
                {% if not dynamic_enabled %}
                ‚Ä¢ Dynamic Escalation DISABLED - no de-escalation
                {% elif distance_from_target > deescalation_threshold %}
                ‚Ä¢ Level 0: Too far from target ({{ distance_from_target | round(1) }}¬∞C > {{ deescalation_threshold }}¬∞C)
                ‚Ä¢ NO de-escalation - maintain current power
                {% elif calculated_trend == 'stable' or calculated_trend == '' %}
                ‚Ä¢ Level 0: No clear temperature trend detected
                ‚Ä¢ Cannot predict if we'll overshoot - maintain current power
                {% elif distance_from_target <= (deescalation_threshold / 2) and current_effectiveness >= 90 %}
                ‚Ä¢ Level 3: MAXIMUM de-escalation
                ‚Ä¢ Very close ({{ distance_from_target | round(1) }}¬∞C) AND highly effective ({{ current_effectiveness }}%)
                ‚Ä¢ Action: Switch to maintenance/eco mode to prevent overshoot
                {% elif distance_from_target <= 0.3 %}
                ‚Ä¢ Level 3: MAXIMUM de-escalation
                ‚Ä¢ Extremely close to target ({{ distance_from_target | round(1) }}¬∞C ‚â§ 0.3¬∞C)
                ‚Ä¢ Action: Final approach - minimal power
                {% elif distance_from_target <= 0.8 and current_effectiveness >= 80 %}
                ‚Ä¢ Level 2: HIGH de-escalation
                ‚Ä¢ Close to target ({{ distance_from_target | round(1) }}¬∞C ‚â§ 0.8¬∞C) with good effectiveness ({{ current_effectiveness }}%)
                ‚Ä¢ Action: Reduce to medium power
                {% elif distance_from_target <= 1.5 and calculated_trend != 'stable' %}
                ‚Ä¢ Level 2: HIGH de-escalation
                ‚Ä¢ Getting close ({{ distance_from_target | round(1) }}¬∞C ‚â§ 1.5¬∞C) with clear progress
                ‚Ä¢ Action: Preventive reduction to avoid overshoot
                {% elif distance_from_target <= deescalation_threshold and current_effectiveness >= 40 %}
                ‚Ä¢ Level 1: LOW de-escalation
                ‚Ä¢ Approaching target ({{ distance_from_target | round(1) }}¬∞C ‚â§ {{ deescalation_threshold }}¬∞C)
                ‚Ä¢ Action: Minor power reduction
                {% else %}
                ‚Ä¢ Level 0: Continue current power level
                ‚Ä¢ Not yet close enough or effectiveness too low
                {% endif %}

            ‚ö° Result: De-escalation Level = {{ deescalation_level }}

            üéØ {{ room_name | upper }} Specific Settings:
                ‚Ä¢ Your de-escalation threshold: {{ deescalation_threshold }}¬∞C (0.8¬∞C = very aggressive)
                ‚Ä¢ Current distance: {{ distance_from_target | round(1) }}¬∞C
                ‚Ä¢ Will de-escalate when: {{ distance_from_target | round(1) }}¬∞C ‚â§ {{ deescalation_threshold }}¬∞C
                {% if distance_from_target > deescalation_threshold %}
                ‚Ä¢ ‚ö†Ô∏è Still {{ (distance_from_target - deescalation_threshold) | round(1) }}¬∞C away from de-escalation range
                {% else %}
                ‚Ä¢ ‚úÖ In de-escalation range - reducing power!
                {% endif %}
          level: warning

  - if:
      - condition: template
        value_template: "{{ debug_enabled and dynamic_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [11/18] üîç {{ room_name | upper }} STALL & WRONG-DIRECTION ESCALATION DEBUG

            üìä Feature Status:
                ‚Ä¢ Stall & Wrong-Direction Escalation Enabled: {{ wrong_direction_enabled }}
                ‚Ä¢ Escalation Per Check: +{{ wrong_direction_per_check }} levels

            üå°Ô∏è Temperature Trend Analysis:
                ‚Ä¢ Current Mode: {{ last_mode }}
                ‚Ä¢ Temperature Trend: {{ calculated_trend }}
                ‚Ä¢ Time in Current Mode: {{ time_in_current_mode | round(1) }} min
                ‚Ä¢ Effectiveness Check Interval: {{ effectiveness_check_mins }} min

            üö® Stall & Wrong Direction Detection:
                {% if last_mode == 'cooling' %}
                ‚Ä¢ Mode: Cooling
                ‚Ä¢ Expected: Temperature FALLING at rate > {{ min_progress_rate }}¬∞C/min
                ‚Ä¢ Actual Rate: {{ temp_change_rate | round(3) }}¬∞C/min
                ‚Ä¢ Wrong Direction (rising): {{ temp_change_rate > wrong_direction_min_rate }} (rate > +{{ wrong_direction_min_rate }}¬∞C/min)
                ‚Ä¢ Stalling (cooling too slowly): {{ temp_change_rate >= -min_progress_rate and temp_change_rate <= 0 }} (rate between -{{ min_progress_rate }} and 0¬∞C/min, inclusive)
                {% elif last_mode == 'heating' %}
                ‚Ä¢ Mode: Heating
                ‚Ä¢ Expected: Temperature RISING at rate > {{ min_progress_rate }}¬∞C/min
                ‚Ä¢ Actual Rate: {{ temp_change_rate | round(3) }}¬∞C/min
                ‚Ä¢ Wrong Direction (falling): {{ temp_change_rate < -wrong_direction_min_rate }} (rate < -{{ wrong_direction_min_rate }}¬∞C/min)
                ‚Ä¢ Stalling (heating too slowly): {{ temp_change_rate <= min_progress_rate and temp_change_rate >= 0 }} (rate between 0 and +{{ min_progress_rate }}¬∞C/min, inclusive)
                {% else %}
                ‚Ä¢ Mode: {{ last_mode }} (not cooling/heating)
                ‚Ä¢ Stall/Wrong Direction: Not Applicable
                {% endif %}

            ‚ö° Incremental Escalation Calculation:
                ‚Ä¢ Stall or Wrong Direction Detected: {{ wrong_direction_detected }}
                ‚Ä¢ Wrong Direction Threshold: {{ wrong_direction_min_rate }}¬∞C/min
                ‚Ä¢ Minimum Progress Rate: {{ min_progress_rate }}¬∞C/min
                ‚Ä¢ Current Rate: {{ temp_change_rate | round(3) }}¬∞C/min
                ‚Ä¢ Escalation Add (This Check): +{{ wrong_direction_escalation_add }} levels
                ‚Ä¢ Base Escalation: Level {{ escalation_level }}
                ‚Ä¢ Final Escalation: Level {{ final_escalation_level }} (base + stall_add, capped at 4)

            üí° How Incremental Escalation Works:
                {% if not wrong_direction_enabled %}
                ‚Ä¢ Feature DISABLED - using base escalation only
                {% elif wrong_direction_per_check == 0 %}
                ‚Ä¢ Feature enabled but set to +0 - no escalation added
                {% elif not wrong_direction_detected %}
                ‚Ä¢ Temperature progressing well - no additional escalation needed
                {% else %}
                ‚Ä¢ Stall or wrong direction detected! Adding +{{ wrong_direction_per_check }} level(s) this check
                ‚Ä¢ At next effectiveness check (in ~{{ effectiveness_check_mins }} min), if still stalling/wrong: +{{ wrong_direction_per_check }} more
                ‚Ä¢ Escalation builds up: Check 1: +{{ wrong_direction_per_check }}, Check 2: +{{ wrong_direction_per_check * 2 }}, Check 3: +{{ wrong_direction_per_check * 3 }}, etc.
                ‚Ä¢ Stops escalating when temp progresses faster or reaches Level 4 (Fan 5 maximum)
                {% endif %}
          level: warning

  # DEBUG: Dynamic target adjustment
  - if:
      - condition: template
        value_template: "{{ debug_enabled and enable_dynamic_target and final_escalation_level > 0 }}"
    then:
      - service: system_log.write
        data:
          message: >
            [12/18] üéØ {{ room_name | upper }} DYNAMIC TARGET ADJUSTMENT

            üîß Smart Escalation Boost Active:
                ‚Ä¢ Feature Enabled: {{ enable_dynamic_target }}
                ‚Ä¢ User Desired Temperature: {{ target_temp }}¬∞C
                ‚Ä¢ Final Escalation Level: {{ final_escalation_level }}
                ‚Ä¢ Offset Per Level: {{ escalation_offset }}¬∞C
                ‚Ä¢ Total Adjustment: {{ (final_escalation_level * escalation_offset) | round(1) }}¬∞C

            üå°Ô∏è Target Calculation:
                ‚Ä¢ Current Mode: {{ last_mode }}
                {% if last_mode == 'cooling' %}
                ‚Ä¢ Cooling Mode: LOWERING target to make AC work harder
                ‚Ä¢ Formula: {{ target_temp }}¬∞C - ({{ final_escalation_level }} √ó {{ escalation_offset }}¬∞C) = {{ adjusted_target }}¬∞C
                ‚Ä¢ AC will cool to {{ adjusted_target }}¬∞C instead of {{ target_temp }}¬∞C
                ‚Ä¢ Creates {{ (target_temp - adjusted_target) | round(1) }}¬∞C buffer zone below user target
                {% elif last_mode == 'heating' %}
                ‚Ä¢ Heating Mode: RAISING target to make AC work harder
                ‚Ä¢ Formula: {{ target_temp }}¬∞C + ({{ final_escalation_level }} √ó {{ escalation_offset }}¬∞C) = {{ adjusted_target }}¬∞C
                ‚Ä¢ AC will heat to {{ adjusted_target }}¬∞C instead of {{ target_temp }}¬∞C
                ‚Ä¢ Creates {{ (adjusted_target - target_temp) | round(1) }}¬∞C buffer zone above user target
                {% endif %}

            üí° Why This Helps:
                ‚Ä¢ AC compressor works harder with more aggressive target
                ‚Ä¢ Combined with Fan Level {{ final_escalation_level }} = maximum effectiveness
                ‚Ä¢ Buffer zone prevents immediate drift back when escalation reduces
                ‚Ä¢ Auto-reverts to {{ target_temp }}¬∞C once temperature stable

            ‚öôÔ∏è Behavior:
                ‚Ä¢ Target sent to AC: {{ adjusted_target }}¬∞C ({{ "%.1f" | format(adjusted_target - target_temp) }}¬∞C {% if adjusted_target > target_temp %}above{% else %}below{% endif %} user target)
                ‚Ä¢ Once stable and escalation drops to 0: Returns to {{ target_temp }}¬∞C
          level: warning

  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [13/18] üîç {{ room_name | upper }} TEMPERATURE & TIMING LOGIC

            üå°Ô∏è Temperature Logic:
                ‚Ä¢ last_transition: "{{ last_transition }}"
                ‚Ä¢ hysteresis: {{ hysteresis_tolerance }}¬∞C
                ‚Ä¢ current_temp: {{ current_temp }}¬∞C
                ‚Ä¢ comfort_max_temp: {{ comfort_max_temp }}¬∞C
                ‚Ä¢ comfort_min_temp: {{ comfort_min_temp }}¬∞C
                ‚Ä¢ time_since_change: {{ time_since_change | round(1) }}min
                ‚Ä¢ runtime_min: {{ runtime_min }}min
                ‚Ä¢ time_check: {{ time_since_change > runtime_min }}
                ‚Ä¢ mode_check: {{ last_mode != 'cooling' and last_mode != 'heating' }}
                ‚Ä¢ actual_ac_off: {{ actual_ac_state == 'off' }}
          level: warning

  # Manual Override Debug Logging - v3.3.0 Enhanced Detection

  # Presence Confirmation Delay Debug Logging (Smart Mode)
  - if:
      - condition: template
        value_template: "{{ debug_enabled and control_mode == 'Smart' }}"
    then:
      - service: system_log.write
        data:
          message: >
            [15/18] üë§ {{ room_name | upper }} PRESENCE CONFIRMATION DEBUG

            ‚è±Ô∏è Delay Configuration:
                ‚Ä¢ presence_confirmation_delay: {{ presence_confirmation_delay }} minutes
                ‚Ä¢ presence_timeout (grace period): {{ presence_timeout }} minutes

            üîç Current Status:
                ‚Ä¢ room_presence_detected: {{ room_presence_detected }}
                ‚Ä¢ minutes_with_presence: {{ minutes_with_presence | round(1) }} min
                ‚Ä¢ minutes_since_presence: {{ minutes_since_presence | round(0) }} min
                ‚Ä¢ smart_presence_active: {{ smart_presence_active }}

            {% if presence_confirmation_delay > 0 %}
            üìã Confirmation Delay Logic:
                {% if room_presence_detected %}
                ‚úÖ Presence detected NOW:
                    ‚Ä¢ Time with presence: {{ minutes_with_presence | round(1) }} minutes
                    ‚Ä¢ Required delay: {{ presence_confirmation_delay }} minutes
                    ‚Ä¢ Status: {% if minutes_with_presence >= presence_confirmation_delay %}‚úÖ CONFIRMED - Can activate AC{% else %}‚è≥ WAITING - {{ (presence_confirmation_delay - minutes_with_presence) | round(1) }} min until activation{% endif %}
                {% else %}
                ‚ùå No presence detected:
                    ‚Ä¢ Last seen: {{ minutes_since_presence | round(0) }} minutes ago
                    ‚Ä¢ Grace period: {{ presence_timeout }} minutes
                    ‚Ä¢ Status: {% if minutes_since_presence < presence_timeout %}‚è≥ GRACE PERIOD ACTIVE - AC will stay on{% else %}‚ùå GRACE PERIOD EXPIRED - AC will turn off{% endif %}
                {% endif %}
            {% else %}
            ‚ÑπÔ∏è Instant activation enabled (no confirmation delay)
            {% endif %}

            üéØ Final Decision:
                ‚Ä¢ smart_presence_active: {{ smart_presence_active }}
                ‚Ä¢ actual_ac_state: {{ actual_ac_state }}
                ‚Ä¢ time_in_current_mode: {{ time_in_current_mode | round(1) }}min
                ‚Ä¢ runtime_min: {{ runtime_min }}min
                ‚Ä¢ Runtime check: {{ time_in_current_mode < runtime_min }}
                {% set presence_active = smart_presence_active | string | lower == 'true' %}
                {% if not presence_active and actual_ac_state != 'off' and time_in_current_mode < runtime_min %}
                ‚Ä¢ ‚è±Ô∏è RUNTIME PROTECTION: AC will continue for {{ (runtime_min - time_in_current_mode) | round(1) }} more minutes
                ‚Ä¢ AC will: ‚è≥ STAY ON (compressor protection) then ‚ùå TURN OFF when runtime met
                {% elif presence_active %}
                ‚Ä¢ AC will: ‚úÖ STAY ON / ACTIVATE (presence confirmed)
                {% else %}
                ‚Ä¢ AC will: ‚ùå TURN OFF / STAY OFF (no presence)
                {% endif %}
          level: warning

  # GLOBAL MANUAL OVERRIDE CHECK - Exit before choose blocks if override is active
  # This prevents automation from turning AC back on when user manually turned it off

  # DEBUG: Log all values IMMEDIATELY before condition evaluation
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [16/18] üîç {{ room_name | upper }} PRE-CONDITION EVALUATION DEBUG

            üìä Variable States (at condition check time):
                ‚Ä¢ control_mode: {{ control_mode }}
                ‚Ä¢ is_override_mode: {{ control_mode == 'Override' }}
                ‚Ä¢ RESULT: {{ 'TRUE - WILL BLOCK' if control_mode == 'Override' else 'FALSE - WILL NOT BLOCK' }}

            üîê Override Helper States:
                ‚Ä¢ helper_override_timestamp: {{ helper_override_timestamp if helper_override_timestamp else 'NOT CONFIGURED' }}
                ‚Ä¢ Timestamp state: {{ states(helper_override_timestamp) if helper_override_timestamp else 'N/A' }}

            ‚è±Ô∏è Time Calculations:
                {% if control_mode == 'Override' and helper_override_timestamp and states(helper_override_timestamp) not in ['unknown', 'unavailable', ''] %}
                {% set override_time = as_timestamp(states(helper_override_timestamp)) %}
                {% if override_time %}
                {% set time_since_override = (as_timestamp(now()) - override_time) / 3600 %}
                ‚Ä¢ Time since override: {{ time_since_override | round(2) }} hours
                ‚Ä¢ Timeout threshold: {{ override_timeout }} hours
                ‚Ä¢ Will auto-clear in: {{ (override_timeout - time_since_override) | round(2) }} hours
                {% else %}
                ‚Ä¢ override_time calculation: FAILED (timestamp conversion)
                {% endif %}
                {% else %}
                ‚Ä¢ override_time calculation: Not in Override mode or helper not available
                {% endif %}
          level: warning

  # v3.11.0: Check if Override mode is active (automation paused)
  - if:
      - condition: template
        value_template: "{{ control_mode == 'Override' }}"
    then:
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üö´ {{ room_name | upper }} OVERRIDE MODE - AUTOMATION PAUSED

                ‚è∏Ô∏è Automation Paused:
                    ‚Ä¢ User manually changed AC settings
                    ‚Ä¢ Override Since: {{ states(helper_override_timestamp) if helper_override_timestamp else 'unknown' }}
                    ‚Ä¢ Timeout: {{ override_timeout }} hour(s)
                    ‚Ä¢ Previous mode: {{ states(helper_mode_before_override) if helper_mode_before_override else 'unknown' }}

                üîí Respecting User Control:
                    ‚Ä¢ Last mode (helper): {{ states(helper_mode) | default('off') }}
                    ‚Ä¢ Actual AC state: {{ actual_ac_state }}
                    ‚Ä¢ All automation actions blocked until override clears

                ‚ÑπÔ∏è Override will clear automatically after {{ override_timeout }} hour(s)
                   or immediately if you change control mode
              level: warning
      # Exit immediately - don't process any choose blocks
      - stop: "Override mode active - respecting user's manual changes"

  # v3.17.1 FIX: Proactive helper_change update to prevent race condition false overrides
  # CRITICAL: Update helper_change timestamp BEFORE any climate commands are sent
  # This prevents subsequent automation runs (triggered by climate state changes) from
  # falsely detecting the automation's own actions as manual intervention.
  #
  # Race condition scenario (FIXED):
  # 1. Run #1: Person trigger ‚Üí Decide to turn on AC ‚Üí Send climate command
  # 2. AC state changes (off ‚Üí heat_cool) within 0.2 seconds
  # 3. Run #2: climate_state_change trigger ‚Üí Calculate manual override detection
  #    - Uses OLD helper_change timestamp (from before Run #1)
  #    - time_since_change > 45 seconds ‚Üí within_hardware_delay = FALSE
  #    - Detects: last_mode="off", actual="on", not within delay
  #    - RESULT: False positive Override mode activation!
  #
  # Solution: Update helper_change NOW if we're going to take action AND starting a new mode
  # This ensures Run #2 will see fresh timestamp and recognize it's within hardware delay
  # v3.18.6 FIX: REMOVED race condition protection block
  # This block was updating helper_change BEFORE the main choose block ran,
  # which was blocking manual override detection when user manually turned AC on.
  #
  # Problem Scenario:
  # 1. User manually turns AC ON via physical remote
  # 2. Automation triggers
  # 3. State sync sees helper_last_mode='off' but actual AC='on'
  # 4. State sync updates helper_last_mode to 'cooling' or 'heating'
  # 5. should_activate becomes TRUE after state sync
  # 6. Race condition protection sees should_activate=TRUE
  # 7. Updates helper_change to NOW()
  # 8. Manual override check runs immediately after
  # 9. within_hardware_delay=TRUE (only 10 seconds since helper_change updated)
  # 10. is_manual_on=FALSE (blocked by within_hardware_delay)
  # 11. Override doesn't activate ‚Üí AC turns back off ‚Üí User frustrated!
  #
  # Solution: Remove this proactive update entirely.
  # The 45-second within_hardware_delay protection is sufficient when helper_change
  # is ONLY updated when automation actually makes a control decision (in choose blocks).
  # State sync is passive housekeeping and should NOT reset the hardware delay window.

  - choose:
      # v3.11.9 FIX: Defensive check - verify Override mode using actual helper state
      # This catches cases where Override was just activated in this same automation run.
      # The control_mode variable may still hold the old value, but the helper entity is already updated.
      - conditions:
          - condition: template
            value_template: >
              {{ control_mode_helper not in [none, '', 'unavailable', 'unknown']
                 and is_state(control_mode_helper, 'Override') }}
        sequence:
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üõ°Ô∏è {{ room_name | upper }} DEFENSIVE CHECK: Override mode detected via helper state
                    ‚Ä¢ control_mode variable: {{ control_mode }}
                    ‚Ä¢ control_mode_helper state: {{ states(control_mode_helper) }}
                    ‚Ä¢ This prevents AC control when Override was just activated
                    ‚Ä¢ Stopping automation to respect user's manual changes
                  level: warning
          - stop: "Override mode active (helper state check) - respecting user's manual changes"

      # Handle Manual mode - True manual control with optional timeout
      - conditions:
          - condition: template
            value_template: "{{ control_mode == 'Manual' }}"
        sequence:
          # Check if Manual mode timeout has been reached
          - if:
              - condition: template
                value_template: "{{ manual_timeout_hours > 0 }}"
              - condition: template
                value_template: >
                  {% if helper_change and states(helper_change) not in ['unknown', 'unavailable', ''] %}
                    {% set change_timestamp = as_timestamp(states(helper_change)) %}
                    {% if change_timestamp %}
                      {% set time_in_manual = (as_timestamp(now()) - change_timestamp) / 3600 %}
                      {{ time_in_manual >= manual_timeout_hours }}
                    {% else %}
                      false
                    {% endif %}
                  {% else %}
                    false
                  {% endif %}
            then:
              - service: system_log.write
                data:
                  message: >
                    {% set change_timestamp = as_timestamp(states(helper_change)) %}
                    ‚è∞ {{ room_name | upper }} MANUAL MODE TIMEOUT: Returning to automation
                    ‚Ä¢ Manual timeout reached: {{ manual_timeout_hours }} hours
                    ‚Ä¢ Time in manual: {{ ((as_timestamp(now()) - change_timestamp) / 3600) | round(1) if change_timestamp else 'N/A' }}h
                    ‚Ä¢ Switching back to Smart mode - automation will resume
                    ‚Ä¢ AC will continue running under normal automation control
                  level: warning

              # Switch back to Smart mode (don't turn off AC)
              - condition: template
                value_template: "{{ control_mode_helper not in [none, '', 'unavailable', 'unknown'] }}"
              - service: input_select.select_option
                target:
                  entity_id: "{{ control_mode_helper }}"
                data:
                  option: "Smart"
                continue_on_error: true

              - service: input_text.set_value
                target:
                  entity_id: !input helper_last_mode
                data:
                  value: "manual_timeout_return_to_smart"
                continue_on_error: true

              - if:
                  - condition: template
                    value_template: "{{ enable_notifications }}"
                then:
                  - service: !input notification_service
                    data:
                      title: "{{ room_name }} Climate Control"
                      message: "Manual timeout ({{ manual_timeout_hours }}h) - switched back to Smart mode"
                    continue_on_error: true
              - stop: "Manual mode timeout - returned to Smart mode"
            else:
              # Manual mode continues - complete user control
              - condition: template
                value_template: "{{ debug_enabled }}"
              - service: system_log.write
                data:
                  message: >
                    {% set change_timestamp = as_timestamp(states(helper_change)) %}
                    üéÆ {{ room_name | upper }} MANUAL MODE: Full user control active
                    ‚Ä¢ Temperature: {{ current_temp }}¬∞C
                    ‚Ä¢ Timeout setting: {{ manual_mode_timeout }} ({{ manual_timeout_hours }}h)
                    {% if manual_timeout_hours > 0 %}
                    ‚Ä¢ Time remaining: {{ (manual_timeout_hours - ((as_timestamp(now()) - change_timestamp) / 3600)) | round(1) if change_timestamp else 'N/A' }}h
                    {% else %}
                    ‚Ä¢ No timeout - manual until you change it
                    {% endif %}
                    ‚Ä¢ FULL CONTROL: Set any temp/fan remotely - NO automation interference
                    ‚Ä¢ Perfect for pre-conditioning rooms before arrival!
                  level: debug
              - stop: "Manual mode active - user has complete control"

      # v4.0.2: Log when AC unavailable (prevents false manual override)
      - conditions:
          - condition: template
            value_template: "{{ any_ac_unavailable and debug_enabled }}"
        sequence:
          - service: system_log.write
            data:
              message: >
                üîå {{ room_name | upper }} AC UNAVAILABLE: Skipping manual override detection
                ‚Ä¢ AC disconnected - this is a known issue
                ‚Ä¢ Manual override detection disabled while unavailable
                ‚Ä¢ Automation will resume when AC reconnects
                ‚Ä¢ AC entity states: {% for entity in climate_list %}{{ entity }}={{ states(entity) }}{% if not loop.last %}, {% endif %}{% endfor %}
              level: warning

      # Skip if manual override is active (user changed AC while in Auto/Smart) - NEVER for mode changes
      - conditions:
          - condition: template
            value_template: "{{ control_mode == 'Override' and manual_override_detection }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    {% set change_timestamp = as_timestamp(states(helper_change)) %}
                    üîí {{ room_name | upper }} MANUAL OVERRIDE: Respecting user changes
                    ‚Ä¢ Manual override detected: {{ manual_override_detection }}
                    ‚Ä¢ Last mode state: "{{ states(helper_mode) | default('off') }}"
                    ‚Ä¢ Actual AC state: "{{ actual_ac_state }}"
                    ‚Ä¢ Override timeout: {{ override_timeout }} hours
                    ‚Ä¢ Time remaining: {{ (override_timeout - ((as_timestamp(now()) - change_timestamp) / 3600)) | round(1) if change_timestamp else 'N/A' }} hours
                    ‚Ä¢ AC will maintain user settings until timeout expires
                  level: warning

          # STOP HERE - Respect user's manual changes
          - stop: "Manual override active - respecting user changes"

      # =====================================
      # CONTINUE MODE - INTELLIGENT FAN ADJUSTMENT
      # Dynamically adjust fan speed when already cooling/heating within comfort zone
      # Pursuing overshoot target with smart power management
      # =====================================
      - conditions:
          # Global activation check
          - condition: template
            value_template: "{{ should_activate }}"

          # Already in cooling mode
          - condition: template
            value_template: "{{ last_mode in ['cooling', 'bed_comfort_eco', 'bed_comfort_quiet'] }}"

          # Within comfort zone (not overheated)
          - condition: template
            value_template: "{{ current_temp <= comfort_max_temp }}"

          # Near overshoot target (within 0.5¬∞C above or below)
          # v4.6.0: Extended to handle maintaining near target, not just approaching it
          # v4.7.1 FIX: Only run Continue Mode if ABOVE overshoot target (haven't reached it yet)
          # Once overshoot_target is reached, fall through to Comfort Zone Action for user's selected behavior
          - condition: template
            value_template: >
              {% set overshoot_target = target_temp - target_overshoot %}
              {{ current_temp > overshoot_target and current_temp < (comfort_max_temp - 0.1) }}

          # Cooling enabled
          - condition: template
            value_template: "{{ enable_cooling }}"

        sequence:
          # v4.7.1 FIX: Update helper_change timestamp to prevent false manual override detection
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: !input helper_last_change
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          - variables:
              # v4.6.12 FIX: Smart fan level respecting BOTH effectiveness AND escalation level
              # Use the HIGHER of effectiveness-based fan or escalation-based fan
              continue_mode_fan_level: >
                {% set overshoot_target = target_temp - target_overshoot %}
                {% set distance = current_temp - overshoot_target %}

                {# Calculate effectiveness-based fan level (gentle approach when working well) #}
                {% if current_effectiveness >= 85 and distance <= 0.3 %}
                  {% set effectiveness_fan = 1 %}  {# Excellent performance, very close - minimum fan #}
                {% elif current_effectiveness >= 75 and distance <= 0.5 %}
                  {% set effectiveness_fan = 1 %}  {# Great performance, close - minimum fan #}
                {% elif current_effectiveness >= 65 and distance <= 1.0 %}
                  {% set effectiveness_fan = 2 %}  {# Good performance, getting close - low fan #}
                {% elif current_effectiveness >= 50 and distance <= 1.5 %}
                  {% set effectiveness_fan = 2 %}  {# Decent performance, approaching - low fan #}
                {% elif distance <= 0.5 %}
                  {% set effectiveness_fan = 2 %}  {# Very close regardless of effectiveness - be gentle #}
                {% else %}
                  {% set effectiveness_fan = 3 %}  {# Need more power to reach overshoot target #}
                {% endif %}

                {# Map escalation level to fan level (power boost when stalling) #}
                {% if final_escalation_level == 4 %}
                  {% set escalation_fan = 5 %}  {# Maximum power - AC is severely stalling #}
                {% elif final_escalation_level == 3 %}
                  {% set escalation_fan = 4 %}  {# High power - AC is stalling #}
                {% elif final_escalation_level >= 2 %}
                  {% set escalation_fan = 3 %}  {# Medium power - AC needs help #}
                {% else %}
                  {% set escalation_fan = 1 %}  {# Normal operation #}
                {% endif %}

                {# Use the HIGHER of the two - respects both gentle approach AND stall detection #}
                {{ [effectiveness_fan, escalation_fan] | max }}

              # Select best available fan mode for continue mode
              continue_fan_mode: >
                {% set fans = state_attr(climate_list[0], 'fan_modes') | list %}
                {% set level = continue_mode_fan_level | int %}
                {% if ('Level ' ~ level) in fans %}
                  Level {{ level }}
                {% elif level | string in fans %}
                  {{ level }}
                {% elif level == 1 and 'Silence' in fans %}
                  Silence
                {% elif level == 1 and 'quiet' in fans %}
                  quiet
                {% elif level == 1 and 'Quiet' in fans %}
                  Quiet
                {% elif level == 1 and 'low' in fans %}
                  low
                {% elif level == 1 and 'Low' in fans %}
                  Low
                {% elif level == 2 and 'medium-low' in fans %}
                  medium-low
                {% elif level == 3 and 'medium' in fans %}
                  medium
                {% elif level == 3 and 'Medium' in fans %}
                  Medium
                {% elif 'auto' in fans %}
                  auto
                {% elif 'Auto' in fans %}
                  Auto
                {% else %}
                  {{ fans[0] if fans else 'Auto' }}
                {% endif %}

              # HVAC mode stays cool
              continue_hvac_mode: >
                {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                {% if 'cool' in modes %}
                  cool
                {% elif 'Cool' in modes %}
                  Cool
                {% else %}
                  {{ modes[0] if modes else 'cool' }}
                {% endif %}

          # Debug logging for continue mode
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üéØ {{ room_name | upper }} CONTINUE MODE - INTELLIGENT FAN ADJUSTMENT

                    üìä Status:
                        ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                        ‚Ä¢ Overshoot Target: {{ (target_temp - target_overshoot) | round(1) }}¬∞C
                        ‚Ä¢ Distance: {{ (current_temp - (target_temp - target_overshoot)) | round(2) }}¬∞C
                        ‚Ä¢ Effectiveness: {{ current_effectiveness }}%

                    üåÄ Fan Decision:
                        ‚Ä¢ Escalation Level: {{ final_escalation_level }} ‚Üí Fan {{ [1, 3, 4, 5][final_escalation_level | int(0) - 1] if final_escalation_level | int(0) >= 1 else 1 }}
                        ‚Ä¢ Effectiveness-Based: {{ current_effectiveness }}% ‚Üí Fan {% if current_effectiveness >= 85 %}1{% elif current_effectiveness >= 65 %}2{% elif current_effectiveness >= 50 %}2{% else %}3{% endif %}
                        ‚Ä¢ Final Smart Fan Level: {{ continue_mode_fan_level }} (higher of both)
                        ‚Ä¢ Selected Fan Mode: {{ continue_fan_mode }}

                    üí° Continue Mode: Using escalation-aware fan control (v4.6.12 fix)
                  level: warning

          # Debug service call parameters BEFORE sending
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üîç {{ room_name | upper }} DEBUG: CONTINUE MODE SERVICE CALL PARAMETERS

                    üìä Service Call Details:
                        ‚Ä¢ Fan Mode: {{ continue_fan_mode }}
                        ‚Ä¢ HVAC Mode: {{ continue_hvac_mode }}
                        ‚Ä¢ Temperature: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Target Entity: {{ climate_list }}
                  level: warning

          # v4.7.1 FIX: Update expected state helpers BEFORE service calls
          # This prevents false positive manual override detection
          - if:
              - condition: template
                value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_fan }}"
                data:
                  value: "{{ continue_fan_mode }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "{{ continue_hvac_mode }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_expected_temp }}"
                data:
                  value: "{{ adjusted_target }}"
                continue_on_error: true

          # v5.0.4: MANDATORY BRP084 SERVICE CALL PATTERN
          # Helper updates above are instant - no delay needed
          # BRP084 Firmware 2.8.0: Fan settings only work when mode is set (not 'off')
          # BRP069 Firmware: Does GET before every set(), preserves settings
          #
          # MANDATORY Pattern: temp+hvac FIRST (turns on AC), then fan immediately after
          # This works for BOTH firmware types.
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                # Step 1: Set temperature + HVAC mode in ONE call
                - service: climate.set_temperature
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    temperature: "{{ adjusted_target }}"
                    hvac_mode: "{{ continue_hvac_mode }}"
                  continue_on_error: false  # FAIL LOUDLY

                # Step 2: Tiny delay allows pydaikin batching on BRP069
                - delay:
                    milliseconds: 10

                # Step 3: Set fan mode immediately
                - service: climate.set_fan_mode
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    fan_mode: "{{ continue_fan_mode }}"
                  continue_on_error: false  # FAIL LOUDLY

          # v5.0.6 FIX: Update snapshot after service calls to prevent false override detection
          # Build snapshot from EXPECTED values (what we commanded), not AC state (might not have updated yet)
          - if:
              - condition: template
                value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] }}"
            then:
              - variables:
                  snapshot_hvac: "{{ states(helper_expected_hvac) if helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] else continue_hvac_mode }}"
                  snapshot_temp: "{{ states(helper_expected_temp) | float(adjusted_target) if helper_expected_temp not in [none, '', 'unavailable', 'unknown'] else adjusted_target }}"
                  snapshot_fan: "{{ states(helper_expected_fan) if helper_expected_fan not in [none, '', 'unavailable', 'unknown'] else continue_fan_mode }}"
                  snapshot_swing: "{{ states(helper_expected_swing) if helper_expected_swing not in [none, '', 'unavailable', 'unknown'] else 'unknown' }}"
                  update_snapshot: "hvac={{ snapshot_hvac }},temp={{ snapshot_temp }},fan={{ snapshot_fan }},swing={{ snapshot_swing }}"
                  update_checksum: >
                    {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
                    {{ ((snapshot_temp * 1000) + (snapshot_fan | string | length) + (snapshot_swing | string | length) + hvac_codes.get(snapshot_hvac, 99)) | int(0) }}

              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_last_command }}"
                data:
                  value: "{{ update_snapshot }}"
                continue_on_error: true

              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_state_checksum }}"
                data:
                  value: "{{ update_checksum }}"
                continue_on_error: true

              # Debug log snapshot update
              - if:
                  - condition: template
                    value_template: "{{ debug_enabled }}"
                then:
                  - service: system_log.write
                    data:
                      message: >
                        üì∏ {{ room_name | upper }} SNAPSHOT UPDATED (Continue Mode)
                            ‚Ä¢ New Snapshot: {{ update_snapshot }}
                            ‚Ä¢ New Checksum: {{ update_checksum }}
                            ‚Ä¢ HVAC: {{ snapshot_hvac }}
                            ‚Ä¢ Temp: {{ snapshot_temp }}¬∞C
                            ‚Ä¢ Fan: {{ snapshot_fan }}
                      level: warning

          # v4.6.1: Continue Mode does NOT update helper_change
          # This allows bed comfort mode to activate after runtime_min is met
          # (Continue mode is just adjusting fan speed, not changing modes)

      # =====================================
      # UNIFIED COOLING MODE (v4.0.0)
      # Replaces cooling_high/medium/low tiers with dynamic escalation
      # =====================================
      - conditions:
          # Global activation check
          - condition: template
            value_template: "{{ should_activate }}"

          # Temperature above comfort zone
          - condition: template
            value_template: "{{ current_temp > comfort_max_temp }}"

          # Cooling enabled
          - condition: template
            value_template: "{{ enable_cooling }}"

          # Runtime protection (respect minimum runtime)
          - condition: template
            value_template: >
              {% set time_protection_met = (
                last_mode in ['cooling', 'cooling_low', 'cooling_medium', 'cooling_high', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only']
                and time_in_current_mode >= runtime_min
              ) or last_mode not in ['cooling', 'cooling_low', 'cooling_medium', 'cooling_high', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] %}
              {{ time_protection_met }}

        sequence:
          # Define variables for fan speed, HVAC mode, and swing mode based on escalation level
          - variables:
              # Map escalation level (0-4) to fan level (1-5)
              desired_fan_level: >
                {% if final_escalation_level == 0 %}
                  1
                {% elif final_escalation_level == 1 %}
                  2
                {% elif final_escalation_level == 2 %}
                  3
                {% elif final_escalation_level == 3 %}
                  4
                {% else %}
                  5
                {% endif %}

              # Select best available fan mode for this escalation level
              selected_fan_mode: >
                {% set fans = state_attr(climate_list[0], 'fan_modes') | list %}
                {% set level = desired_fan_level | int %}
                {% if ('Level ' ~ level) in fans %}
                  Level {{ level }}
                {% elif level | string in fans %}
                  {{ level }}
                {% elif level == 1 and 'quiet' in fans %}
                  quiet
                {% elif level == 1 and 'Quiet' in fans %}
                  Quiet
                {% elif level == 1 and 'low' in fans %}
                  low
                {% elif level == 1 and 'Low' in fans %}
                  Low
                {% elif level == 2 and 'medium-low' in fans %}
                  medium-low
                {% elif level == 3 and 'medium' in fans %}
                  medium
                {% elif level == 3 and 'Medium' in fans %}
                  Medium
                {% elif level == 4 and 'medium-high' in fans %}
                  medium-high
                {% elif level == 5 and 'high' in fans %}
                  high
                {% elif level == 5 and 'High' in fans %}
                  High
                {% elif 'auto' in fans %}
                  auto
                {% elif 'Auto' in fans %}
                  Auto
                {% else %}
                  {{ fans[-1] if fans else 'Auto' }}
                {% endif %}

              # Select cooling HVAC mode with fallbacks
              selected_hvac_mode: >
                {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                {% if 'cool' in modes %}
                  cool
                {% elif 'Cool' in modes %}
                  Cool
                {% elif enable_heating and 'auto' in modes %}
                  auto
                {% elif enable_heating and 'Auto' in modes %}
                  Auto
                {% elif enable_heating and 'heat_cool' in modes %}
                  heat_cool
                {% elif enable_heating and 'Heat/Cool' in modes %}
                  Heat/Cool
                {% else %}
                  {{ modes[0] if modes else 'cool' }}
                {% endif %}

              # Swing mode selection
              desired_swing: !input swing_mode_active
              selected_swing_mode: >
                {% set swing_modes = state_attr(climate_list[0], 'swing_modes') | list %}
                {% if desired_swing in swing_modes %}
                  {{ desired_swing }}
                {% elif desired_swing == 'both' and '3D' in swing_modes %}
                  3D
                {% elif desired_swing == 'both' and 'Both' in swing_modes %}
                  Both
                {% elif 'both' in swing_modes %}
                  both
                {% elif 'Both' in swing_modes %}
                  Both
                {% elif '3D' in swing_modes %}
                  3D
                {% elif 'vertical' in swing_modes %}
                  vertical
                {% elif 'Vertical' in swing_modes %}
                  Vertical
                {% else %}
                  none
                {% endif %}

          # Enhanced debug logging with escalation visibility
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                ‚ùÑÔ∏è {{ room_name | upper }} COOLING - ESCALATION L{{ final_escalation_level }}/4

                üìä Temperature:
                    ‚Ä¢ Current: {{ current_temp }}¬∞C ‚Üí Target: {{ target_temp }}¬∞C
                    ‚Ä¢ Distance: {{ (current_temp - target_temp) | round(1) }}¬∞C to go
                    ‚Ä¢ Overshoot target: {{ adjusted_target }}¬∞C
                    ‚Ä¢ Comfort zone: {{ comfort_min_temp }}¬∞C - {{ comfort_max_temp }}¬∞C

                ‚ö° Performance:
                    ‚Ä¢ Escalation: L{{ final_escalation_level }} ({{ ['GENTLE', 'SMALL BOOST', 'MODERATE', 'STRONG', 'EMERGENCY'][final_escalation_level | int] }})
                    ‚Ä¢ Fan: {{ selected_fan_mode }}
                    ‚Ä¢ Effectiveness: {{ current_effectiveness | round(0) }}%
                    ‚Ä¢ Rate: {{ temp_change_rate | round(2) }}¬∞C/min
                    ‚Ä¢ Time in mode: {{ time_in_current_mode | round(1) }} min

                üí° Reason: {{ escalation_reason if escalation_reason is defined else 'Temperature control' }}
              level: warning
              logger: "blueprints.climate_control.{{ room_name | lower | replace(' ', '_') }}"

          # v5.0.3: ALWAYS SEND - Let integration handle deduplication
          # The integration has optimistic state + 30s timeout specifically to handle this
          # Our job: Calculate correct settings and send them
          # Integration's job: Deduplicate via optimistic state, batch rapid calls
          # Result: Commands ALWAYS sent when automation runs, integration prevents spam

          # Update helper BEFORE activation to prevent false manual override detection
          - if:
              - condition: template
                value_template: "{{ helper_mode not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_mode }}"
                data:
                  value: "cooling"

          # v4.1.2 CRITICAL FIX: Update expected state helpers BEFORE climate service calls
          # Problem: Climate state change triggers new automation run BEFORE expected helpers are updated
          # ‚Üí New run sees stale helper_expected_hvac='off' ‚Üí automation_expects_on=false ‚Üí FALSE OVERRIDE!
          # Solution: Update expected helpers first so any triggered automation run sees correct values
          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "{{ selected_hvac_mode }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_fan }}"
                data:
                  value: "{{ selected_fan_mode }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              # v4.2.0 FIX: Use input_number.set_value (helper_expected_temp is input_number, not input_text)
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_expected_temp }}"
                data:
                  value: "{{ adjusted_target }}"
                continue_on_error: true

          # Update helper_change timestamp BEFORE climate service calls
          # This ensures snapshot comparison sees the most recent command timestamp
          - if:
              - condition: template
                value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ helper_change }}"
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_mode_time not in [none, '', 'unavailable', 'unknown'] and helper_last_mode_at_start != 'cooling' }}"
            then:
              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ helper_mode_time }}"
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_temp_history not in [none, '', 'unavailable', 'unknown'] and helper_last_mode_at_start != 'cooling' }}"
            then:
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_temp_history }}"
                data:
                  value: "{{ current_temp }}"
                continue_on_error: true

          # v4.7.1 CRITICAL: 200ms delay for helper writes to commit
          # Prevents async race condition where climate state change triggers new automation
          # before helper values commit to state machine
          - delay:
              milliseconds: 200

          # v5.0.3: ALWAYS send climate service calls (integration handles deduplication)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"

                # v4.7.0 FIX: Use parallel calls to prevent coordinator blocking
                # climate.set_temperature with hvac_mode implicitly turns on AC (pow=1)
                - parallel:
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ current_entity }}"
                      data:
                        temperature: "{{ adjusted_target }}"
                        hvac_mode: "{{ selected_hvac_mode }}"
                      continue_on_error: false

                    - sequence:
                        # Tiny delay to ensure temperature call starts first
                        - delay:
                            milliseconds: 10
                        # Then immediately call fan mode
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode }}"
                          continue_on_error: false

                # Call swing mode separately (optional, can fail)
                - if:
                    - condition: template
                      value_template: "{{ selected_swing_mode not in ['none', '', 'unavailable', 'unknown'] }}"
                  then:
                    - service: climate.set_swing_mode
                      target:
                        entity_id: "{{ current_entity }}"
                      data:
                        swing_mode: "{{ selected_swing_mode }}"
                      continue_on_error: true

          # v5.0.6 FIX: Update snapshot after service calls to prevent false override detection
          - if:
              - condition: template
                value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] }}"
            then:
              - variables:
                  snapshot_hvac: "{{ states(helper_expected_hvac) if helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] else selected_hvac_mode }}"
                  snapshot_temp: "{{ states(helper_expected_temp) | float(adjusted_target) if helper_expected_temp not in [none, '', 'unavailable', 'unknown'] else adjusted_target }}"
                  snapshot_fan: "{{ states(helper_expected_fan) if helper_expected_fan not in [none, '', 'unavailable', 'unknown'] else selected_fan_mode }}"
                  snapshot_swing: "{{ states(helper_expected_swing) if helper_expected_swing not in [none, '', 'unavailable', 'unknown'] else selected_swing_mode }}"
                  update_snapshot: "hvac={{ snapshot_hvac }},temp={{ snapshot_temp }},fan={{ snapshot_fan }},swing={{ snapshot_swing }}"
                  update_checksum: >
                    {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
                    {{ ((snapshot_temp * 1000) + (snapshot_fan | string | length) + (snapshot_swing | string | length) + hvac_codes.get(snapshot_hvac, 99)) | int(0) }}

              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_last_command }}"
                data:
                  value: "{{ update_snapshot }}"
                continue_on_error: true

              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_state_checksum }}"
                data:
                  value: "{{ update_checksum }}"
                continue_on_error: true

              - if:
                  - condition: template
                    value_template: "{{ debug_enabled }}"
                then:
                  - service: system_log.write
                    data:
                      message: >
                        üì∏ {{ room_name | upper }} SNAPSHOT UPDATED (Unified Cooling)
                            ‚Ä¢ New Snapshot: {{ update_snapshot }}
                            ‚Ä¢ New Checksum: {{ update_checksum }}
                            ‚Ä¢ HVAC: {{ snapshot_hvac }}
                            ‚Ä¢ Temp: {{ snapshot_temp }}¬∞C
                            ‚Ä¢ Fan: {{ snapshot_fan }}
                            ‚Ä¢ Swing: {{ snapshot_swing }}
                      level: warning

          # v4.2.2: Helper updates moved to BEFORE climate service calls (lines 6273-6304)
          # This prevents race condition where climate_state_change trigger fires before helpers updated

      # =====================================
      # v4.6.0: CONTINUE MODE - INTELLIGENT FAN ADJUSTMENT (HEATING)
      # Dynamically adjust fan speed when already heating within comfort zone
      # Pursuing overshoot target with smart power management
      # =====================================
      - conditions:
          # Global activation check
          - condition: template
            value_template: "{{ should_activate }}"

          # Already in heating mode
          - condition: template
            value_template: "{{ last_mode in ['heating'] }}"

          # Within comfort zone (not too cold)
          - condition: template
            value_template: "{{ current_temp >= comfort_min_temp }}"

          # Near overshoot target (within 0.5¬∞C above or below)
          # v4.6.0: Extended to handle maintaining near target, not just approaching it
          # v4.7.1 FIX: Only run Continue Mode if BELOW overshoot target (haven't reached it yet)
          # Once overshoot_target is reached, fall through to Comfort Zone Action for user's selected behavior
          - condition: template
            value_template: >
              {% set overshoot_target = target_temp + target_overshoot %}
              {{ current_temp < overshoot_target and current_temp > (comfort_min_temp + 0.1) }}

          # Heating enabled
          - condition: template
            value_template: "{{ enable_heating }}"

        sequence:
          # v4.7.1 FIX: Update helper_change timestamp to prevent false manual override detection
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: !input helper_last_change
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          - variables:
              # v4.6.12 FIX: Smart fan level respecting BOTH effectiveness AND escalation level
              # Use the HIGHER of effectiveness-based fan or escalation-based fan
              continue_mode_fan_level_heating: >
                {% set overshoot_target = target_temp + target_overshoot %}
                {% set distance = overshoot_target - current_temp %}

                {# Calculate effectiveness-based fan level (gentle approach when working well) #}
                {% if current_effectiveness >= 85 and distance <= 0.3 %}
                  {% set effectiveness_fan = 1 %}  {# Excellent performance, very close - minimum fan #}
                {% elif current_effectiveness >= 75 and distance <= 0.5 %}
                  {% set effectiveness_fan = 1 %}  {# Great performance, close - minimum fan #}
                {% elif current_effectiveness >= 65 and distance <= 1.0 %}
                  {% set effectiveness_fan = 2 %}  {# Good performance, getting close - low fan #}
                {% elif current_effectiveness >= 50 and distance <= 1.5 %}
                  {% set effectiveness_fan = 2 %}  {# Decent performance, approaching - low fan #}
                {% elif distance <= 0.5 %}
                  {% set effectiveness_fan = 2 %}  {# Very close regardless of effectiveness - be gentle #}
                {% else %}
                  {% set effectiveness_fan = 3 %}  {# Need more power to reach overshoot target #}
                {% endif %}

                {# Map escalation level to fan level (power boost when stalling) #}
                {% if final_escalation_level == 4 %}
                  {% set escalation_fan = 5 %}  {# Maximum power - AC is severely stalling #}
                {% elif final_escalation_level == 3 %}
                  {% set escalation_fan = 4 %}  {# High power - AC is stalling #}
                {% elif final_escalation_level >= 2 %}
                  {% set escalation_fan = 3 %}  {# Medium power - AC needs help #}
                {% else %}
                  {% set escalation_fan = 1 %}  {# Normal operation #}
                {% endif %}

                {# Use the HIGHER of the two - respects both gentle approach AND stall detection #}
                {{ [effectiveness_fan, escalation_fan] | max }}

              # Select best available fan mode for continue mode
              continue_fan_mode_heating: >
                {% set fans = state_attr(climate_list[0], 'fan_modes') | list %}
                {% set level = continue_mode_fan_level_heating | int %}
                {% if ('Level ' ~ level) in fans %}
                  Level {{ level }}
                {% elif level | string in fans %}
                  {{ level }}
                {% elif level == 1 and 'Silence' in fans %}
                  Silence
                {% elif level == 1 and 'quiet' in fans %}
                  quiet
                {% elif level == 1 and 'Quiet' in fans %}
                  Quiet
                {% elif level == 1 and 'low' in fans %}
                  low
                {% elif level == 1 and 'Low' in fans %}
                  Low
                {% elif level == 2 and 'medium-low' in fans %}
                  medium-low
                {% elif level == 3 and 'medium' in fans %}
                  medium
                {% elif level == 3 and 'Medium' in fans %}
                  Medium
                {% elif 'auto' in fans %}
                  auto
                {% elif 'Auto' in fans %}
                  Auto
                {% else %}
                  {{ fans[0] if fans else 'Auto' }}
                {% endif %}

              # HVAC mode stays heat
              continue_hvac_mode_heating: >
                {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                {% if 'heat' in modes %}
                  heat
                {% elif 'Heat' in modes %}
                  Heat
                {% else %}
                  {{ modes[0] if modes else 'heat' }}
                {% endif %}

          # Debug logging for continue mode
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üéØ {{ room_name | upper }} CONTINUE MODE - INTELLIGENT FAN ADJUSTMENT (HEATING)

                    üìä Status:
                        ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                        ‚Ä¢ Overshoot Target: {{ (target_temp + target_overshoot) | round(1) }}¬∞C
                        ‚Ä¢ Distance: {{ ((target_temp + target_overshoot) - current_temp) | round(2) }}¬∞C
                        ‚Ä¢ Effectiveness: {{ current_effectiveness }}%

                    üåÄ Fan Decision:
                        ‚Ä¢ Escalation Level: {{ final_escalation_level }} ‚Üí Fan {{ [1, 3, 4, 5][final_escalation_level | int(0) - 1] if final_escalation_level | int(0) >= 1 else 1 }}
                        ‚Ä¢ Effectiveness-Based: {{ current_effectiveness }}% ‚Üí Fan {% if current_effectiveness >= 85 %}1{% elif current_effectiveness >= 65 %}2{% elif current_effectiveness >= 50 %}2{% else %}3{% endif %}
                        ‚Ä¢ Final Smart Fan Level: {{ continue_mode_fan_level_heating }} (higher of both)
                        ‚Ä¢ Selected Fan Mode: {{ continue_fan_mode_heating }}

                    üí° Continue Mode: Using escalation-aware fan control (v4.6.12 fix)
                  level: warning

          # v4.7.1 FIX: Update expected state helpers BEFORE service calls
          # This prevents false positive manual override detection
          - if:
              - condition: template
                value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_fan }}"
                data:
                  value: "{{ continue_fan_mode_heating }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "{{ continue_hvac_mode_heating }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_expected_temp }}"
                data:
                  value: "{{ adjusted_target }}"
                continue_on_error: true

          # v5.0.4: MANDATORY BRP084 SERVICE CALL PATTERN
          # Helper updates above are instant - no delay needed
          # BRP084 Firmware 2.8.0: Fan settings only work when mode is set (not 'off')
          # BRP069 Firmware: Does GET before every set(), preserves settings
          #
          # MANDATORY Pattern: temp+hvac FIRST (turns on AC), then fan immediately after
          # This works for BOTH firmware types.
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                # Step 1: Set temperature + HVAC mode in ONE call
                - service: climate.set_temperature
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    temperature: "{{ adjusted_target }}"
                    hvac_mode: "{{ continue_hvac_mode_heating }}"
                  continue_on_error: false  # FAIL LOUDLY

                # Step 2: Tiny delay allows pydaikin batching on BRP069
                - delay:
                    milliseconds: 10

                # Step 3: Set fan mode immediately
                - service: climate.set_fan_mode
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    fan_mode: "{{ continue_fan_mode_heating }}"
                  continue_on_error: false  # FAIL LOUDLY

          # v5.0.6 FIX: Update snapshot after service calls
          - if:
              - condition: template
                value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] }}"
            then:
              - variables:
                  snapshot_hvac: "{{ states(helper_expected_hvac) if helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] else continue_hvac_mode_heating }}"
                  snapshot_temp: "{{ states(helper_expected_temp) | float(adjusted_target) if helper_expected_temp not in [none, '', 'unavailable', 'unknown'] else adjusted_target }}"
                  snapshot_fan: "{{ states(helper_expected_fan) if helper_expected_fan not in [none, '', 'unavailable', 'unknown'] else continue_fan_mode_heating }}"
                  snapshot_swing: "{{ states(helper_expected_swing) if helper_expected_swing not in [none, '', 'unavailable', 'unknown'] else 'unknown' }}"
                  update_snapshot: "hvac={{ snapshot_hvac }},temp={{ snapshot_temp }},fan={{ snapshot_fan }},swing={{ snapshot_swing }}"
                  update_checksum: >
                    {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
                    {{ ((snapshot_temp * 1000) + (snapshot_fan | string | length) + (snapshot_swing | string | length) + hvac_codes.get(snapshot_hvac, 99)) | int(0) }}
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_last_command }}"
                data:
                  value: "{{ update_snapshot }}"
                continue_on_error: true
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_state_checksum }}"
                data:
                  value: "{{ update_checksum }}"
                continue_on_error: true
              - if:
                  - condition: template
                    value_template: "{{ debug_enabled }}"
                then:
                  - service: system_log.write
                    data:
                      message: >
                        üì∏ {{ room_name | upper }} SNAPSHOT UPDATED (Continue Heating)
                            ‚Ä¢ New Snapshot: {{ update_snapshot }}
                            ‚Ä¢ New Checksum: {{ update_checksum }}
                      level: warning

          # v4.6.1: Continue Mode does NOT update helper_change
          # This allows bed comfort mode to activate after runtime_min is met
          # (Continue mode is just adjusting fan speed, not changing modes)

      # =====================================
      # UNIFIED HEATING MODE (v4.0.0)
      # Replaces heating_high/medium/low tiers with dynamic escalation
      # =====================================
      - conditions:
          # Global activation check
          - condition: template
            value_template: "{{ should_activate }}"

          # Temperature below comfort zone
          - condition: template
            value_template: "{{ current_temp < comfort_min_temp }}"

          # Heating enabled
          - condition: template
            value_template: "{{ enable_heating }}"

          # Runtime protection (respect minimum runtime)
          - condition: template
            value_template: >
              {% set time_protection_met = (
                last_mode in ['heating', 'heating_low', 'heating_medium', 'heating_high', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only']
                and time_in_current_mode >= runtime_min
              ) or last_mode not in ['heating', 'heating_low', 'heating_medium', 'heating_high', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] %}
              {{ time_protection_met }}

        sequence:
          # Define variables for fan speed, HVAC mode, and swing mode based on escalation level
          - variables:
              # Map escalation level (0-4) to fan level (1-5)
              desired_fan_level: >
                {% if final_escalation_level == 0 %}
                  1
                {% elif final_escalation_level == 1 %}
                  2
                {% elif final_escalation_level == 2 %}
                  3
                {% elif final_escalation_level == 3 %}
                  4
                {% else %}
                  5
                {% endif %}

              # Select best available fan mode for this escalation level
              selected_fan_mode: >
                {% set fans = state_attr(climate_list[0], 'fan_modes') | list %}
                {% set level = desired_fan_level | int %}
                {% if ('Level ' ~ level) in fans %}
                  Level {{ level }}
                {% elif level | string in fans %}
                  {{ level }}
                {% elif level == 1 and 'quiet' in fans %}
                  quiet
                {% elif level == 1 and 'Quiet' in fans %}
                  Quiet
                {% elif level == 1 and 'low' in fans %}
                  low
                {% elif level == 1 and 'Low' in fans %}
                  Low
                {% elif level == 2 and 'medium-low' in fans %}
                  medium-low
                {% elif level == 3 and 'medium' in fans %}
                  medium
                {% elif level == 3 and 'Medium' in fans %}
                  Medium
                {% elif level == 4 and 'medium-high' in fans %}
                  medium-high
                {% elif level == 5 and 'high' in fans %}
                  high
                {% elif level == 5 and 'High' in fans %}
                  High
                {% elif 'auto' in fans %}
                  auto
                {% elif 'Auto' in fans %}
                  Auto
                {% else %}
                  {{ fans[-1] if fans else 'Auto' }}
                {% endif %}

              # Select heating HVAC mode with fallbacks
              selected_hvac_mode: >
                {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                {% if 'heat' in modes %}
                  heat
                {% elif 'Heat' in modes %}
                  Heat
                {% elif enable_cooling and 'auto' in modes %}
                  auto
                {% elif enable_cooling and 'Auto' in modes %}
                  Auto
                {% elif enable_cooling and 'heat_cool' in modes %}
                  heat_cool
                {% elif enable_cooling and 'Heat/Cool' in modes %}
                  Heat/Cool
                {% else %}
                  {{ modes[0] if modes else 'heat' }}
                {% endif %}

              # Swing mode selection
              desired_swing: !input swing_mode_active
              selected_swing_mode: >
                {% set swing_modes = state_attr(climate_list[0], 'swing_modes') | list %}
                {% if desired_swing in swing_modes %}
                  {{ desired_swing }}
                {% elif desired_swing == 'both' and '3D' in swing_modes %}
                  3D
                {% elif desired_swing == 'both' and 'Both' in swing_modes %}
                  Both
                {% elif 'both' in swing_modes %}
                  both
                {% elif 'Both' in swing_modes %}
                  Both
                {% elif '3D' in swing_modes %}
                  3D
                {% elif 'vertical' in swing_modes %}
                  vertical
                {% elif 'Vertical' in swing_modes %}
                  Vertical
                {% else %}
                  none
                {% endif %}

          # Enhanced debug logging with escalation visibility
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                üî• {{ room_name | upper }} HEATING - ESCALATION L{{ final_escalation_level }}/4

                üìä Temperature:
                    ‚Ä¢ Current: {{ current_temp }}¬∞C ‚Üí Target: {{ target_temp }}¬∞C
                    ‚Ä¢ Distance: {{ (target_temp - current_temp) | round(1) }}¬∞C to go
                    ‚Ä¢ Overshoot target: {{ adjusted_target }}¬∞C
                    ‚Ä¢ Comfort zone: {{ comfort_min_temp }}¬∞C - {{ comfort_max_temp }}¬∞C

                ‚ö° Performance:
                    ‚Ä¢ Escalation: L{{ final_escalation_level }} ({{ ['GENTLE', 'SMALL BOOST', 'MODERATE', 'STRONG', 'EMERGENCY'][final_escalation_level | int] }})
                    ‚Ä¢ Fan: {{ selected_fan_mode }}
                    ‚Ä¢ Effectiveness: {{ current_effectiveness | round(0) }}%
                    ‚Ä¢ Rate: {{ temp_change_rate | round(2) }}¬∞C/min
                    ‚Ä¢ Time in mode: {{ time_in_current_mode | round(1) }} min

                üí° Reason: {{ escalation_reason if escalation_reason is defined else 'Temperature control' }}
              level: warning
              logger: "blueprints.climate_control.{{ room_name | lower | replace(' ', '_') }}"

          # v5.0.3: ALWAYS SEND - Let integration handle deduplication
          # The integration has optimistic state + 30s timeout specifically to handle this
          # Our job: Calculate correct settings and send them
          # Integration's job: Deduplicate via optimistic state, batch rapid calls
          # Result: Commands ALWAYS sent when automation runs, integration prevents spam

          # Update helper BEFORE activation to prevent false manual override detection
          - if:
              - condition: template
                value_template: "{{ helper_mode not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_mode }}"
                data:
                  value: "heating"

          # v4.1.2 CRITICAL FIX: Update expected state helpers BEFORE climate service calls
          # Problem: Climate state change triggers new automation run BEFORE expected helpers are updated
          # ‚Üí New run sees stale helper_expected_hvac='off' ‚Üí automation_expects_on=false ‚Üí FALSE OVERRIDE!
          # Solution: Update expected helpers first so any triggered automation run sees correct values
          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "{{ selected_hvac_mode }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_fan }}"
                data:
                  value: "{{ selected_fan_mode }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              # v4.2.0 FIX: Use input_number.set_value (helper_expected_temp is input_number, not input_text)
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_expected_temp }}"
                data:
                  value: "{{ adjusted_target }}"
                continue_on_error: true

          # Update helper_change timestamp BEFORE climate service calls
          # This ensures snapshot comparison sees the most recent command timestamp
          - if:
              - condition: template
                value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ helper_change }}"
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_mode_time not in [none, '', 'unavailable', 'unknown'] and helper_last_mode_at_start != 'heating' }}"
            then:
              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ helper_mode_time }}"
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ helper_temp_history not in [none, '', 'unavailable', 'unknown'] and helper_last_mode_at_start != 'heating' }}"
            then:
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_temp_history }}"
                data:
                  value: "{{ current_temp }}"
                continue_on_error: true

          # v4.7.1 CRITICAL: 200ms delay for helper writes to commit
          # Prevents async race condition where climate state change triggers new automation
          # before helper values commit to state machine
          - delay:
              milliseconds: 200

          # v5.0.3: ALWAYS send climate service calls (integration handles deduplication)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"

                # v4.7.0 FIX: Use parallel calls to prevent coordinator blocking
                # climate.set_temperature with hvac_mode implicitly turns on AC (pow=1)
                - parallel:
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ current_entity }}"
                      data:
                        temperature: "{{ adjusted_target }}"
                        hvac_mode: "{{ selected_hvac_mode }}"
                      continue_on_error: false

                    - sequence:
                        # Tiny delay to ensure temperature call starts first
                        - delay:
                            milliseconds: 10
                        # Then immediately call fan mode
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode }}"
                          continue_on_error: false

                # Call swing mode separately (optional, can fail)
                - if:
                    - condition: template
                      value_template: "{{ selected_swing_mode not in ['none', '', 'unavailable', 'unknown'] }}"
                  then:
                    - service: climate.set_swing_mode
                      target:
                        entity_id: "{{ current_entity }}"
                      data:
                        swing_mode: "{{ selected_swing_mode }}"
                      continue_on_error: true

          # v5.0.6 FIX: Update snapshot after service calls to prevent false override detection
          - if:
              - condition: template
                value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] }}"
            then:
              - variables:
                  snapshot_hvac: "{{ states(helper_expected_hvac) if helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] else selected_hvac_mode }}"
                  snapshot_temp: "{{ states(helper_expected_temp) | float(adjusted_target) if helper_expected_temp not in [none, '', 'unavailable', 'unknown'] else adjusted_target }}"
                  snapshot_fan: "{{ states(helper_expected_fan) if helper_expected_fan not in [none, '', 'unavailable', 'unknown'] else selected_fan_mode }}"
                  snapshot_swing: "{{ states(helper_expected_swing) if helper_expected_swing not in [none, '', 'unavailable', 'unknown'] else selected_swing_mode }}"
                  update_snapshot: "hvac={{ snapshot_hvac }},temp={{ snapshot_temp }},fan={{ snapshot_fan }},swing={{ snapshot_swing }}"
                  update_checksum: >
                    {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
                    {{ ((snapshot_temp * 1000) + (snapshot_fan | string | length) + (snapshot_swing | string | length) + hvac_codes.get(snapshot_hvac, 99)) | int(0) }}

              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_last_command }}"
                data:
                  value: "{{ update_snapshot }}"
                continue_on_error: true

              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_state_checksum }}"
                data:
                  value: "{{ update_checksum }}"
                continue_on_error: true

              - if:
                  - condition: template
                    value_template: "{{ debug_enabled }}"
                then:
                  - service: system_log.write
                    data:
                      message: >
                        üì∏ {{ room_name | upper }} SNAPSHOT UPDATED (Unified Heating)
                            ‚Ä¢ New Snapshot: {{ update_snapshot }}
                            ‚Ä¢ New Checksum: {{ update_checksum }}
                            ‚Ä¢ HVAC: {{ snapshot_hvac }}
                            ‚Ä¢ Temp: {{ snapshot_temp }}¬∞C
                            ‚Ä¢ Fan: {{ snapshot_fan }}
                            ‚Ä¢ Swing: {{ snapshot_swing }}
                      level: warning

          # v4.2.2: Helper updates moved to BEFORE climate service calls (lines 6625-6656)
          # This prevents race condition where climate_state_change trigger fires before helpers updated

      # CRITICAL: Clear stability mode when temperature exits comfort zone
      # This MUST be the FIRST condition to prevent getting stuck
      - conditions:
          - condition: template
            value_template: "{{ last_mode in ['stability_off', 'stability_eco', 'stability_fan_only'] }}"
          - condition: template
            value_template: "{{ current_temp < comfort_min_temp or current_temp > comfort_max_temp }}"
        sequence:
          # Always log this critical reset
          - service: system_log.write
            data:
              message: >
                üîÑ Stability Mode Reset: Temperature outside comfort zone!
                ‚Ä¢ Current: {{ current_temp }}¬∞C
                ‚Ä¢ Comfort Zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C
                ‚Ä¢ Was in mode: {{ last_mode }}
                ‚Ä¢ Clearing stability mode to allow normal operation
              level: warning
          
          # Don't set to "off" - set directly to cooling/heating (but respect Smart mode presence)
          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: >
                {% if control_mode == 'Smart' and not smart_presence_active %}
                  off
                {% elif current_temp > comfort_max_temp %}
                  cooling
                {% elif current_temp < comfort_min_temp %}
                  heating
                {% else %}
                  {{ last_mode if last_mode in ['cooling', 'heating'] else 'off' }}
                {% endif %}

          # v4.6.14 DEBUG: Log last_mode preservation in comfort zone
          - if:
              - condition: template
                value_template: "{{ debug_enabled and current_temp >= comfort_min_temp and current_temp <= comfort_max_temp }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üîç {{ room_name | upper }} STABILITY RESET - COMFORT ZONE

                    üìä last_mode Preservation:
                        ‚Ä¢ Previous last_mode: {{ last_mode }}
                        ‚Ä¢ Current temp: {{ current_temp }}¬∞C (in comfort zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C)
                        ‚Ä¢ New last_mode: {{ last_mode if last_mode in ['cooling', 'heating'] else 'off' }}
                        ‚Ä¢ Preserved mode: {{ 'YES' if last_mode in ['cooling', 'heating'] else 'NO' }}

                    üí° Why preserved?
                        ‚Ä¢ If cooling/heating was active, preserve it for fan-only activation
                        ‚Ä¢ Otherwise set to "off" (no active cooling/heating to preserve)
                  level: warning

          # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and last_mode not in ['cooling', 'heating', 'off'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true
          
          # Clear the stability timestamp to reset the feature
          # Don't use 1970 as it causes calculation issues - use current time instead
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ helper_temp_stable_since not in [none, '', 'unavailable', 'unknown'] }}"
                sequence:
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ helper_temp_stable_since }}"
                    data:
                      datetime: "{{ now() }}"
          
          # Now activate cooling/heating as needed since we're outside comfort zone or at trigger point
          - choose:
              # Need cooling
              - conditions:
                  - condition: template
                    value_template: "{{ current_temp > comfort_max_temp and (control_mode != 'Smart' or smart_presence_active) }}"
                sequence:
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            
                            # Smart cooling mode selection
                            # v3.10.0: Only use auto/heat_cool if heating is also enabled
                            selected_hvac_mode: >
                              {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                              {# For cooling, try cooling-capable modes #}
                              {% if 'cool' in modes %}
                                cool
                                {% elif 'Cool' in modes %}
                                Cool
                                {% elif enable_heating and 'auto' in modes %}
                                auto
                                {% elif enable_heating and 'Auto' in modes %}
                                Auto
                                {% elif enable_heating and 'heat_cool' in modes %}
                                heat_cool
                                {% elif enable_heating and 'Heat/Cool' in modes %}
                                Heat/Cool
                                {% else %}
                                off
                              {% endif %}

                        # v4.2.1 FIX: Update ALL helpers BEFORE service calls to prevent manual override false positives
                        # The 500ms verification delay can trigger new automation runs that read stale helpers

                        # 1. Update helper_change FIRST (timestamps the automation action)
                        - if:
                            - condition: template
                              value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                          then:
                            - service: input_datetime.set_datetime
                              target:
                                entity_id: "{{ helper_change }}"
                              data:
                                datetime: "{{ now() }}"
                              continue_on_error: true

                        # 2. Update helper_last_mode BEFORE service calls
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_mode }}"
                          data:
                            value: "cooling"
                          continue_on_error: true

                        # 3. Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_hvac }}"
                          data:
                            value: "{{ selected_hvac_mode }}"
                          continue_on_error: true

                        # 4. Delay for helper propagation before service calls
                        - delay:
                            milliseconds: 200

                        # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            hvac_mode: >
                              {% set available = state_attr(current_entity, 'hvac_modes') | list %}
                              {{ selected_hvac_mode if selected_hvac_mode in available else (available[0] if available else 'off') }}
                          continue_on_error: true

                        # v3.16.14 FIX: Wrapped debug in if/then to not block helper updates
                        - if:
                            - condition: template
                              value_template: "{{ debug_enabled }}"
                          then:
                            - service: system_log.write
                              data:
                                message: >
                                  üîç SMART COOL MODE: {{ repeat.item }}
                                  ‚Ä¢ Available: {{ available_modes | join(', ') }}
                                  ‚Ä¢ Selected: {{ selected_hvac_mode }}
                                  ‚Ä¢ Actual: {{ states(current_entity) }}
                                  ‚Ä¢ Reason: Best cooling mode for this AC unit
                                level: debug

                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: "{{ cooling_target_temp }}"
                    continue_on_error: true

                  # v3.9.13 FIX: Set fan BEFORE temperature
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                            desired_max_fan: !input fan_speed_max
                            selected_fan_mode: >
                              {% if desired_max_fan in available_fans %}
                                {{ desired_max_fan }}
                                {% elif '5' in available_fans %}
                                5
                                {% elif 'Level 5' in available_fans %}
                                Level 5
                                {% elif 'high' in available_fans %}
                                high
                                {% elif 'Auto' in available_fans %}
                                Auto
                                {% elif 'auto' in available_fans %}
                                auto
                                {% else %}
                                {{ available_fans[-1] if available_fans else 'Auto' }}
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_fan }}"
                          data:
                            value: "{{ selected_fan_mode }}"
                          continue_on_error: true

                        # v4.6.5: Batched service call - no verification retry needed
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode }}"
                          continue_on_error: true

                  # v4.2.1: helper_last_mode already updated BEFORE service calls (line ~6722)
                  # This ensures new automation runs from climate_state_change see correct mode

                  # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
                  - condition: template
                    value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'cooling' or actual_ac_state == 'off') }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ helper_mode_time }}"
                    data:
                      datetime: "{{ now() }}"

                  - service: system_log.write
                    data:
                      message: >
                        ‚ùÑÔ∏è Cooling activated after stability reset
                        ‚Ä¢ Temperature: {{ current_temp }}¬∞C
                        ‚Ä¢ Target: {{ cooling_target_temp }}¬∞C
                      level: warning
              
              # Need heating
              - conditions:
                  - condition: template
                    value_template: >
                      {% set time_protection_met = (last_mode == 'heating' and (final_escalation_level > 0 or time_in_current_mode > runtime_min)) or ((last_mode == 'off' or actual_ac_state == 'off') and (not enforce_offtime or time_in_current_mode > offtime_min)) or (last_mode != 'heating' and last_mode != 'off') %}
                      {{ should_activate and current_temp < comfort_min_temp and time_protection_met and (control_mode != 'Smart' or smart_presence_active) }}
                sequence:
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            
                            # Smart heating mode selection
                            # v3.10.0: Only use auto/heat_cool if cooling is also enabled
                            selected_hvac_mode: >
                              {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                              {# For heating, try heating-capable modes #}
                              {% if 'heat' in modes %}
                                heat
                                {% elif 'Heat' in modes %}
                                Heat
                                {% elif enable_cooling and 'auto' in modes %}
                                auto
                                {% elif enable_cooling and 'Auto' in modes %}
                                Auto
                                {% elif enable_cooling and 'heat_cool' in modes %}
                                heat_cool
                                {% elif enable_cooling and 'Heat/Cool' in modes %}
                                Heat/Cool
                                {% else %}
                                off
                              {% endif %}

                        # v4.2.1 FIX: Update ALL helpers BEFORE service calls to prevent manual override false positives

                        # 1. Update helper_change FIRST (timestamps the automation action)
                        - if:
                            - condition: template
                              value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                          then:
                            - service: input_datetime.set_datetime
                              target:
                                entity_id: "{{ helper_change }}"
                              data:
                                datetime: "{{ now() }}"
                              continue_on_error: true

                        # 2. Update helper_last_mode BEFORE service calls
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_mode }}"
                          data:
                            value: "heating"
                          continue_on_error: true

                        # 3. Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_hvac }}"
                          data:
                            value: "{{ selected_hvac_mode }}"
                          continue_on_error: true

                        # 4. Delay for helper propagation before service calls
                        - delay:
                            milliseconds: 200

                        # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            hvac_mode: >
                              {% set available = state_attr(current_entity, 'hvac_modes') | list %}
                              {{ selected_hvac_mode if selected_hvac_mode in available else (available[0] if available else 'off') }}
                          continue_on_error: true

                        # v3.16.14 FIX: Wrapped debug in if/then to not block helper updates
                        - if:
                            - condition: template
                              value_template: "{{ debug_enabled }}"
                          then:
                            - service: system_log.write
                              data:
                                message: >
                                  üîç SMART HEAT MODE: {{ repeat.item }}
                                  ‚Ä¢ Available: {{ available_modes | join(', ') }}
                                  ‚Ä¢ Selected: {{ selected_hvac_mode }}
                                  ‚Ä¢ Actual: {{ states(current_entity) }}
                                  ‚Ä¢ Reason: Best heating mode for this AC unit
                                level: debug

                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: "{{ heating_target_temp }}"
                    continue_on_error: true

                  # v4.6.0: CRITICAL FIX - Set fan mode FIRST, then temperature
                  # Otherwise climate.set_temperature preserves old fan mode (Daikin integration bug)
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                            desired_max_fan: !input fan_speed_max
                            selected_fan_mode: >
                              {% if desired_max_fan in available_fans %}
                                {{ desired_max_fan }}
                                {% elif '5' in available_fans %}
                                5
                                {% elif 'Level 5' in available_fans %}
                                Level 5
                                {% elif 'high' in available_fans %}
                                high
                                {% elif 'Auto' in available_fans %}
                                Auto
                                {% elif 'auto' in available_fans %}
                                auto
                                {% else %}
                                {{ available_fans[-1] if available_fans else 'Auto' }}
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_fan }}"
                          data:
                            value: "{{ selected_fan_mode }}"
                          continue_on_error: true

                        # v4.6.5: Batched service call - no verification retry needed
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode | trim }}"
                          continue_on_error: true

                  # v4.6.5: Batched service call - small delay for fan mode propagation
                  - delay:
                      milliseconds: 200

                  - service: climate.set_temperature
                    target:
                      entity_id: !input climate_entities
                    data:
                      temperature: "{{ heating_target_temp }}"
                    continue_on_error: true

                  # v4.2.1: helper_last_mode already updated BEFORE service calls (line ~6922)

                  # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
                  - condition: template
                    value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'heating' or actual_ac_state == 'off') }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ helper_mode_time }}"
                    data:
                      datetime: "{{ now() }}"

                  - service: system_log.write
                    data:
                      message: >
                        üî• Heating activated after stability reset
                        ‚Ä¢ Temperature: {{ current_temp }}¬∞C
                        ‚Ä¢ Target: {{ heating_target_temp }}¬∞C
                      level: warning

      # Pre-conditioning when approaching
      # v3.11.9 FIX: Only pre-condition when approaching from OUTSIDE, not when already home
      - conditions:
          - condition: template
            value_template: "{{ enable_pre_conditioning }}"
          - condition: template
            value_template: "{{ should_activate }}"
          - condition: template
            value_template: "{{ approaching_home and not anyone_home }}"
          - condition: template
            value_template: >
              {% set needs_cooling = current_temp > comfort_max_temp and current_temp > target_temp and enable_cooling %}
              {% set needs_heating = current_temp < comfort_min_temp and current_temp < target_temp and enable_heating %}
              {{ needs_cooling or needs_heating }}
        sequence:
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                üîç {{ room_name | upper }} CLIMATE DEBUG: Pre-conditioning activated
                ‚Ä¢ Reason: Approaching home
                {% if proximity_sensor %}Distance: {{ states(proximity_sensor) }}m{% endif %}
                ‚Ä¢ Temperature: {{ current_temp }}¬∞C needs adjustment
              level: warning

          # v4.3.0 FIX: Update ALL helpers BEFORE service calls to prevent manual override false positives

          # STEP 1: Update helper_change FIRST (timestamps the automation action)
          - if:
              - condition: template
                value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ helper_change }}"
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

          # STEP 2: Update helper_last_mode
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_mode }}"
            data:
              value: "pre_conditioning"
            continue_on_error: true

          # STEP 3: Calculate expected values ONCE for all helpers
          - variables:
              precond_hvac_mode: >
                {% if current_temp > comfort_max_temp and enable_cooling %}
                  cool
                {% elif current_temp < comfort_min_temp and enable_heating %}
                  heat
                {% elif enable_cooling and enable_heating %}
                  heat_cool
                {% elif enable_cooling %}
                  cool
                {% elif enable_heating %}
                  heat
                {% else %}
                  off
                {% endif %}
              precond_fan_mode: >
                {% set available_fans = state_attr(climate_list[0], 'fan_modes') | list %}
                {% set desired_medium_fan = fan_speed_medium %}
                {% if desired_medium_fan in available_fans %}
                  {{ desired_medium_fan }}
                {% elif '3' in available_fans %}
                  3
                {% elif 'Level 3' in available_fans %}
                  Level 3
                {% elif 'medium' in available_fans %}
                  medium
                {% elif 'Auto' in available_fans %}
                  Auto
                {% elif 'auto' in available_fans %}
                  auto
                {% else %}
                  {{ available_fans[-1] if available_fans else 'Auto' }}
                {% endif %}

          # STEP 4: Update helper_expected_hvac
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: "{{ precond_hvac_mode }}"
            continue_on_error: true

          # STEP 5: Update helper_expected_temp
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ adjusted_target }}"
            continue_on_error: true

          # STEP 6: Update helper_expected_fan
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_fan }}"
            data:
              value: "{{ precond_fan_mode }}"
            continue_on_error: true

          # v4.7.1 CRITICAL: 200ms delay for helper writes to commit
          # Prevents async race condition where climate state change triggers new automation
          # before helper values commit to state machine
          - delay:
              milliseconds: 200

          # v5.0.3: MANDATORY BRP084 Pattern - rapid batched calls (NO DELAYS)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                # FIRST: Temperature + HVAC mode together (turns AC ON atomically)
                - service: climate.set_temperature
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    temperature: "{{ adjusted_target }}"
                    hvac_mode: "{{ precond_hvac_mode }}"
                  continue_on_error: false

                # SECOND: Fan mode IMMEDIATELY (allows pydaikin batching on BRP069)
                - service: climate.set_fan_mode
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    fan_mode: "{{ precond_fan_mode }}"
                  continue_on_error: false

          - service: system_log.write
            data:
              message: >
                üå°Ô∏è {{ room_name | upper }} TEMP SET: Pre-conditioning
                Set AC to: {{ adjusted_target | round(0) }}¬∞C (rounded for AC compatibility)
                Actual value: {{ adjusted_target | round(1) }}¬∞C
                ‚Ä¢ Reason: Pre-conditioning target temperature (approaching home)
                Current: {{ current_temp | round(1) }}¬∞C ‚Üí Target: {{ adjusted_target | round(1) }}¬∞C
              level: warning

          - condition: template
            value_template: "{{ enable_notifications }}"

          - service: !input notification_service
            data:
              title: "Climate Pre-conditioning"
              message: >
                Pre-conditioning started - approaching home.
                Current: {{ current_temp }}¬∞C
            continue_on_error: true

      # Cooling mode for pre-conditioning when approaching home
      # Activates when temperature exceeds comfort zone max
      # NEW: Prevents short cycling by using target-based hysteresis logic
      # IMPORTANT: Only for pre-conditioning - not when already home in Smart mode
      # v3.11.9 FIX: Only pre-condition when approaching from OUTSIDE, not when already home
      - conditions:
          - condition: template
            value_template: "{{ should_activate and approaching_home and not anyone_home }}"
          - condition: template
            value_template: >
              {% if last_mode == 'cooling' %}
                {# Already cooling - continue until target reached #}
                {% if current_temp <= (target_temp - target_overshoot) %}
                  False  {# EXIT: Target achieved with overshoot - cooled to {{ (target_temp - target_overshoot) | round(1) }}¬∞C (strategy: {{ overshoot_strategy }}) #}
                {% else %}
                  {{ should_activate and enable_cooling and current_temp > (target_temp - target_overshoot) }}
                {% endif %}
              {% else %}
                {# Not cooling - start if comfort max exceeded #}
                {{ should_activate and enable_cooling and current_temp > comfort_max_temp }}
              {% endif %}
          - condition: template
            value_template: >
              {% if last_mode == 'cooling' %}
                {# Same cooling mode - allow escalation, enforce runtime for de-escalation #}
                {{ final_escalation_level > 0 or time_in_current_mode > runtime_min }}
              {% elif (last_mode == 'off' or actual_ac_state == 'off') and enforce_offtime %}
                {# Starting from OFF - enforce off-time if enabled #}
                {# Check BOTH helper mode AND actual AC state to catch mode change scenarios #}
                {{ time_in_current_mode > offtime_min }}
              {% else %}
                {# Switching from heating/eco OR off-time protection disabled #}
                true
              {% endif %}
        sequence:
          - service: system_log.write
            data:
              message: >
                {% set current_mode = states(helper_mode) | default('off') %}
                {% set temp_gap = (current_temp - target_temp) | round(1) %}
                {% set eta_minutes = (temp_gap / temp_change_rate) | round(0) if temp_change_rate > 0 else 99 %}
                {% set effectiveness = current_effectiveness if dynamic_enabled else 70 %}
                {% set escalation = escalation_level if dynamic_enabled else 0 %}
                {% set deescalation = deescalation_level if dynamic_enabled else 0 %}
                {% set temp_gap_adjusted = temp_gap | abs | round(1) %}
                {% set distance_adjusted = temp_gap | abs | round(1) %}
                {% set esc_display = 'L' ~ escalation if escalation > 0 else ('DE-L' ~ deescalation if deescalation > 0 else 'None') %}
                {% set current_fan = state_attr(climate_list[0], 'fan_mode') | default('Auto') %}

                {% if current_mode == 'cooling' %}
                  {% if temp_gap <= 0.3 %}
                    üéØ {{ room_name | upper }} LOW COOLING - PRECISION FINISH
                    üìä CONTINUE MODE: Temperature {{ current_temp }}¬∞C fine-tuning to {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C remaining)
                    ‚è±Ô∏è ETA: ~{{ eta_minutes }}min {% if effectiveness >= 85 %}| ‚ùÑÔ∏è OPTIMAL EFFICIENCY{% elif effectiveness >= 65 %}| ‚öôÔ∏è GOOD CONTROL ({{ effectiveness }}%){% else %}| üîß ADJUSTING ({{ effectiveness }}% effective){% endif %}
                  {% elif temp_gap <= 1.5 %}
                    ‚ùÑÔ∏è {{ room_name | upper }} LOW COOLING - GENTLE APPROACH
                    üìä CONTINUE MODE: Gradually cooling {{ current_temp }}¬∞C ‚Üí {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C to go)
                    ‚è±Ô∏è ETA: ~{{ eta_minutes }}min | ‚ö° Escalation: {{ esc_display }} | Fan: {{ current_fan }}{% if escalation > 0 %} | üîº ESCALATING L{{ escalation }}{% elif deescalation > 0 %} | üîΩ DE-ESCALATING L{{ deescalation }}{% endif %}
                  {% else %}
                    ‚ùÑÔ∏è {{ room_name | upper }} LOW COOLING - PATIENT MODE
                    üìä CONTINUE MODE: Steady cooling {{ current_temp }}¬∞C ‚Üí {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C to cool)
                    üå°Ô∏è Gentle power until comfort | ‚ö° Escalation: {{ esc_display }} | Fan: {{ current_fan }} | Effectiveness: {{ effectiveness }}%
                  {% endif %}
                {% else %}
                  {% if temp_gap >= 3.0 %}
                    ‚ùÑÔ∏è {{ room_name | upper }} LOW COOLING - CAUTIOUS START
                    üöÄ START MODE: Moderate heat {{ current_temp }}¬∞C > {{ comfort_max_temp }}¬∞C ({{ distance_adjusted }}¬∞C excess)
                    üå°Ô∏è Gentle cooling approach | Target: {{ adjusted_target }}¬∞C | ETA: ~{{ eta_minutes }}min
                  {% elif temp_gap >= 1.0 %}
                    ‚ùÑÔ∏è {{ room_name | upper }} LOW COOLING - COMFORT ADJUSTMENT
                    üöÄ START MODE: Slight warmth {{ current_temp }}¬∞C > {{ comfort_max_temp }}¬∞C threshold
                    ‚öôÔ∏è Gentle cooling ‚Üí {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C to cool) | ‚ö° Escalation: {{ esc_display }} | Fan: {{ current_fan }}
                  {% else %}
                    ‚ùÑÔ∏è {{ room_name | upper }} LOW COOLING - MICRO-ADJUST
                    üöÄ START MODE: Fine-tuning {{ current_temp }}¬∞C > {{ comfort_max_temp }}¬∞C
                    üéØ Minimal cooling to {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C remaining) | ETA: ~{{ eta_minutes }}min
                  {% endif %}
                {% endif %}
                ‚Ä¢ Last Mode: {{ current_mode }}
              level: warning
          
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                    
                    # Smart cooling mode selection
                    # v3.10.0: Only use auto/heat_cool if heating is also enabled
                    selected_hvac_mode: >
                      {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                      {# For cooling, try cooling-capable modes #}
                      {% if 'cool' in modes %}
                        cool
                        {% elif 'Cool' in modes %}
                        Cool
                        {% elif enable_heating and 'auto' in modes %}
                        auto
                        {% elif enable_heating and 'Auto' in modes %}
                        Auto
                        {% elif enable_heating and 'heat_cool' in modes %}
                        heat_cool
                        {% elif enable_heating and 'Heat/Cool' in modes %}
                        Heat/Cool
                        {% else %}
                        off
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_hvac }}"
                  data:
                    value: "{{ selected_hvac_mode }}"
                  continue_on_error: true

                # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                - service: climate.set_hvac_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    hvac_mode: "{{ selected_hvac_mode }}"
                  continue_on_error: true

                - condition: template
                  value_template: "{{ debug_enabled }}"
                - service: system_log.write
                  data:
                    message: >
                      üîç SMART LOW COOL MODE: {{ repeat.item }}
                      ‚Ä¢ Available: {{ available_modes | join(', ') }}
                      ‚Ä¢ Selected: {{ selected_hvac_mode }}
                      ‚Ä¢ Actual: {{ states(current_entity) }}
                      ‚Ä¢ Reason: Low cooling mode for gentle temperature control
                    level: debug

          # Capture expected values for enhanced manual override detection (v3.3.0)
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ cooling_target_temp }}"
            continue_on_error: true

          # v4.6.14 FIX: Use low fan speed for gentle cooling
          # Set fan FIRST, then temperature (Daikin integration requirement)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"

                    # Smart low fan mode selection
                    selected_fan_mode: >
                      {% set fans = state_attr(repeat.item, 'fan_modes') | list %}

                      {# Try low speed equivalents in order of preference #}
                      {% if 'low' in fans %}
                        low
                        {% elif 'Low' in fans %}
                        Low
                        {% elif '1' in fans %}
                        1
                        {% elif 'Level 1' in fans %}
                        Level 1
                        {% elif 'quiet' in fans %}
                        quiet
                        {% elif 'Quiet' in fans %}
                        Quiet
                        {% elif 'eco' in fans %}
                        eco
                        {% elif 'Eco' in fans %}
                        Eco
                        {% elif 'auto' in fans %}
                        auto
                        {% elif 'Auto' in fans %}
                        Auto
                      {# Fallback to available options #}
                        {% elif '2' in fans %}
                        2
                        {% elif 'Level 2' in fans %}
                        Level 2
                        {% else %}
                        {{ fans[0] if fans else 'Auto' }}
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_fan }}"
                  data:
                    value: "{{ selected_fan_mode }}"
                  continue_on_error: true

                # v4.7.1 CRITICAL: 200ms delay for helper writes to commit
                - delay:
                    milliseconds: 200

                # v4.7.0 FIX: Use parallel calls to prevent coordinator blocking
                - parallel:
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ current_entity }}"
                      data:
                        temperature: "{{ cooling_target_temp }}"
                        hvac_mode: "cool"
                      continue_on_error: false

                    - sequence:
                        # Tiny delay to ensure temperature call starts first
                        - delay:
                            milliseconds: 10
                        # Then immediately call fan mode
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode | trim if selected_fan_mode is string else selected_fan_mode }}"
                          continue_on_error: false

                - condition: template
                  value_template: "{{ debug_enabled }}"
                - service: system_log.write
                  data:
                    message: >
                      üîç SMART LOW FAN: {{ repeat.item }}
                      ‚Ä¢ Available: {{ available_fans | join(', ') }}
                      ‚Ä¢ Selected: {{ selected_fan_mode }}
                      ‚Ä¢ Actual: {{ state_attr(current_entity, 'fan_mode') }}
                      ‚Ä¢ Reason: Low fan speed for gentle cooling
                    level: debug

          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "cooling"

          # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'cooling' or actual_ac_state == 'off') }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

      # Medium cooling - DEPRECATED (unified cooling mode)
      # This section is now handled by unified cooling logic
      # Kept for backwards compatibility but should not activate
      - conditions:
          - condition: template
            value_template: "{{ false }}"
          - condition: template
            value_template: >
              {% if last_mode == 'cooling' %}
                {# Same cooling mode - allow escalation, enforce runtime for de-escalation #}
                {{ final_escalation_level > 0 or time_in_current_mode > runtime_min }}
              {% elif (last_mode == 'off' or actual_ac_state == 'off') and enforce_offtime %}
                {# Starting from OFF - enforce off-time if enabled #}
                {# Check BOTH helper mode AND actual AC state to catch mode change scenarios #}
                {{ time_in_current_mode > offtime_min }}
              {% else %}
                {# Switching from heating/eco OR off-time protection disabled #}
                true
              {% endif %}
        sequence:
          - service: system_log.write
            data:
              message: >
                {% set current_mode = states(helper_mode) | default('off') %}
                {% set temp_gap = (current_temp - target_temp) | round(1) %}
                {% set eta_minutes = (temp_gap / temp_change_rate) | round(0) if temp_change_rate > 0 else 99 %}
                {% set effectiveness = current_effectiveness if dynamic_enabled else 75 %}
                {% set escalation = escalation_level if dynamic_enabled else 0 %}
                {% set deescalation = deescalation_level if dynamic_enabled else 0 %}
                {% set temp_gap_adjusted = temp_gap | abs | round(1) %}
                {% set distance_adjusted = temp_gap | abs | round(1) %}
                {% set esc_display = 'L' ~ escalation if escalation > 0 else 'None' %}
                {% set current_fan = state_attr(climate_list[0], 'fan_mode') | default('Auto') %}

                {% if current_mode == 'cooling' and current_temp > comfort_max_temp %}
                  {% if temp_gap <= 0.5 %}
                    üéØ {{ room_name | upper }} MEDIUM COOLING - FINAL APPROACH
                    üìä CONTINUE MODE: Temperature {{ current_temp }}¬∞C nearly at {{ adjusted_target }}¬∞C target ({{ temp_gap_adjusted }}¬∞C remaining)
                    ‚è±Ô∏è ETA: ~{{ eta_minutes }}min {% if effectiveness >= 85 %}| ‚ùÑÔ∏è OPTIMAL EFFICIENCY{% elif effectiveness >= 65 %}| ‚ö° GOOD EFFECTIVENESS ({{ effectiveness }}%){% else %}| üîß ADJUSTING ({{ effectiveness }}% effective){% endif %}
                  {% elif temp_gap <= 2.0 %}
                    ‚ùÑÔ∏è {{ room_name | upper }} MEDIUM COOLING - STEADY PROGRESS
                    üìä CONTINUE MODE: Cooling {{ current_temp }}¬∞C ‚Üí {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C to go)
                    ‚è±Ô∏è ETA: ~{{ eta_minutes }}min | ‚ö° Escalation: {{ esc_display }} | Fan: {{ current_fan }}{% if escalation > 0 %} | üîº ESCALATING L{{ escalation }}{% elif deescalation > 0 %} | üîΩ DE-ESCALATING L{{ deescalation }}{% endif %}
                  {% else %}
                    ‚ùÑÔ∏è {{ room_name | upper }} MEDIUM COOLING - SUSTAINED MODE
                    üìä CONTINUE MODE: Working gap {{ current_temp }}¬∞C ‚Üí {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C to cool)
                    ‚öôÔ∏è Balanced power until target | ‚ö° Escalation: {{ esc_display }} | Fan: {{ current_fan }} | Effectiveness: {{ effectiveness }}%
                  {% endif %}
                {% else %}
                  {% if temp_gap >= 4.0 %}
                    ‚ùÑÔ∏è {{ room_name | upper }} MEDIUM COOLING - INTENSIVE START
                    üöÄ START MODE: Significant heat {{ current_temp }}¬∞C > {{ comfort_max_temp }}¬∞C ({{ distance_adjusted }}¬∞C excess)
                    ‚ö° Steady cooling power engaged | Target: {{ adjusted_target }}¬∞C | ETA: ~{{ eta_minutes }}min
                  {% elif temp_gap >= 1.5 %}
                    ‚ùÑÔ∏è {{ room_name | upper }} MEDIUM COOLING - STANDARD COOL-DOWN
                    üöÄ START MODE: Moderate heat {{ current_temp }}¬∞C > {{ comfort_max_temp }}¬∞C threshold
                    ‚öôÔ∏è Balanced cooling ‚Üí {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C to cool) | ‚ö° Escalation: {{ esc_display }} | Fan: {{ current_fan }}
                  {% else %}
                    ‚ùÑÔ∏è {{ room_name | upper }} MEDIUM COOLING - GENTLE MODE
                    üöÄ START MODE: Minor adjustment {{ current_temp }}¬∞C > {{ comfort_max_temp }}¬∞C
                    üéØ Comfort cooling to {{ adjusted_target }}¬∞C ({{ temp_gap_adjusted }}¬∞C remaining) | ETA: ~{{ eta_minutes }}min
                  {% endif %}
                {% endif %}
                ‚Ä¢ Last Mode: {{ current_mode }}
              level: warning
          
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                    
                    # Smart cooling mode selection
                    # v3.10.0: Only use auto/heat_cool if heating is also enabled
                    selected_hvac_mode: >
                      {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                      {# For cooling, try cooling-capable modes #}
                      {% if 'cool' in modes %}
                        cool
                        {% elif 'Cool' in modes %}
                        Cool
                        {% elif enable_heating and 'auto' in modes %}
                        auto
                        {% elif enable_heating and 'Auto' in modes %}
                        Auto
                        {% elif enable_heating and 'heat_cool' in modes %}
                        heat_cool
                        {% elif enable_heating and 'Heat/Cool' in modes %}
                        Heat/Cool
                        {% else %}
                        off
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_hvac }}"
                  data:
                    value: "{{ selected_hvac_mode }}"
                  continue_on_error: true

                # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                - service: climate.set_hvac_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    hvac_mode: "{{ selected_hvac_mode }}"
                  continue_on_error: true

                - condition: template
                  value_template: "{{ debug_enabled }}"
                - service: system_log.write
                  data:
                    message: >
                      üîç SMART MEDIUM COOL MODE: {{ repeat.item }}
                      ‚Ä¢ Available: {{ available_modes | join(', ') }}
                      ‚Ä¢ Selected: {{ selected_hvac_mode }}
                      ‚Ä¢ Actual: {{ states(current_entity) }}
                      ‚Ä¢ Reason: Medium cooling mode for balanced temperature control
                    level: debug

          # Capture expected values for enhanced manual override detection (v3.3.0)
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ cooling_target_temp }}"
            continue_on_error: true

          # v4.6.14 FIX: Use medium fan speed for balanced cooling
          # Set fan FIRST, then temperature (Daikin integration requirement)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                    desired_medium_fan: "{{ fan_speed_medium }}"

                    # Smart medium fan mode selection
                    selected_fan_mode: >
                      {% set fans = state_attr(repeat.item, 'fan_modes') | list %}
                      {% set desired = fan_speed_medium %}

                      {# First try the exact user selection #}
                      {% if desired in fans %}
                        {{ desired }}
                      {# Then try medium speed equivalents in order of preference #}
                        {% elif 'medium' in fans %}
                        medium
                        {% elif 'Medium' in fans %}
                        Medium
                        {% elif '3' in fans %}
                        3
                        {% elif 'Level 3' in fans %}
                        Level 3
                        {% elif 'auto' in fans %}
                        auto
                        {% elif 'Auto' in fans %}
                        Auto
                      {# Fallback to available options #}
                        {% elif '2' in fans %}
                        2
                        {% elif 'Level 2' in fans %}
                        Level 2
                        {% elif 'low' in fans %}
                        low
                        {% elif 'high' in fans %}
                        high
                        {% else %}
                        {{ fans[0] if fans else 'Auto' }}
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_fan }}"
                  data:
                    value: "{{ selected_fan_mode }}"
                  continue_on_error: true

                # v4.7.1 CRITICAL: 200ms delay for helper writes to commit
                - delay:
                    milliseconds: 200

                # v4.7.0 FIX: Use parallel calls to prevent coordinator blocking
                - parallel:
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ current_entity }}"
                      data:
                        temperature: "{{ cooling_target_temp }}"
                        hvac_mode: "cool"
                      continue_on_error: false

                    - sequence:
                        # Tiny delay to ensure temperature call starts first
                        - delay:
                            milliseconds: 10
                        # Then immediately call fan mode
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode | trim if selected_fan_mode is string else selected_fan_mode }}"
                          continue_on_error: false

                - condition: template
                  value_template: "{{ debug_enabled }}"
                - service: system_log.write
                  data:
                    message: >
                      üîç SMART MEDIUM FAN: {{ repeat.item }}
                      ‚Ä¢ Desired: {{ desired_medium_fan }}
                      ‚Ä¢ Available: {{ available_fans | join(', ') }}
                      ‚Ä¢ Selected: {{ selected_fan_mode }}
                      ‚Ä¢ Actual: {{ state_attr(current_entity, 'fan_mode') }}
                      ‚Ä¢ Reason: {{ 'Exact match' if desired_medium_fan in available_fans else 'Best equivalent for medium cooling' }}
                    level: debug

          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "cooling"

          # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'cooling' or actual_ac_state == 'off') }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

      # =====================================
      # BED COMFORT MODE - Ultra-quiet operation when in bed (v3.12.0)
      # v3.12.9 FIX: Moved BEFORE Comfort Zone to take precedence when in bed
      # =====================================
      # Triggered when bed sensor detects occupancy and temperature comfortable
      # SAFE: Only activates after overshoot target reached, never interrupts active cooling/heating
      - conditions:
          # Feature must be enabled (not set to 'off')
          - condition: template
            value_template: "{{ bed_comfort_mode != 'off' }}"

          # Bed sensor must be configured and active
          - condition: template
            value_template: "{{ bed_sensor_manual and is_state(bed_sensor_manual, 'on') }}"

          # Temperature MUST be within comfort zone (no emergency heating/cooling needed)
          - condition: template
            value_template: "{{ current_temp >= comfort_min_temp and current_temp <= comfort_max_temp }}"

          # AC must currently be ON (don't turn on AC just for bed comfort)
          - condition: template
            value_template: "{{ actual_ac_state != 'off' }}"

          # Respect minimum runtime (anti-short-cycling)
          - condition: template
            value_template: "{{ time_since_change >= runtime_min }}"

          # NOT in manual/override mode
          - condition: template
            value_template: "{{ control_mode not in ['Manual', 'Override'] }}"

          # Smart mode presence requirement (if Smart mode active)
          - condition: or
            conditions:
              - condition: template
                value_template: "{{ control_mode != 'Smart' }}"
              - condition: template
                value_template: "{{ smart_presence_active }}"

          # CRITICAL SAFETY: Check overshoot target reached if in continue mode
          # This prevents bed comfort from interrupting active cooling/heating to target
          # v4.0.4 FIX: Also exclude fan_only modes to prevent overriding power-saving fan-only
          # v4.6.8 FIX: ALLOW bed comfort to override stability_fan_only when user enters bed
          - condition: template
            value_template: >
              {% set in_continue_mode = (last_mode == 'cooling' or last_mode == 'heating') %}
              {% set in_bed_fan_only = last_mode == 'bed_eco_fan_only' %}
              {% set in_comfort_fan_only = last_mode == 'comfort_fan_only' %}
              {% set in_overshoot_fan_only = last_mode == 'stability_fan_only' %}

              {% if in_bed_fan_only %}
                false  {# Don't interrupt bed ECO fan-only mode #}
              {% elif in_comfort_fan_only %}
                false  {# Don't interrupt comfort zone fan-only #}
              {% elif in_overshoot_fan_only %}
                true   {# v4.6.8: ALLOW bed comfort to override overshoot fan-only when user enters bed #}
              {% elif not in_continue_mode %}
                true
              {% elif last_mode == 'cooling' %}
                {{ current_temp <= (target_temp - target_overshoot) }}
              {% elif last_mode == 'heating' %}
                {{ current_temp >= (target_temp + target_overshoot) }}
              {% else %}
                true
              {% endif %}

        sequence:
          # Debug logging
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                üõèÔ∏è {{ room_name | upper }} BED COMFORT MODE ACTIVATED

                Sleep Optimization:
                    ‚Ä¢ Bed Comfort Mode: {{ bed_comfort_mode | upper }}
                    ‚Ä¢ Bed Sensor: {{ bed_sensor_manual }} = ON
                    ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                    ‚Ä¢ Comfort Zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C
                    ‚Ä¢ Last Mode: {{ last_mode }}
                    ‚Ä¢ Overshoot Target: {{ target_temp - target_overshoot if last_mode == 'cooling' else target_temp + target_overshoot }}¬∞C

                Action: {{ 'Ultra-quiet fan only' if bed_comfort_mode == 'quiet' else 'Full ECO mode' }}
              level: warning

          # v3.12.1 FIX: Update timestamp BEFORE changing AC settings
          # This prevents false manual override detection when bed comfort activates
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_change }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          # Choose action based on mode
          - choose:
              # QUIET mode - Ultra-quiet fan only (no temp/HVAC change)
              - conditions:
                  - condition: template
                    value_template: "{{ bed_comfort_mode == 'quiet' }}"
                sequence:
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            quietest_fan: >
                              {% set fans = state_attr(repeat.item, 'fan_modes') | list %}
                              {% if 'silence' in fans %}
                                silence
                              {% elif 'Silence' in fans %}
                                Silence
                              {% elif 'quiet' in fans %}
                                quiet
                              {% elif 'Quiet' in fans %}
                                Quiet
                              {% elif '1' in fans %}
                                1
                              {% elif 'Level 1' in fans %}
                                Level 1
                              {% elif 'low' in fans %}
                                low
                              {% elif 'Low' in fans %}
                                Low
                              {% else %}
                                {{ fans[0] if fans else 'Auto' }}
                              {% endif %}

                        # v4.6.5: Batched service call - no verification retry needed
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ repeat.item }}"
                          data:
                            fan_mode: "{{ quietest_fan }}"
                          continue_on_error: true

                        # v3.16.14 FIX: Wrapped debug in if/then to not block helper updates
                        - if:
                            - condition: template
                              value_template: "{{ debug_enabled }}"
                          then:
                            - service: system_log.write
                              data:
                                message: "üõèÔ∏è {{ room_name | upper }}: Set {{ repeat.item }} fan to {{ quietest_fan }} (actual: {{ state_attr(repeat.item, 'fan_mode') }})"
                                level: debug

                        # v4.3.0: Update expected fan helper to prevent false manual override detection
                        - if:
                            - condition: template
                              value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
                          then:
                            - service: input_text.set_value
                              target:
                                entity_id: "{{ helper_expected_fan }}"
                              data:
                                value: "{{ quietest_fan }}"
                              continue_on_error: true

              # ECO mode - Actively maintain temperature using external sensor
              # v3.12.0: Continuously monitor and adjust to keep temp at target
              - conditions:
                  - condition: template
                    value_template: "{{ bed_comfort_mode == 'eco' }}"
                sequence:
                  # v4.7.1 FIX: Update helper_change timestamp to prevent false manual override detection
                  - condition: template
                    value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input helper_last_change
                    data:
                      datetime: "{{ now() }}"
                    continue_on_error: true

                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: "{{ adjusted_target }}"
                    continue_on_error: true

                  # v5.0.3: MANDATORY BRP084 Pattern - Set temp+hvac+fan in rapid succession
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            # Smart stability mode selection
                            # Only use auto/heat_cool if both heating and cooling enabled
                            selected_hvac_mode: >
                              {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                              {# For stability, prefer auto/heat_cool only if both enabled #}
                              {% if enable_cooling and enable_heating and 'auto' in modes %}
                                auto
                              {% elif enable_cooling and enable_heating and 'Auto' in modes %}
                                Auto
                              {% elif enable_cooling and enable_heating and 'heat_cool' in modes %}
                                heat_cool
                              {% elif enable_cooling and enable_heating and 'Heat/Cool' in modes %}
                                Heat/Cool
                              {% elif enable_cooling and 'cool' in modes %}
                                cool
                              {% elif enable_cooling and 'Cool' in modes %}
                                Cool
                              {% elif enable_heating and 'heat' in modes %}
                                heat
                              {% elif enable_heating and 'Heat' in modes %}
                                Heat
                              {% else %}
                                off
                              {% endif %}

                        # Capture expected HVAC for manual override detection
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_hvac }}"
                          data:
                            value: "{{ selected_hvac_mode }}"
                          continue_on_error: true

                        # v5.0.3: FIRST - Temperature + HVAC mode together (turns AC ON atomically)
                        - service: climate.set_temperature
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            temperature: "{{ adjusted_target }}"
                            hvac_mode: "{{ selected_hvac_mode }}"
                          continue_on_error: false

                        # v5.0.3: SECOND - Calculate fan mode based on escalation
                        - variables:
                            available_fans: "{{ state_attr(current_entity, 'fan_modes') | list }}"
                            # v4.3.4: Store current HA-reported fan mode BEFORE making changes
                            current_ha_fan_mode: "{{ state_attr(current_entity, 'fan_mode') }}"
                            # Escalation-based fan selection (eco=Level 0, escalate up to Level 4)
                            expected_fan_mode: >
                              {% set fans = available_fans %}
                              {% if final_escalation_level == 0 %}
                                {# Level 0: Eco fan speed (quietest) #}
                                {% set desired_eco = fan_speed_eco %}
                                {% if desired_eco in fans %}
                                  {{ desired_eco }}
                                {% elif 'quiet' in fans %}
                                  quiet
                                {% elif 'Quiet' in fans %}
                                  Quiet
                                {% elif 'silence' in fans %}
                                  silence
                                {% elif 'Silence' in fans %}
                                  Silence
                                {% elif '1' in fans %}
                                  1
                                {% elif 'Level 1' in fans %}
                                  Level 1
                                {% elif 'low' in fans %}
                                  low
                                {% elif 'Low' in fans %}
                                  Low
                                {% elif 'auto' in fans %}
                                  auto
                                {% elif 'Auto' in fans %}
                                  Auto
                                {% else %}
                                  {{ fans[0] if fans else 'Auto' }}
                                {% endif %}
                              {% elif final_escalation_level == 1 %}
                                {# Level 1: Small escalation - Fan 2 #}
                                {% if '2' in fans %}
                                  2
                                {% elif 'Level 2' in fans %}
                                  Level 2
                                {% elif 'low' in fans %}
                                  low
                                {% elif 'Low' in fans %}
                                  Low
                                {% elif '3' in fans %}
                                  3
                                {% elif 'Level 3' in fans %}
                                  Level 3
                                {% elif 'auto' in fans %}
                                  auto
                                {% elif 'Auto' in fans %}
                                  Auto
                                {% else %}
                                  {{ fans[1] if fans|length > 1 else fans[0] }}
                                {% endif %}
                              {% elif final_escalation_level == 2 %}
                                {# Level 2: Moderate escalation - Fan 3 #}
                                {% if '3' in fans %}
                                  3
                                {% elif 'Level 3' in fans %}
                                  Level 3
                                {% elif 'medium' in fans %}
                                  medium
                                {% elif 'Medium' in fans %}
                                  Medium
                                {% elif '4' in fans %}
                                  4
                                {% elif 'Level 4' in fans %}
                                  Level 4
                                {% elif 'auto' in fans %}
                                  auto
                                {% elif 'Auto' in fans %}
                                  Auto
                                {% else %}
                                  {{ fans[2] if fans|length > 2 else (fans[1] if fans|length > 1 else fans[0]) }}
                                {% endif %}
                              {% elif final_escalation_level == 3 %}
                                {# Level 3: Strong escalation - Fan 4 #}
                                {% if '4' in fans %}
                                  4
                                {% elif 'Level 4' in fans %}
                                  Level 4
                                {% elif '5' in fans %}
                                  5
                                {% elif 'Level 5' in fans %}
                                  Level 5
                                {% elif 'high' in fans %}
                                  high
                                {% elif 'High' in fans %}
                                  High
                                {% elif 'auto' in fans %}
                                  auto
                                {% elif 'Auto' in fans %}
                                  Auto
                                {% else %}
                                  {{ fans[-2] if fans|length > 1 else fans[-1] }}
                                {% endif %}
                              {% else %}
                                {# Level 4: Emergency maximum - Fan 5 #}
                                {% set desired_max = fan_speed_max %}
                                {% if desired_max in fans %}
                                  {{ desired_max }}
                                {% elif '5' in fans %}
                                  5
                                {% elif 'Level 5' in fans %}
                                  Level 5
                                {% elif '4' in fans %}
                                  4
                                {% elif 'Level 4' in fans %}
                                  Level 4
                                {% elif 'high' in fans %}
                                  high
                                {% elif 'High' in fans %}
                                  High
                                {% elif 'auto' in fans %}
                                  auto
                                {% elif 'Auto' in fans %}
                                  Auto
                                {% else %}
                                  {{ fans[-1] if fans else 'Auto' }}
                                {% endif %}
                              {% endif %}

                        # Capture expected fan for manual override detection
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_fan }}"
                          data:
                            value: "{{ expected_fan_mode }}"
                          continue_on_error: true

                        # v5.0.3: SECOND - Fan mode IMMEDIATELY (allows pydaikin batching on BRP069)
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ expected_fan_mode }}"
                          continue_on_error: false

                        # v5.0.3: THIRD - Swing mode IMMEDIATELY (optional, can fail safely)
                        - if:
                            - condition: template
                              value_template: "{{ selected_swing_mode not in ['none', '', 'unavailable', 'unknown'] }}"
                          then:
                            - variables:
                                available_swings: "{{ state_attr(current_entity, 'swing_modes') | list }}"
                                desired_swing: !input swing_mode_active
                                selected_swing_mode: >
                                  {% if desired_swing in available_swings %}
                                    {{ desired_swing }}
                                    {% elif desired_swing == 'both' and '3D' in available_swings %}
                                    3D
                                    {% elif desired_swing == 'both' and 'Both' in available_swings %}
                                    Both
                                    {% elif desired_swing == 'vertical' and 'Vertical' in available_swings %}
                                    Vertical
                                    {% elif desired_swing == 'Vertical' and 'vertical' in available_swings %}
                                    vertical
                                    {% elif desired_swing == 'horizontal' and 'Horizontal' in available_swings %}
                                    Horizontal
                                    {% elif desired_swing == 'Horizontal' and 'horizontal' in available_swings %}
                                    horizontal
                                    {% elif 'both' in available_swings %}
                                    both
                                    {% elif 'Both' in available_swings %}
                                    Both
                                    {% elif '3D' in available_swings %}
                                    3D
                                    {% elif 'Vertical' in available_swings %}
                                    Vertical
                                    {% elif 'vertical' in available_swings %}
                                    vertical
                                    {% else %}
                                    {{ available_swings[0] if available_swings else 'Off' }}
                                  {% endif %}

                            - service: climate.set_swing_mode
                              target:
                                entity_id: "{{ current_entity }}"
                              data:
                                swing_mode: "{{ selected_swing_mode | trim }}"
                              continue_on_error: true

                  # Debug logging AFTER service calls
                  - condition: template
                    value_template: "{{ debug_enabled }}"
                  - service: system_log.write
                    data:
                      message: >
                        üõèÔ∏è {{ room_name | upper }} BED COMFORT ECO: Maintaining Target Temperature

                        Temperature:
                            ‚Ä¢ Set AC to: {{ adjusted_target | round(1) }}¬∞C
                            ‚Ä¢ Current: {{ current_temp | round(1) }}¬∞C ‚Üí Target: {{ target_temp | round(1) }}¬∞C

                        Escalation (v3.13.16):
                            ‚Ä¢ Level: {{ final_escalation_level }} (0=Eco, 1-4=Escalated)
                            ‚Ä¢ Fan: {{ state_attr(climate_list[0], 'fan_mode') if climate_list else 'unknown' }}
                            ‚Ä¢ Uses same effectiveness tracking as continue mode

                        Reason: Bed occupied - continuous temperature maintenance in ECO mode with dynamic fan escalation
                      level: warning

          # Update helper to track bed comfort mode
          - condition: template
            value_template: "{{ helper_mode not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_mode }}"
            data:
              value: "bed_comfort_{{ bed_comfort_mode }}"

      # =====================================
      # BED ECO FAN-ONLY MODE (v4.3.0)
      # Power-saving mode when temperature stable at target
      # =====================================
      - conditions:
          - condition: template
            value_template: "{{ bed_eco_should_fan_only }}"

          # Bed still occupied (or in grace period)
          - condition: template
            value_template: >
              {% set sensor_active = bed_sensor_manual and is_state(bed_sensor_manual, 'on') %}
              {% set in_grace = (bed_absence_grace > 0 and minutes_since_bed_off < bed_absence_grace) %}
              {{ sensor_active or in_grace }}

          # AC supports fan_only
          - condition: template
            value_template: >
              {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
              {{ 'fan_only' in modes or 'fan-only' in modes or 'Fan Only' in modes or 'dry' in modes }}

          # Runtime protection
          - condition: template
            value_template: "{{ time_since_change >= runtime_min }}"

        sequence:
          # Debug logging
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üõèÔ∏èüí® {{ room_name | upper }} BED ECO ‚Üí FAN-ONLY MODE

                    Stability Detection:
                        ‚Ä¢ Temp: {{ current_temp }}¬∞C (target: {{ target_temp }}¬∞C)
                        ‚Ä¢ Change rate: {{ temp_change_rate | round(3) }}¬∞C/min (max: {{ bed_eco_stability_rate }})
                        ‚Ä¢ Stable for: {{ time_in_current_mode | round(1) }} min (required: {{ bed_eco_stability_minutes }})

                    Thresholds:
                        ‚Ä¢ Return if temp > {{ (target_temp + bed_eco_return_threshold) | round(1) }}¬∞C
                        ‚Ä¢ Max undershoot: {{ bed_eco_max_overshoot }}¬∞C

                    Power Savings: ~85% reduction (compressor OFF)
                  level: warning
                  logger: "blueprints.climate_control.{{ room_name | lower | replace(' ', '_') }}"

          # STEP 1: Update helper_change BEFORE AC changes
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_change }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          # STEP 2: Update expected_hvac BEFORE changing mode
          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "fan_only"
                continue_on_error: true

          # STEP 2B: Update expected_temp (fan-only doesn't change setpoint but prevents false override)
          - if:
              - condition: template
                value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_number.set_value
                target:
                  entity_id: "{{ helper_expected_temp }}"
                data:
                  value: "{{ target_temp }}"
                continue_on_error: true

          # STEP 3: Update helper_mode BEFORE AC changes
          - condition: template
            value_template: "{{ helper_mode not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_mode }}"
            data:
              value: "bed_eco_fan_only"

          # STEP 4: Variables for fan-only mode
          - variables:
              selected_fan_only_hvac: >
                {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                {% if 'fan_only' in modes %}
                  fan_only
                {% elif 'fan-only' in modes %}
                  fan-only
                {% elif 'Fan Only' in modes %}
                  Fan Only
                {% elif 'dry' in modes %}
                  dry
                {% else %}
                  off
                {% endif %}

              selected_fan_only_fan: >
                {% set fans = state_attr(climate_list[0], 'fan_modes') | list %}
                {% if 'silence' in fans %}
                  silence
                {% elif 'Silence' in fans %}
                  Silence
                {% elif 'quiet' in fans %}
                  quiet
                {% elif 'Quiet' in fans %}
                  Quiet
                {% elif '1' in fans %}
                  1
                {% elif 'Level 1' in fans %}
                  Level 1
                {% elif 'low' in fans %}
                  low
                {% elif 'Low' in fans %}
                  Low
                {% else %}
                  {{ fans[0] if fans else 'Auto' }}
                {% endif %}

          # v4.7.1 FIX: Update expected_fan helper BEFORE climate service calls
          - if:
              - condition: template
                value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_fan }}"
                data:
                  value: "{{ selected_fan_only_fan }}"
                continue_on_error: true

          # v4.7.1 CRITICAL: 200ms delay for helper writes to commit before climate service calls
          - delay:
              milliseconds: 200

          # v4.7.0 FIX: Use parallel calls to prevent coordinator blocking
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - parallel:
                    # v4.7.1 FIX: Use climate.set_temperature (not set_hvac_mode) to actually send command to AC
                    # set_hvac_mode only updates UI optimistically without sending proper command to Daikin units
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ repeat.item }}"
                      data:
                        temperature: "{{ target_temp }}"
                        hvac_mode: "{{ selected_fan_only_hvac }}"
                      continue_on_error: false

                    - sequence:
                        # Tiny delay to ensure temperature call starts first
                        - delay:
                            milliseconds: 10
                        # Then immediately call fan mode
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ repeat.item }}"
                          data:
                            fan_mode: "{{ selected_fan_only_fan }}"
                          continue_on_error: false

      # =====================================
      # BED ECO FAN-ONLY ‚Üí RETURN TO COOLING (v4.3.0)
      # When temperature rises above threshold
      # =====================================
      - conditions:
          - condition: template
            value_template: "{{ bed_eco_should_return }}"

          # Bed still occupied (or in grace period)
          - condition: template
            value_template: >
              {% set sensor_active = bed_sensor_manual and is_state(bed_sensor_manual, 'on') %}
              {% set in_grace = (bed_absence_grace > 0 and minutes_since_bed_off < bed_absence_grace) %}
              {{ sensor_active or in_grace }}

          # Runtime protection
          - condition: template
            value_template: "{{ time_since_change >= runtime_min }}"

        sequence:
          # Debug logging
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üõèÔ∏è‚ùÑÔ∏è {{ room_name | upper }} BED ECO FAN-ONLY ‚Üí RETURN TO COOLING

                    Temperature Rise:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C
                        ‚Ä¢ Target: {{ target_temp }}¬∞C
                        ‚Ä¢ Threshold: {{ (target_temp + bed_eco_return_threshold) | round(1) }}¬∞C
                        ‚Ä¢ Rose: {{ (current_temp - target_temp) | round(1) }}¬∞C above target

                    Action: Returning to bed_comfort_eco for active cooling
                  level: warning
                  logger: "blueprints.climate_control.{{ room_name | lower | replace(' ', '_') }}"

          # Update helper_change
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_change }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          # Set mode back to bed_comfort_eco - the bed ECO block will handle the rest
          - condition: template
            value_template: "{{ helper_mode not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_mode }}"
            data:
              value: "bed_comfort_eco"

      # Comfort zone - Eco mode or OFF mode (Power Saving)
      # When temperature is within acceptable range (e.g., 21-25¬∞C with ¬±2¬∞C tolerance)
      # OFF mode saves 40-60% more energy vs eco mode but allows temperature drift
      # v3.19.2 FIX: Don't activate comfort zone actions until overshoot target is reached (if enabled)
      - conditions:
          - condition: template
            value_template: "{{ should_activate }}"
          - condition: template
            value_template: >
              {% set in_comfort_zone = current_temp >= comfort_min_temp and current_temp <= comfort_max_temp %}
              {% set overshoot_reached = true %}
              {% if target_overshoot > 0 and last_mode == 'cooling' %}
                {% set overshoot_reached = current_temp <= (target_temp - target_overshoot) %}
              {% elif target_overshoot > 0 and last_mode == 'heating' %}
                {% set overshoot_reached = current_temp >= (target_temp + target_overshoot) %}
              {% endif %}
              {{ in_comfort_zone and overshoot_reached }}
          - condition: template
            value_template: "{{ time_since_change > runtime_min }}"

          # v4.6.9: Don't activate comfort zone actions if user is in bed - bed comfort takes priority
          - condition: template
            value_template: >
              {{
                not (bed_comfort_mode != 'off' and
                     bed_sensor_manual and
                     is_state(bed_sensor_manual, 'on'))
              }}
        sequence:
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                üîç {{ room_name | upper }} CLIMATE DEBUG: Comfort Zone Action Triggered
                
                üéõÔ∏è Control Status:
                    ‚Ä¢ Control Mode: {{ control_mode }}
                    ‚Ä¢ Should Activate: {{ should_activate }}
                    ‚Ä¢ Extreme Temp Detected: {{ extreme_temp_detected }}
                    ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                    ‚Ä¢ Extreme High: {{ extreme_high }}¬∞C
                    ‚Ä¢ Extreme Low: {{ extreme_low }}¬∞C
                    ‚Ä¢ Room Presence: {{ room_presence_detected }}
                    ‚Ä¢ Approaching Home: {{ approaching_home }}
              level: warning
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ comfort_zone_action == 'eco' }}"
                sequence:
                  # Eco mode - maintain with reduced fan and wider setpoint (uses ~150-250W)

                  # v4.7.1 DEBUG: Prove ECO block is executing
                  - if:
                      - condition: template
                        value_template: "{{ debug_enabled }}"
                    then:
                      - service: system_log.write
                        data:
                          message: >
                            üö® {{ room_name | upper }} ECO MODE BLOCK ACTIVATED

                            üìä Debug Info:
                                ‚Ä¢ comfort_zone_action: {{ comfort_zone_action }}
                                ‚Ä¢ Should be 'eco' to match: {{ comfort_zone_action == 'eco' }}
                                ‚Ä¢ last_mode: {{ last_mode }}
                                ‚Ä¢ This block should NOT execute if comfort_zone_action != 'eco'!
                          level: warning

                  # v4.7.1 FIX: Calculate expected values BEFORE updating helpers
                  - variables:
                      entity_for_calculation: "{{ climate_list[0] }}"
                      available_modes_calc: "{{ state_attr(climate_list[0], 'hvac_modes') | list }}"
                      available_fans_calc: "{{ state_attr(climate_list[0], 'fan_modes') | list }}"
                      expected_hvac_mode_calc: >
                        {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                        {% if enable_cooling and enable_heating and 'auto' in modes %}
                          auto
                        {% elif enable_cooling and enable_heating and 'Auto' in modes %}
                          Auto
                        {% elif enable_cooling and enable_heating and 'heat_cool' in modes %}
                          heat_cool
                        {% elif enable_cooling and enable_heating and 'Heat/Cool' in modes %}
                          Heat/Cool
                        {% elif enable_cooling and 'cool' in modes %}
                          cool
                        {% elif enable_cooling and 'Cool' in modes %}
                          Cool
                        {% elif enable_heating and 'heat' in modes %}
                          heat
                        {% elif enable_heating and 'Heat' in modes %}
                          Heat
                        {% else %}
                          off
                        {% endif %}
                      expected_fan_mode_calc: >
                        {% set fans = state_attr(climate_list[0], 'fan_modes') | list %}
                        {% set desired = fan_speed_eco %}
                        {% if desired in fans %}
                          {{ desired }}
                        {% elif 'Auto' in fans %}
                          Auto
                        {% elif 'auto' in fans %}
                          auto
                        {% elif 'Quiet' in fans %}
                          Quiet
                        {% elif 'quiet' in fans %}
                          quiet
                        {% elif 'Silence' in fans %}
                          Silence
                        {% elif 'silence' in fans %}
                          silence
                        {% elif 'Level 1' in fans %}
                          Level 1
                        {% elif '1' in fans %}
                          1
                        {% elif 'low' in fans %}
                          low
                        {% elif 'Low' in fans %}
                          Low
                        {% else %}
                          {{ fans[0] if fans else 'Auto' }}
                        {% endif %}

                  # v4.7.1 FIX: Update ALL helpers BEFORE any climate service calls
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_hvac }}"
                        data:
                          value: "{{ expected_hvac_mode_calc }}"
                        continue_on_error: true

                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_temp not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_number.set_value
                        target:
                          entity_id: "{{ helper_expected_temp }}"
                        data:
                          value: "{{ adjusted_target }}"
                        continue_on_error: true

                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_fan }}"
                        data:
                          value: "{{ expected_fan_mode_calc }}"
                        continue_on_error: true

                  # v4.7.1 CRITICAL: 200ms delay for helper writes to commit before climate service calls
                  - delay:
                      milliseconds: 200

                  # Set HVAC mode to auto for maximum efficiency in comfort zone
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            # Smart stability mode selection
                            # v3.10.0: Only use auto/heat_cool if both heating and cooling enabled
                            expected_hvac_mode: >
                              {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                              {# For stability, prefer auto/heat_cool only if both enabled #}
                              {% if enable_cooling and enable_heating and 'auto' in modes %}
                                auto
                              {% elif enable_cooling and enable_heating and 'Auto' in modes %}
                                Auto
                              {% elif enable_cooling and enable_heating and 'heat_cool' in modes %}
                                heat_cool
                              {% elif enable_cooling and enable_heating and 'Heat/Cool' in modes %}
                                Heat/Cool
                              {% elif enable_cooling and 'cool' in modes %}
                                cool
                              {% elif enable_cooling and 'Cool' in modes %}
                                Cool
                              {% elif enable_heating and 'heat' in modes %}
                                heat
                              {% elif enable_heating and 'Heat' in modes %}
                                Heat
                              {% else %}
                                off
                              {% endif %}

                  - service: system_log.write
                    data:
                      message: >
                        üå°Ô∏è {{ room_name | upper }} TEMP SET: Comfort Zone Maintenance (ECO Mode)
                        Set AC to: {{ target_temp | round(0) }}¬∞C (rounded for AC compatibility)
                        Actual value: {{ target_temp | round(1) }}¬∞C
                        Reason: Maintaining target temperature within comfort zone
                        Current: {{ current_temp | round(1) }}¬∞C ‚Üí Target: {{ target_temp | round(1) }}¬∞C
                      level: warning

                  # v5.0.3: MANDATORY BRP084 Pattern - Set temp+hvac in ONE call, then fan, then swing
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                            # Smart stability mode selection
                            # v3.10.0: Only use auto/heat_cool if both heating and cooling enabled
                            selected_hvac_mode: >
                              {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                              {# For stability, prefer auto/heat_cool only if both enabled #}
                              {% if enable_cooling and enable_heating and 'auto' in modes %}
                                auto
                              {% elif enable_cooling and enable_heating and 'Auto' in modes %}
                                Auto
                              {% elif enable_cooling and enable_heating and 'heat_cool' in modes %}
                                heat_cool
                              {% elif enable_cooling and enable_heating and 'Heat/Cool' in modes %}
                                Heat/Cool
                              {% elif enable_cooling and 'cool' in modes %}
                                cool
                              {% elif enable_cooling and 'Cool' in modes %}
                                Cool
                              {% elif enable_heating and 'heat' in modes %}
                                heat
                              {% elif enable_heating and 'Heat' in modes %}
                                Heat
                              {% else %}
                                off
                              {% endif %}
                            desired_eco_fan: "{{ fan_speed_eco }}"
                            selected_fan_mode: >
                              {% if desired_eco_fan in available_fans %}
                                {{ desired_eco_fan }}
                                {% elif 'Auto' in available_fans %}
                                Auto
                                {% elif 'auto' in available_fans %}
                                auto
                                {% elif 'Quiet' in available_fans %}
                                Quiet
                                {% elif 'quiet' in available_fans %}
                                quiet
                                {% elif 'Silence' in available_fans %}
                                Silence
                                {% elif 'silence' in available_fans %}
                                silence
                                {% elif 'Level 1' in available_fans %}
                                Level 1
                                {% elif '1' in available_fans %}
                                1
                                {% elif 'low' in available_fans %}
                                low
                                {% elif 'Low' in available_fans %}
                                Low
                                {% else %}
                                {{ available_fans[0] if available_fans else 'Auto' }}
                              {% endif %}

                        # v5.0.3: MANDATORY BRP084 pattern - rapid batched calls (NO DELAYS)
                        # FIRST: Temperature + HVAC mode together (turns AC ON atomically)
                        - service: climate.set_temperature
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            temperature: "{{ adjusted_target }}"
                            hvac_mode: "{{ selected_hvac_mode }}"
                          continue_on_error: false

                        # SECOND: Fan mode IMMEDIATELY (allows pydaikin batching on BRP069)
                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode }}"
                          continue_on_error: false

                        # THIRD: Swing mode IMMEDIATELY (optional, can fail safely)
                        # Call swing within same repeat loop to maintain rapid batched pattern
                        - if:
                            - condition: template
                              value_template: "{{ selected_swing_mode not in ['none', '', 'unavailable', 'unknown'] }}"
                          then:
                            - variables:
                                available_swings: "{{ state_attr(current_entity, 'swing_modes') | list }}"
                                desired_swing: !input swing_mode_active
                                selected_swing_mode: >
                                  {% if desired_swing in available_swings %}
                                    {{ desired_swing }}
                                    {% elif desired_swing == 'both' and '3D' in available_swings %}
                                    3D
                                    {% elif desired_swing == 'both' and 'Both' in available_swings %}
                                    Both
                                    {% elif desired_swing == 'vertical' and 'Vertical' in available_swings %}
                                    Vertical
                                    {% elif desired_swing == 'Vertical' and 'vertical' in available_swings %}
                                    vertical
                                    {% elif desired_swing == 'horizontal' and 'Horizontal' in available_swings %}
                                    Horizontal
                                    {% elif desired_swing == 'Horizontal' and 'horizontal' in available_swings %}
                                    horizontal
                                    {% elif 'both' in available_swings %}
                                    both
                                    {% elif 'Both' in available_swings %}
                                    Both
                                    {% elif '3D' in available_swings %}
                                    3D
                                    {% elif 'Vertical' in available_swings %}
                                    Vertical
                                    {% elif 'vertical' in available_swings %}
                                    vertical
                                    {% else %}
                                    {{ available_swings[0] if available_swings else 'Off' }}
                                  {% endif %}

                            - service: climate.set_swing_mode
                              target:
                                entity_id: "{{ current_entity }}"
                              data:
                                swing_mode: "{{ selected_swing_mode | trim }}"
                              continue_on_error: true
                  
                  - service: input_text.set_value
                    target:
                      entity_id: !input helper_last_mode
                    data:
                      value: "eco"

                  # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
                  - condition: template
                    value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'eco' or actual_ac_state == 'off') }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ helper_mode_time }}"
                    data:
                      datetime: "{{ now() }}"
                  
                  - condition: template
                    value_template: "{{ enable_notifications }}"
                  
                  - service: !input notification_service
                    data:
                      title: "{{ room_name }} Climate Control"
                      message: "Eco mode - Comfort zone ({{ current_temp }}¬∞C)"
                    continue_on_error: true

              # v4.7.2 DEBUG: Log comfort_zone_action value
              - conditions:
                  - condition: template
                    value_template: "{{ debug_enabled }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: >
                        üîç {{ room_name | upper }} COMFORT ZONE BLOCK EVALUATION

                        üìä Settings:
                            ‚Ä¢ comfort_zone_action: "{{ comfort_zone_action }}"
                            ‚Ä¢ last_mode: "{{ last_mode }}"
                            ‚Ä¢ actual_ac_state: "{{ actual_ac_state }}"
                            ‚Ä¢ current_temp: {{ current_temp }}¬∞C
                            ‚Ä¢ comfort_zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C

                        üéØ Which block will match?
                            ‚Ä¢ comfort_zone_action == 'off': {{ comfort_zone_action == 'off' }}
                            ‚Ä¢ comfort_zone_action == 'eco': {{ comfort_zone_action == 'eco' }}
                            ‚Ä¢ comfort_zone_action == 'fan_only' AND last_mode in active modes: {{ comfort_zone_action == 'fan_only' and last_mode in ['cooling', 'heating', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] }}
                            ‚Ä¢ comfort_zone_action == 'fan_only' AND last_mode NOT in active modes: {{ comfort_zone_action == 'fan_only' and last_mode not in ['cooling', 'heating', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] }}
                      level: warning

              # v3.19.0: Debug logging when fan-only is blocked due to no prior cooling/heating
              - conditions:
                  - condition: template
                    value_template: "{{ comfort_zone_action == 'fan_only' }}"
                  - condition: template
                    value_template: >
                      {{ last_mode not in ['cooling', 'heating', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] }}
                sequence:
                  # v4.7.2: Check if AC is already in fan mode - if so, sync helper instead of turning off
                  - choose:
                      # AC is already in a fan-like mode - sync the helper
                      - conditions:
                          - condition: template
                            value_template: "{{ states(climate_list[0]) in ['fan_only', 'dry'] or actual_ac_state == 'on' }}"
                        sequence:
                          - if:
                              - condition: template
                                value_template: "{{ debug_enabled }}"
                            then:
                              - service: system_log.write
                                data:
                                  message: >
                                    üîÑ {{ room_name | upper }} STATE SYNC: AC already in fan-like mode

                                    üìä Current State:
                                        ‚Ä¢ AC HVAC Mode: {{ states(climate_list[0]) }}
                                        ‚Ä¢ AC Power State: {{ actual_ac_state }}
                                        ‚Ä¢ last_mode helper: {{ last_mode }}
                                        ‚Ä¢ comfort_zone_action: {{ comfort_zone_action }}

                                    üîß Action:
                                        ‚Ä¢ Syncing helper_last_mode to 'comfort_fan_only'
                                        ‚Ä¢ AC will remain ON in current mode
                                  level: warning

                          - service: input_text.set_value
                            target:
                              entity_id: !input helper_last_mode
                            data:
                              value: "comfort_fan_only"

                          - service: input_datetime.set_datetime
                            target:
                              entity_id: !input helper_last_change
                            data:
                              datetime: "{{ now() }}"
                            continue_on_error: true

                    # AC is OFF or in a different mode - turn it off
                    default:
                      - if:
                          - condition: template
                            value_template: "{{ debug_enabled }}"
                        then:
                          - service: system_log.write
                            data:
                              message: >
                                üö´ {{ room_name | upper }} COMFORT FAN-ONLY BLOCKED

                                üìä Reason: No prior cooling/heating mode detected
                                    ‚Ä¢ Current temp: {{ current_temp }}¬∞C (in comfort zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C)
                                    ‚Ä¢ last_mode: {{ last_mode }}
                                    ‚Ä¢ AC state: {{ actual_ac_state }}
                                    ‚Ä¢ Expected: AC must have been actively cooling/heating before fan-only can activate

                                üí° Fan-only mode only activates AFTER cooling/heating brings temperature to comfort zone.
                                   Currently falling back to OFF mode since AC was not previously running in active mode.
                              level: warning

                      # Fallback to OFF mode when fan-only blocked
                      - service: input_datetime.set_datetime
                        target:
                          entity_id: !input helper_last_change
                        data:
                          datetime: "{{ now() }}"
                        continue_on_error: true

                      - service: input_text.set_value
                        target:
                          entity_id: !input helper_last_mode
                        data:
                          value: "off"

                      # v3.19.25 FIX: Add delay to prevent false override detection (same as line 12419)
                      - delay:
                          milliseconds: 200

                      # v4.7.0: Turn off AC - fail loudly if error
                      - service: climate.turn_off
                        target:
                          entity_id: !input climate_entities
                        continue_on_error: false

                      # v5.0.6 FIX: Update snapshot after turn_off
                      - if:
                          - condition: template
                            value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] }}"
                        then:
                          - variables:
                              update_snapshot: "hvac=off,temp=0,fan=unknown,swing=unknown"
                              update_checksum: "0"
                          - service: input_text.set_value
                            target:
                              entity_id: "{{ helper_last_command }}"
                            data:
                              value: "{{ update_snapshot }}"
                            continue_on_error: true
                          - service: input_number.set_value
                            target:
                              entity_id: "{{ helper_state_checksum }}"
                            data:
                              value: "{{ update_checksum }}"
                            continue_on_error: true
                          - if:
                              - condition: template
                                value_template: "{{ debug_enabled }}"
                            then:
                              - service: system_log.write
                                data:
                                  message: >
                                    üì∏ {{ room_name | upper }} SNAPSHOT UPDATED (Turn OFF)
                                        ‚Ä¢ New Snapshot: {{ update_snapshot }}
                                  level: warning

              - conditions:
                  - condition: template
                    value_template: "{{ comfort_zone_action == 'fan_only' }}"
                  - condition: template
                    value_template: >
                      {{ last_mode in ['cooling', 'heating', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] }}
                sequence:
                  # v3.18.0: Fan-only mode when comfort zone reached

                  # Update helper_change BEFORE switching to fan_only to prevent false Override detection
                  - condition: template
                    value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input helper_last_change
                    data:
                      datetime: "{{ now() }}"
                    continue_on_error: true

                  # Update expected_hvac BEFORE changing mode to prevent race condition
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_hvac }}"
                        data:
                          value: "fan_only"
                        continue_on_error: true

                  # Update helper_last_mode BEFORE switching to prevent false override
                  - service: input_text.set_value
                    target:
                      entity_id: !input helper_last_mode
                    data:
                      value: "comfort_fan_only"

                  # v4.7.1 CRITICAL: 200ms delay for helper writes to commit before climate service calls
                  - delay:
                      milliseconds: 200

                  # Check if AC supports fan_only mode
                  - variables:
                      entity_for_check: "{{ climate_list[0] }}"
                      available_modes: "{{ state_attr(entity_for_check, 'hvac_modes') | list }}"
                      selected_fan_only_hvac: >
                        {% set modes = state_attr(entity_for_check, 'hvac_modes') | list %}
                        {% if 'fan_only' in modes %}
                          fan_only
                        {% elif 'fan-only' in modes %}
                          fan-only
                        {% elif 'Fan Only' in modes %}
                          Fan Only
                        {% elif 'dry' in modes %}
                          dry
                        {% else %}
                          off
                        {% endif %}
                      supports_fan_only: "{{ selected_fan_only_hvac in ['fan_only', 'fan-only', 'Fan Only', 'dry'] }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_enabled }}"
                    then:
                      - service: system_log.write
                        data:
                          message: >
                            üå¨Ô∏è {{ room_name | upper }} COMFORT ZONE ‚Üí FAN-ONLY MODE

                            üìä Temperature Status:
                                ‚Ä¢ Current: {{ current_temp | round(1) }}¬∞C
                                ‚Ä¢ Comfort zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C
                                ‚Ä¢ In comfort zone: True

                            ‚ö° Fan-Only Activation:
                                ‚Ä¢ Switching from: {{ last_mode | upper }}
                                ‚Ä¢ Target HVAC mode: {{ selected_fan_only_hvac }}
                                ‚Ä¢ User selected fan speed: {{ fan_only_fan_speed_setting }}
                                ‚Ä¢ Mapped to AC fan mode: {{ selected_fan_only_fan_mode }}
                                ‚Ä¢ AC supports fan_only: {{ supports_fan_only }}

                            üí∞ Expected Savings:
                                ‚Ä¢ Power reduction: ~85% (compressor OFF, fan only)
                                ‚Ä¢ Will return to cooling/heating if temp exits comfort zone

                            üõ°Ô∏è Manual Override Protection:
                                ‚Ä¢ helper_change updated: {{ now() }}
                                ‚Ä¢ helper_expected_hvac: fan_only
                                ‚Ä¢ Safe from false manual override detection
                          level: warning

                  # Switch to fan_only mode (if supported)
                  - if:
                      - condition: template
                        value_template: "{{ supports_fan_only }}"
                    then:
                      # v4.7.2 DEBUG: Log EXACT values being passed to climate service
                      - if:
                          - condition: template
                            value_template: "{{ debug_enabled }}"
                        then:
                          - service: system_log.write
                            data:
                              message: >
                                üö® {{ room_name | upper }} ABOUT TO CALL climate.set_temperature

                                üìä EXACT Values Being Passed:
                                    ‚Ä¢ entity_id: {{ climate_list[0] }}
                                    ‚Ä¢ temperature: {{ target_temp }}
                                    ‚Ä¢ hvac_mode: "{{ selected_fan_only_hvac }}"
                                    ‚Ä¢ Type of hvac_mode: {{ selected_fan_only_hvac.__class__.__name__ }}
                                    ‚Ä¢ Length: {{ selected_fan_only_hvac | length }}
                                    ‚Ä¢ Raw value: {{ selected_fan_only_hvac | tojson }}

                                üîç Variable Calculation:
                                    ‚Ä¢ available_modes from AC: {{ state_attr(climate_list[0], 'hvac_modes') | list }}
                                    ‚Ä¢ 'fan_only' in modes: {{ 'fan_only' in state_attr(climate_list[0], 'hvac_modes') | list }}
                                    ‚Ä¢ selected_fan_only_hvac result: {{ selected_fan_only_hvac }}
                              level: warning

                      # v5.0.3: MANDATORY BRP084 Pattern - rapid batched calls (NO DELAYS)
                      - repeat:
                          for_each: "{{ climate_list }}"
                          sequence:
                            # FIRST: Temperature + HVAC mode together (turns AC ON with fan_only mode)
                            # For fan_only, we still set a temperature to ensure AC responds correctly
                            - service: climate.set_temperature
                              target:
                                entity_id: "{{ repeat.item }}"
                              data:
                                temperature: "{{ target_temp }}"
                                hvac_mode: "{{ selected_fan_only_hvac }}"
                              continue_on_error: false

                            # SECOND: Fan mode IMMEDIATELY (allows pydaikin batching on BRP069)
                            - service: climate.set_fan_mode
                              target:
                                entity_id: "{{ repeat.item }}"
                              data:
                                fan_mode: "{{ selected_fan_only_fan_mode }}"
                              continue_on_error: false

                      # Update expected fan helper
                      - if:
                          - condition: template
                            value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
                        then:
                          - service: input_text.set_value
                            target:
                              entity_id: "{{ helper_expected_fan }}"
                            data:
                              value: "{{ selected_fan_only_fan_mode }}"
                            continue_on_error: true

                      # Wait briefly for AC to respond
                      - delay:
                          seconds: 2

                      # Post-activation debug with actual AC state
                      - if:
                          - condition: template
                            value_template: "{{ debug_enabled }}"
                        then:
                          - service: system_log.write
                            data:
                              message: >
                                ‚úÖ {{ room_name | upper }} FAN-ONLY MODE ACTIVATED - STATE VERIFICATION

                                üìä AC State After Commands:
                                    ‚Ä¢ HVAC Mode: {{ states(climate_list[0]) }}
                                    ‚Ä¢ Fan Mode: {{ state_attr(climate_list[0], 'fan_mode') }}
                                    ‚Ä¢ Temperature: {{ state_attr(climate_list[0], 'current_temperature') }}¬∞C

                                üéØ What Was Sent:
                                    ‚Ä¢ User Selection: {{ fan_only_fan_speed_setting }}
                                    ‚Ä¢ Mapped Fan Mode: {{ selected_fan_only_fan_mode }}
                                    ‚Ä¢ HVAC Mode: {{ selected_fan_only_hvac }}

                                ‚úÖ Verification:
                                    ‚Ä¢ Expected HVAC: {{ selected_fan_only_hvac }}
                                    ‚Ä¢ Actual HVAC: {{ states(climate_list[0]) }}
                                    ‚Ä¢ Match: {{ states(climate_list[0]) == selected_fan_only_hvac }}
                                    ‚Ä¢ Expected Fan: {{ selected_fan_only_fan_mode }}
                                    ‚Ä¢ Actual Fan: {{ state_attr(climate_list[0], 'fan_mode') }}
                                    ‚Ä¢ Match: {{ state_attr(climate_list[0], 'fan_mode') == selected_fan_only_fan_mode }}
                              level: warning

                    else:
                      # v4.6.5: Fallback - AC doesn't support fan_only, turn off instead
                      - delay:
                          milliseconds: 200

                      - service: climate.turn_off
                        target:
                          entity_id: !input climate_entities
                        continue_on_error: true

                      - if:
                          - condition: template
                            value_template: "{{ debug_enabled }}"
                        then:
                          - service: system_log.write
                            data:
                              message: >
                                ‚ö†Ô∏è {{ room_name | upper }} FAN-ONLY MODE NOT SUPPORTED

                                AC doesn't support fan_only mode. Available modes: {{ available_modes | join(', ') }}

                                Falling back to turning AC OFF instead.

                                Recommendation: Change "Action When Comfort Zone Reached" to "OFF" or "ECO" in automation settings.
                              level: warning

            default:
              # OFF mode - Maximum power savings (0W consumption)
              # A/C turns completely off when temperature is acceptable
              # Will restart when temp exits comfort zone (e.g., <21¬∞C or >25¬∞C)

              # v3.11.13 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
              - condition: template
                value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
              - service: input_datetime.set_datetime
                target:
                  entity_id: !input helper_last_change
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

              # v3.13.15 FIX: Update expected_hvac BEFORE turn_off to prevent race condition
              - if:
                  - condition: template
                    value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                then:
                  - service: input_text.set_value
                    target:
                      entity_id: "{{ helper_expected_hvac }}"
                    data:
                      value: "off"
                    continue_on_error: true

              - service: input_text.set_value
                target:
                  entity_id: !input helper_last_mode
                data:
                  value: "off"

              # v4.6.5: Small delay for helper propagation, then turn off - no verification retry needed
              - delay:
                  milliseconds: 200

              - service: climate.turn_off
                target:
                  entity_id: !input climate_entities
                continue_on_error: true

              # Update mode start time for off-time protection tracking (always update when going to OFF)
              - if:
                  - condition: template
                    value_template: "{{ helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' }}"
                then:
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "{{ helper_mode_time }}"
                    data:
                      datetime: "{{ now() }}"
              
              - condition: template
                value_template: "{{ enable_notifications }}"
              
              - service: !input notification_service
                data:
                  title: "{{ room_name }} Climate Control"
                  message: "Turned off - Comfort zone ({{ current_temp }}¬∞C)"
                continue_on_error: true

      # =====================================
      # FAN-ONLY CONTINUE MODE (v3.18.0)
      # =====================================
      # Maintain fan-only mode when already active, return to cooling/heating when exits comfort zone

      - conditions:
          - condition: template
            value_template: "{{ last_mode in ['stability_fan_only', 'comfort_fan_only'] }}"
          - condition: template
            value_template: "{{ control_mode in ['Smart', 'Auto'] }}"
          - condition: template
            value_template: "{{ control_mode != 'Smart' or smart_presence_active }}"
          # v3.19.22 FIX: CRITICAL - Only run fan-only block when temp WITHIN comfort zone
          # This prevents infinite loop when temp exits comfort zone
          # When temp exits, this block won't match, allowing cooling/heating blocks to activate
          - condition: template
            value_template: "{{ current_temp >= comfort_min_temp and current_temp <= comfort_max_temp }}"
        sequence:
          # v3.18.7: MAINTAIN MODE - Enforce fan speed on every check (before exit check)
          - choose:
              # MAINTAIN: Still in comfort zone, enforce fan speed
              - conditions:
                  - condition: template
                    value_template: "{{ current_temp >= comfort_min_temp and current_temp <= comfort_max_temp }}"
                sequence:
                  # v4.7.1: Calculate correct fan_only HVAC mode for this AC
                  - variables:
                      selected_fan_only_hvac: >
                        {% set modes = state_attr(climate_list[0], 'hvac_modes') | list %}
                        {% if 'fan_only' in modes %}
                          fan_only
                        {% elif 'fan-only' in modes %}
                          fan-only
                        {% elif 'Fan Only' in modes %}
                          Fan Only
                        {% elif 'dry' in modes %}
                          dry
                        {% else %}
                          off
                        {% endif %}

                  # Continuously enforce fan speed setting
                  - if:
                      - condition: template
                        value_template: "{{ debug_enabled }}"
                    then:
                      - service: system_log.write
                        data:
                          message: >
                            üå¨Ô∏è {{ room_name | upper }} FAN-ONLY MAINTAIN MODE

                            üìä Status:
                                ‚Ä¢ Current Mode: {{ last_mode | upper }}
                                ‚Ä¢ Temperature: {{ current_temp | round(1) }}¬∞C (comfort: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C)
                                ‚Ä¢ Current HVAC: {{ states(climate_list[0]) }}
                                ‚Ä¢ Current Fan: {{ state_attr(climate_list[0], 'fan_mode') }}
                                ‚Ä¢ Expected Fan: {{ selected_fan_only_fan_mode }}
                                ‚Ä¢ Match: {{ state_attr(climate_list[0], 'fan_mode') == selected_fan_only_fan_mode }}

                            üîß Action (v3.18.11):
                                ‚Ä¢ Enforcing HVAC mode: fan_only
                                ‚Ä¢ Enforcing fan speed: {{ selected_fan_only_fan_mode }}
                          level: warning

                  # v4.6.5: ONLY enforce if settings don't match
                  # Skip unnecessary service calls to prevent state refresh issues
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            current_hvac: "{{ states(repeat.item) }}"
                            current_fan: "{{ state_attr(repeat.item, 'fan_mode') }}"
                            needs_update: "{{ current_hvac != selected_fan_only_hvac or current_fan != selected_fan_only_fan_mode }}"

                        # Only send commands if something doesn't match
                        - if:
                            - condition: template
                              value_template: "{{ needs_update }}"
                          then:
                            # v4.7.2 DEBUG: Log what values are being passed
                            - if:
                                - condition: template
                                  value_template: "{{ debug_enabled }}"
                              then:
                                - service: system_log.write
                                  data:
                                    message: >
                                      üö® {{ room_name | upper }} MAINTENANCE BLOCK - MISMATCH DETECTED

                                      üìä Current State vs Expected:
                                          ‚Ä¢ Entity: {{ current_entity }}
                                          ‚Ä¢ current_hvac (from HA): "{{ current_hvac }}"
                                          ‚Ä¢ selected_fan_only_hvac (target): "{{ selected_fan_only_hvac }}"
                                          ‚Ä¢ HVAC Match: {{ current_hvac == selected_fan_only_hvac }}
                                          ‚Ä¢ current_fan: "{{ current_fan }}"
                                          ‚Ä¢ selected_fan_only_fan_mode: "{{ selected_fan_only_fan_mode }}"
                                          ‚Ä¢ Fan Match: {{ current_fan == selected_fan_only_fan_mode }}

                                      üîß About to Send:
                                          ‚Ä¢ Will send hvac_mode: "{{ selected_fan_only_hvac }}"
                                          ‚Ä¢ Type: {{ selected_fan_only_hvac.__class__.__name__ }}
                                          ‚Ä¢ Raw: {{ selected_fan_only_hvac | tojson }}
                                    level: warning

                            # v4.7.1 FIX: Use climate.set_temperature (not set_hvac_mode) for fan_only mode
                            # set_hvac_mode only updates UI optimistically without sending proper command to Daikin units
                            # Set HVAC mode if wrong
                            - if:
                                - condition: template
                                  value_template: "{{ current_hvac != selected_fan_only_hvac }}"
                              then:
                                - service: climate.set_temperature
                                  target:
                                    entity_id: "{{ current_entity }}"
                                  data:
                                    temperature: "{{ target_temp }}"
                                    hvac_mode: "{{ selected_fan_only_hvac }}"
                                  continue_on_error: true
                                - delay:
                                    milliseconds: 200

                            # Set fan mode if wrong
                            - if:
                                - condition: template
                                  value_template: "{{ current_fan != selected_fan_only_fan_mode }}"
                              then:
                                - service: climate.set_fan_mode
                                  target:
                                    entity_id: "{{ current_entity }}"
                                  data:
                                    fan_mode: "{{ selected_fan_only_fan_mode }}"
                                  continue_on_error: true

                  # Update expected fan helper
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_fan }}"
                        data:
                          value: "{{ selected_fan_only_fan_mode }}"
                        continue_on_error: true

              # v3.19.22: REMOVED EXIT sub-block - no longer needed
              # The parent condition now requires temp WITHIN comfort zone (line 12663)
              # When temp exits comfort zone, this entire fan-only block won't match
              # This allows cooling/heating activation blocks to run naturally without manual override false positives
              #
              # HISTORY:
              # v3.18.12 removed last_mode reset from EXIT block to prevent manual override false positives
              # But EXIT block only logged message - never actually transitioned to cooling/heating
              # Result: Infinite loop of logging "FAN-ONLY ‚Üí RETURN TO COOLING/HEATING" with no action
              # v3.19.22 fixes this by preventing fan-only block from matching when temp exits comfort zone

      # Temperature Stability Auto-Off (Auto/Smart Mode - temperature equilibrium reached AND in comfort zone)
      - conditions:
          - condition: template
            value_template: "{{ temp_stability_enabled }}"
          - condition: template
            value_template: "{{ control_mode in ['Smart', 'Auto'] }}"
          - condition: template
            value_template: "{{ temp_stability_detected }}"
          - condition: template
            value_template: "{{ last_mode not in ['off', 'stability_off', 'stability_eco', 'stability_fan_only', 'comfort_fan_only', 'unavailable', 'unknown', none] }}"
          - condition: template
            value_template: "{{ time_since_change >= runtime_min }}"
          # v3.9.21 FIX: Only turn off when WITHIN comfort zone, not outside it with buffer
          # v3.9.26 FIX: Don't turn off if actively pursuing overshoot target in continue mode
          - condition: template
            value_template: >
              {% set in_comfort_zone = current_temp >= comfort_min_temp and current_temp <= comfort_max_temp %}
              {% set in_continue_mode = (last_mode == 'cooling' or last_mode == 'heating') %}
              {% set overshoot_target_reached = false %}

              {% if in_continue_mode %}
                {% if last_mode == 'cooling' %}
                  {# Cooling: target reached when temp <= (target - overshoot) #}
                  {% set overshoot_target_reached = current_temp <= (target_temp - target_overshoot) %}
                {% elif last_mode == 'heating' %}
                  {# Heating: target reached when temp >= (target + overshoot) #}
                  {% set overshoot_target_reached = current_temp >= (target_temp + target_overshoot) %}
                {% endif %}
              {% endif %}

              {# Allow stability auto-off ONLY if: in comfort zone AND (not in continue mode OR overshoot target already reached) #}
              {{ in_comfort_zone and (not in_continue_mode or overshoot_target_reached) }}
        sequence:
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üéØ Smart Feature: Temperature Stable & Comfortable
                    üå°Ô∏è Temperature steady at {{ current_temp | round(1) }}¬∞C for {{ time_in_current_mode | round(0) }} minutes
                    ‚úÖ Within comfort zone ({{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C) - switching to {{ stability_behavior|upper }} mode to save energy

                    üìã Technical: ¬±{{ stability_tolerance }}¬∞C tolerance, {{ stability_duration }}min requirement, {{ time_since_change | round(1) }}min since last change
                  level: warning

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ stability_behavior == 'off' }}"
                sequence:
                  # v3.11.13 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
                  - condition: template
                    value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input helper_last_change
                    data:
                      datetime: "{{ now() }}"
                    continue_on_error: true

                  # v3.13.15 FIX: Update expected_hvac BEFORE turn_off to prevent race condition
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_hvac }}"
                        data:
                          value: "off"
                        continue_on_error: true

                  # v4.6.5: Small delay for helper propagation, then turn off - no verification retry needed
                  - delay:
                      milliseconds: 200

                  - service: climate.turn_off
                    target:
                      entity_id: !input climate_entities
                    continue_on_error: true

                  # v4.2.1: Update mode helper AFTER turn_off completes to prevent false override detection
                  # Problem: stability_off is in is_manual_on check - if helper set BEFORE turn_off,
                  # another trigger during turn_off sees stability_off+on ‚Üí false positive!
                  - service: input_text.set_value
                    target:
                      entity_id: !input helper_last_mode
                    data:
                      value: "stability_off"

                  - service: system_log.write
                    data:
                      message: >
                        üå°Ô∏è {{ room_name | upper }} TEMP SET: Temperature Stability Auto-Off
                        Set AC to: OFF
                        Actual value: OFF
                        Reason: Temperature equilibrium reached - AC job complete
                        Stable at: {{ current_temp | round(1) }}¬∞C for {{ time_in_current_mode | round(0) }} minutes
                      level: warning

              - conditions:
                  - condition: template
                    value_template: "{{ stability_behavior == 'eco' }}"
                sequence:
                  # v3.13.17 FIX: Update helper_last_mode BEFORE changing AC to prevent false override
                  - service: input_text.set_value
                    target:
                      entity_id: !input helper_last_mode
                    data:
                      value: "stability_eco"

                  # Set HVAC mode with compatibility check for eco mode
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            expected_hvac_mode: >
                              {% if current_temp > comfort_max_temp %}
                                {% if 'cool' in available_modes %}
                                  cool
                                  {% elif 'auto' in available_modes %}
                                  auto
                                  {% elif 'heat_cool' in available_modes %}
                                  heat_cool
                                  {% else %}
                                  {{ available_modes[0] if available_modes else 'off' }}
                                {% endif %}
                                {% elif current_temp < comfort_min_temp %}
                                {% if 'heat' in available_modes %}
                                  heat
                                  {% elif 'auto' in available_modes %}
                                  auto
                                  {% elif 'heat_cool' in available_modes %}
                                  heat_cool
                                  {% else %}
                                  {{ available_modes[0] if available_modes else 'off' }}
                                {% endif %}
                                {% else %}
                                {% if 'auto' in available_modes %}
                                  auto
                                  {% elif 'heat_cool' in available_modes %}
                                  heat_cool
                                  {% else %}
                                  {{ available_modes[0] if available_modes else 'off' }}
                                {% endif %}
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_hvac }}"
                          data:
                            value: "{{ expected_hvac_mode }}"
                          continue_on_error: true

                        # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            hvac_mode: "{{ expected_hvac_mode }}"

                  - variables:
                      expected_temp: >
                        {% if current_temp > comfort_max_temp %}
                          {{ comfort_max_temp + 1 }}
                          {% elif current_temp < comfort_min_temp %}
                          {{ comfort_min_temp - 1 }}
                          {% else %}
                          {{ target_temp }}
                        {% endif %}

                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: "{{ expected_temp }}"
                    continue_on_error: true

                  # v4.6.5: Batched service call - no verification retry needed
                  - service: climate.set_temperature
                    target:
                      entity_id: !input climate_entities
                    data:
                      temperature: "{{ expected_temp }}"
                    continue_on_error: true

                  - service: system_log.write
                    data:
                      message: >
                        üå°Ô∏è {{ room_name | upper }} TEMP SET: Temperature Stability Eco Mode
                        Set AC to: {{ ((comfort_max_temp + 1) if current_temp > comfort_max_temp else (comfort_min_temp - 1) if current_temp < comfort_min_temp else target_temp) | round(0) }}¬∞C (rounded for AC compatibility)
                        Actual value: {{ ((comfort_max_temp + 1) if current_temp > comfort_max_temp else (comfort_min_temp - 1) if current_temp < comfort_min_temp else target_temp) | round(1) }}¬∞C
                        Reason: Temperature stability eco mode (gentle maintenance after equilibrium)
                        Current: {{ current_temp | round(1) }}¬∞C ‚Üí Stable for {{ time_in_current_mode | round(0) }} minutes
                      level: warning

                  # Set eco fan mode for efficient stability eco mode
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                            desired_eco_fan: "{{ fan_speed_eco }}"
                            expected_fan_mode: >
                              {% if desired_eco_fan in available_fans %}
                                {{ desired_eco_fan }}
                                {% elif 'Auto' in available_fans %}
                                Auto
                                {% elif 'auto' in available_fans %}
                                auto
                                {% elif 'Quiet' in available_fans %}
                                Quiet
                                {% elif 'quiet' in available_fans %}
                                quiet
                                {% elif 'Silence' in available_fans %}
                                Silence
                                {% elif 'silence' in available_fans %}
                                silence
                                {% elif 'Level 1' in available_fans %}
                                Level 1
                                {% elif '1' in available_fans %}
                                1
                                {% elif 'low' in available_fans %}
                                low
                                {% elif 'Low' in available_fans %}
                                Low
                                {% else %}
                                {{ available_fans[0] if available_fans else 'Auto' }}
                              {% endif %}

              - conditions:
                  - condition: template
                    value_template: "{{ stability_behavior == 'fan_only' }}"
                sequence:
                  # v3.18.0: Fan-only mode when temperature stable

                  # Update helper_change BEFORE switching to fan_only to prevent false Override detection
                  - condition: template
                    value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input helper_last_change
                    data:
                      datetime: "{{ now() }}"
                    continue_on_error: true

                  # Update expected_hvac BEFORE changing mode to prevent race condition
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_hvac }}"
                        data:
                          value: "fan_only"
                        continue_on_error: true

                  # Update helper_last_mode BEFORE switching to prevent false override
                  - service: input_text.set_value
                    target:
                      entity_id: !input helper_last_mode
                    data:
                      value: "stability_fan_only"

                  # Check if AC supports fan_only mode
                  - variables:
                      entity_for_check: "{{ climate_list[0] }}"
                      available_modes: "{{ state_attr(entity_for_check, 'hvac_modes') | list }}"
                      selected_fan_only_hvac: >
                        {% set modes = state_attr(entity_for_check, 'hvac_modes') | list %}
                        {% if 'fan_only' in modes %}
                          fan_only
                        {% elif 'fan-only' in modes %}
                          fan-only
                        {% elif 'Fan Only' in modes %}
                          Fan Only
                        {% elif 'dry' in modes %}
                          dry
                        {% else %}
                          off
                        {% endif %}
                      supports_fan_only: "{{ selected_fan_only_hvac in ['fan_only', 'fan-only', 'Fan Only', 'dry'] }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_enabled }}"
                    then:
                      - service: system_log.write
                        data:
                          message: >
                            üå¨Ô∏è {{ room_name | upper }} STABILITY ‚Üí FAN-ONLY MODE

                            üìä Temperature Status:
                                ‚Ä¢ Current: {{ current_temp | round(1) }}¬∞C
                                ‚Ä¢ Stable for: {{ time_in_current_mode | round(0) }} minutes
                                ‚Ä¢ Within comfort zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C

                            ‚ö° Fan-Only Activation:
                                ‚Ä¢ Switching from: {{ last_mode | upper }}
                                ‚Ä¢ Target HVAC mode: {{ selected_fan_only_hvac }}
                                ‚Ä¢ Target fan speed: {{ selected_fan_only_fan_mode }}
                                ‚Ä¢ AC supports fan_only: {{ supports_fan_only }}

                            üí∞ Expected Savings:
                                ‚Ä¢ Power reduction: ~85% (compressor OFF, fan only)
                                ‚Ä¢ Will return to cooling/heating if temp exits comfort zone

                            üõ°Ô∏è Manual Override Protection:
                                ‚Ä¢ helper_change updated: {{ now() }}
                                ‚Ä¢ helper_expected_hvac: fan_only
                                ‚Ä¢ Safe from false manual override detection
                          level: warning

                  # Switch to fan_only mode (if supported)
                  - if:
                      - condition: template
                        value_template: "{{ supports_fan_only }}"
                    then:
                      # v4.7.2 DEBUG: Log EXACT values being passed to climate service
                      - if:
                          - condition: template
                            value_template: "{{ debug_enabled }}"
                        then:
                          - service: system_log.write
                            data:
                              message: >
                                üö® {{ room_name | upper }} ABOUT TO CALL climate.set_temperature

                                üìä EXACT Values Being Passed:
                                    ‚Ä¢ entity_id: {{ climate_list[0] }}
                                    ‚Ä¢ temperature: {{ target_temp }}
                                    ‚Ä¢ hvac_mode: "{{ selected_fan_only_hvac }}"
                                    ‚Ä¢ Type of hvac_mode: {{ selected_fan_only_hvac.__class__.__name__ }}
                                    ‚Ä¢ Length: {{ selected_fan_only_hvac | length }}
                                    ‚Ä¢ Raw value: {{ selected_fan_only_hvac | tojson }}

                                üîç Variable Calculation:
                                    ‚Ä¢ available_modes from AC: {{ state_attr(climate_list[0], 'hvac_modes') | list }}
                                    ‚Ä¢ 'fan_only' in modes: {{ 'fan_only' in state_attr(climate_list[0], 'hvac_modes') | list }}
                                    ‚Ä¢ selected_fan_only_hvac result: {{ selected_fan_only_hvac }}
                              level: warning

                      # v5.0.3: MANDATORY BRP084 Pattern - rapid batched calls (NO DELAYS)
                      - repeat:
                          for_each: "{{ climate_list }}"
                          sequence:
                            # FIRST: Temperature + HVAC mode together (turns AC ON with fan_only mode)
                            # For fan_only, we still set a temperature to ensure AC responds correctly
                            - service: climate.set_temperature
                              target:
                                entity_id: "{{ repeat.item }}"
                              data:
                                temperature: "{{ target_temp }}"
                                hvac_mode: "{{ selected_fan_only_hvac }}"
                              continue_on_error: false

                            # SECOND: Fan mode IMMEDIATELY (allows pydaikin batching on BRP069)
                            - service: climate.set_fan_mode
                              target:
                                entity_id: "{{ repeat.item }}"
                              data:
                                fan_mode: "{{ selected_fan_only_fan_mode }}"
                              continue_on_error: false

                      # Update expected fan helper
                      - if:
                          - condition: template
                            value_template: "{{ helper_expected_fan not in [none, '', 'unavailable', 'unknown'] }}"
                        then:
                          - service: input_text.set_value
                            target:
                              entity_id: "{{ helper_expected_fan }}"
                            data:
                              value: "{{ selected_fan_only_fan_mode }}"
                            continue_on_error: true

                      - service: system_log.write
                        data:
                          message: >
                            üå°Ô∏è {{ room_name | upper }} TEMP SET: Temperature Stability Fan-Only Mode
                            Set AC to: FAN_ONLY
                            Fan speed: {{ selected_fan_only_fan_mode }}
                            Reason: Temperature equilibrium reached - switching to fan-only for power savings
                            Stable at: {{ current_temp | round(1) }}¬∞C for {{ time_in_current_mode | round(0) }} minutes
                          level: warning

                    else:
                      # v4.6.5: Fallback - AC doesn't support fan_only, turn off instead
                      - delay:
                          milliseconds: 200

                      - service: climate.turn_off
                        target:
                          entity_id: !input climate_entities
                        continue_on_error: true

                      - if:
                          - condition: template
                            value_template: "{{ debug_enabled }}"
                        then:
                          - service: system_log.write
                            data:
                              message: >
                                ‚ö†Ô∏è {{ room_name | upper }} FAN-ONLY MODE NOT SUPPORTED

                                AC doesn't support fan_only mode. Available modes: {{ available_modes | join(', ') }}

                                Falling back to turning AC OFF instead.

                                Recommendation: Change "Stability Auto-Off Action" to "OFF" or "ECO" in automation settings.
                              level: warning

          # v3.13.17: Removed duplicate helper_last_mode update (now done in each branch BEFORE AC changes)

          # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and last_mode != 'stability_' + stability_behavior }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          - condition: template
            value_template: "{{ notification_service is defined and notification_service not in [none, ''] }}"
          - service: "{{ notification_service }}"
            data:
              title: "{{ room_name }} Climate Control"
              message: "Temperature Stability: {{ stability_behavior }} (stable {{ time_in_current_mode | round(0) }}min, {{ current_temp }}¬∞C)"


      # Manual Mode - Immediately clear automation states when detected
      - conditions:
          - condition: template
            value_template: "{{ control_mode == 'Manual' }}"
          - condition: template
            value_template: "{{ last_mode in ['stability_off', 'stability_eco', 'stability_fan_only', 'smart_off', 'smart_eco', 'smart_maintain', 'eco', 'cooling', 'heating'] }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üéÆ Manual Mode: IMMEDIATE Control Restored
                    üîÑ Clearing "{{ last_mode }}" state instantly
                    üí° You now have full manual control - no automation interference

                    üìã Technical: Manual mode = instant automation disable
                  level: warning

          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "manual"

          # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'manual' or actual_ac_state == 'off') }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true
          
          # CRITICAL: Update helper_change to start 3-hour override protection
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown', []] and helper_change is string and helper_change != '' }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_change }}"
            data:
              datetime: "{{ now() }}"
              
          # v3.13.15 FIX: Update expected_hvac BEFORE turn_off to prevent race condition
          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "off"
                continue_on_error: true

          # v4.6.5: Turn off AC when switching to Manual mode - no verification retry needed
          - delay:
              milliseconds: 200

          - service: climate.turn_off
            target:
              entity_id: !input climate_entities
            continue_on_error: true

      # Smart Mode room absence (room empty but still home)
      - conditions:
          - condition: template
            value_template: "{{ control_mode == 'Smart' }}"
          - condition: template
            value_template: "{{ not room_presence_detected }}"
          - condition: template
            value_template: "{{ minutes_since_presence >= presence_timeout }}"
          - condition: template
            value_template: "{{ proximity_zone == 'home' or anyone_home }}"
          - condition: template
            value_template: "{{ time_since_change >= runtime_min }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üö™ Smart Mode: Room Empty
                    üí° Nobody detected in room for {{ minutes_since_presence | round(0) }} minutes
                    üè† You're still home, so switching to {{ smart_behavior|upper }} mode to save energy

                    üìã Technical: {{ time_since_change | round(1) }}min since last change
                  level: warning

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ smart_behavior == 'off' }}"
                sequence:
                  # v3.11.13 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
                  - condition: template
                    value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input helper_last_change
                    data:
                      datetime: "{{ now() }}"
                    continue_on_error: true

                  # v3.13.17 FIX: Update helpers BEFORE turn_off to prevent false override
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_hvac }}"
                        data:
                          value: "off"
                        continue_on_error: true

                  # v4.6.5: Small delay for helper propagation, then turn off - no verification retry needed
                  - delay:
                      milliseconds: 200

                  - service: climate.turn_off
                    target:
                      entity_id: !input climate_entities
                    continue_on_error: true

                  # v4.2.1: Update mode helper AFTER turn_off completes to prevent false override detection
                  - service: input_text.set_value
                    target:
                      entity_id: "{{ helper_mode }}"
                    data:
                      value: "smart_off"
                    continue_on_error: true

              - conditions:
                  - condition: template
                    value_template: "{{ smart_behavior == 'eco' }}"
                sequence:
                  # Set HVAC mode with auto preference and fallback for room eco mode
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            # Smart eco mode selection
                            # v3.10.0: Respect enable_heating and enable_cooling settings
                            expected_hvac_mode: >
                              {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                              {# Prefer auto/heat_cool only if both heating and cooling enabled #}
                              {% if enable_cooling and enable_heating and 'auto' in modes %}
                                auto
                              {% elif enable_cooling and enable_heating and 'Auto' in modes %}
                                Auto
                              {% elif enable_cooling and enable_heating and 'heat_cool' in modes %}
                                heat_cool
                              {% elif enable_cooling and enable_heating and 'Heat/Cool' in modes %}
                                Heat/Cool
                              {% elif current_temp > comfort_max_temp and enable_cooling and 'cool' in modes %}
                                cool
                              {% elif current_temp > comfort_max_temp and enable_cooling and 'Cool' in modes %}
                                Cool
                              {% elif current_temp < comfort_min_temp and enable_heating and 'heat' in modes %}
                                heat
                              {% elif current_temp < comfort_min_temp and enable_heating and 'Heat' in modes %}
                                Heat
                              {% elif enable_cooling and 'cool' in modes %}
                                cool
                              {% elif enable_cooling and 'Cool' in modes %}
                                Cool
                              {% elif enable_heating and 'heat' in modes %}
                                heat
                              {% elif enable_heating and 'Heat' in modes %}
                                Heat
                              {% else %}
                                off
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_hvac }}"
                          data:
                            value: "{{ expected_hvac_mode }}"
                          continue_on_error: true

                        # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            hvac_mode: "{{ expected_hvac_mode }}"

                  - variables:
                      expected_temp: >
                        {% if current_temp > comfort_max_temp %}
                          {{ comfort_max_temp + eco_mode_setpoint_offset }}
                          {% elif current_temp < comfort_min_temp %}
                          {{ comfort_min_temp - eco_mode_setpoint_offset }}
                          {% else %}
                          {{ target_temp }}
                        {% endif %}

                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: "{{ expected_temp }}"
                    continue_on_error: true

                  # v4.6.5: Batched service call - no verification retry needed
                  - service: climate.set_temperature
                    target:
                      entity_id: !input climate_entities
                    data:
                      temperature: "{{ expected_temp }}"
                    continue_on_error: true

                  - service: system_log.write
                    data:
                      message: >
                        üå°Ô∏è {{ room_name | upper }} TEMP SET: Smart Room Eco Mode
                        Set AC to: {{ ((comfort_max_temp + eco_mode_setpoint_offset) if current_temp > comfort_max_temp else (comfort_min_temp - eco_mode_setpoint_offset) if current_temp < comfort_min_temp else target_temp) | round(0) }}¬∞C (rounded for AC compatibility)
                        Actual value: {{ ((comfort_max_temp + eco_mode_setpoint_offset) if current_temp > comfort_max_temp else (comfort_min_temp - eco_mode_setpoint_offset) if current_temp < comfort_min_temp else target_temp) | round(1) }}¬∞C
                        Reason: {{ 'Eco cooling (comfort max +' + eco_mode_setpoint_offset|string + '¬∞C)' if current_temp > comfort_max_temp else 'Eco heating (comfort min -' + eco_mode_setpoint_offset|string + '¬∞C)' if current_temp < comfort_min_temp else 'Direct target (within comfort zone)' }}
                        Current: {{ current_temp | round(1) }}¬∞C ‚Üí Comfort range: {{ comfort_min_temp | round(1) }}-{{ comfort_max_temp | round(1) }}¬∞C
                      level: warning

                  # Set eco fan mode for efficient smart room eco mode
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                            desired_eco_fan: "{{ fan_speed_eco }}"
                            expected_fan_mode: >
                              {% if desired_eco_fan in available_fans %}
                                {{ desired_eco_fan }}
                                {% elif 'Auto' in available_fans %}
                                Auto
                                {% elif 'auto' in available_fans %}
                                auto
                                {% elif 'Quiet' in available_fans %}
                                Quiet
                                {% elif 'quiet' in available_fans %}
                                quiet
                                {% elif 'Silence' in available_fans %}
                                Silence
                                {% elif 'silence' in available_fans %}
                                silence
                                {% elif 'Level 1' in available_fans %}
                                Level 1
                                {% elif '1' in available_fans %}
                                1
                                {% elif 'low' in available_fans %}
                                low
                                {% elif 'Low' in available_fans %}
                                Low
                                {% else %}
                                {{ available_fans[0] if available_fans else 'Auto' }}
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_fan }}"
                          data:
                            value: "{{ expected_fan_mode }}"
                          continue_on_error: true

                        # v4.2.1: 200ms propagation delay before fan service call
                        - delay:
                            milliseconds: 200

                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ expected_fan_mode }}"

                        # v4.2.1: Verify fan mode was set correctly, retry if not
                        - delay:
                            milliseconds: 500
                        - if:
                            - condition: template
                              value_template: "{{ state_attr(current_entity, 'fan_mode') | string | lower != expected_fan_mode | string | trim | lower }}"
                          then:
                            - service: climate.set_fan_mode
                              target:
                                entity_id: "{{ current_entity }}"
                              data:
                                fan_mode: "{{ expected_fan_mode }}"
                              continue_on_error: true

              - conditions:
                  - condition: template
                    value_template: "{{ smart_behavior == 'maintain' }}"
                sequence:
                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: "{{ adjusted_target }}"
                    continue_on_error: true

                  # v4.6.5: Batched service call - no verification retry needed
                  - service: climate.set_temperature
                    target:
                      entity_id: !input climate_entities
                    data:
                      temperature: "{{ adjusted_target }}"
                    continue_on_error: true

                  - service: system_log.write
                    data:
                      message: >
                        üå°Ô∏è {{ room_name | upper }} TEMP SET: Smart Room Maintain
                        Set AC to: {{ target_temp | round(0) }}¬∞C (rounded for AC compatibility)
                        Actual value: {{ target_temp | round(1) }}¬∞C
                        Reason: Smart mode maintain current temperature (room empty but still home)
                        Current: {{ current_temp | round(1) }}¬∞C ‚Üí Target: {{ target_temp | round(1) }}¬∞C
                      level: warning
          
          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "smart_{{ smart_behavior }}"

          # Update mode start time for effectiveness tracking (only if mode changed OR AC was off)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and last_mode != 'smart_' + smart_behavior }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true
          
          - condition: template
            value_template: "{{ enable_notifications }}"
          
          - service: !input notification_service
            data:
              title: "{{ room_name }} Climate Control"
              message: "Smart Mode: {{ smart_behavior }} (room empty {{ minutes_since_presence | round(0) }}min, {{ current_temp }}¬∞C)"
            continue_on_error: true

      # Away mode (Global - nobody home)
      - conditions:
          - condition: template
            value_template: "{{ enable_away_mode }}"
          - condition: template
            value_template: "{{ not should_activate }}"
          - condition: template
            value_template: "{{ time_since_change >= runtime_min }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    üîç {{ room_name | upper }} CLIMATE DEBUG: Away mode activated
                    Action: {{ away_action }}
                    Nobody home detected
                    Time since last change: {{ time_since_change | round(1) }} min
                  level: warning

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ away_action == 'off' }}"
                sequence:
                  # v3.11.13 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
                  - condition: template
                    value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input helper_last_change
                    data:
                      datetime: "{{ now() }}"
                    continue_on_error: true

                  # v3.13.17 FIX: Update helpers BEFORE turn_off to prevent false override
                  - if:
                      - condition: template
                        value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
                    then:
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ helper_expected_hvac }}"
                        data:
                          value: "off"
                        continue_on_error: true

                  - service: input_text.set_value
                    target:
                      entity_id: "{{ helper_mode }}"
                    data:
                      value: "off"
                    continue_on_error: true

                  # v4.6.5: Small delay for helper propagation, then turn off - no verification retry needed
                  - delay:
                      milliseconds: 200

                  - service: climate.turn_off
                    target:
                      entity_id: !input climate_entities
                    continue_on_error: true

              - conditions:
                  - condition: template
                    value_template: "{{ away_action == 'eco' }}"
                sequence:
                  # Set HVAC mode with auto preference and fallback for away eco mode
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                            selected_hvac_mode: >
                              {% if 'auto' in available_modes %}
                                auto
                                {% elif 'Auto' in available_modes %}
                                Auto
                                {% elif 'heat_cool' in available_modes %}
                                heat_cool
                                {% elif 'Heat/Cool' in available_modes %}
                                heat_cool
                                {% elif current_temp > comfort_max_temp and 'cool' in available_modes %}
                                cool
                                {% elif current_temp < comfort_min_temp and 'heat' in available_modes %}
                                heat
                                {% else %}
                                {{ available_modes[0] if available_modes else 'off' }}
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_hvac }}"
                          data:
                            value: "{{ selected_hvac_mode }}"
                          continue_on_error: true

                        # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            hvac_mode: "{{ selected_hvac_mode }}"

                  # Capture expected values for enhanced manual override detection (v3.3.0)
                  - service: input_number.set_value
                    target:
                      entity_id: "{{ helper_expected_temp }}"
                    data:
                      value: >
                        {% if current_temp > comfort_max_temp %}
                          {{ cooling_target_temp + eco_mode_setpoint_offset }}
                          {% else %}
                          {{ heating_target_temp - eco_mode_setpoint_offset }}
                        {% endif %}
                    continue_on_error: true

                  # v4.2.1: 200ms propagation delay before temperature service call
                  - delay:
                      milliseconds: 200

                  - service: climate.set_temperature
                    target:
                      entity_id: !input climate_entities
                    data:
                      temperature: >
                        {% if current_temp > comfort_max_temp %}
                          {{ cooling_target_temp + eco_mode_setpoint_offset }}
                          {% else %}
                          {{ heating_target_temp - eco_mode_setpoint_offset }}
                        {% endif %}

                  # v4.2.1: Verify temperature was set correctly, retry if not
                  - delay:
                      milliseconds: 500
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            eco_target: >
                              {% if current_temp > comfort_max_temp %}
                                {{ cooling_target_temp + eco_mode_setpoint_offset }}
                              {% else %}
                                {{ heating_target_temp - eco_mode_setpoint_offset }}
                              {% endif %}
                        - if:
                            - condition: template
                              value_template: "{{ (state_attr(repeat.item, 'temperature') | float(0) - eco_target | float) | abs > 0.5 }}"
                          then:
                            - service: climate.set_temperature
                              target:
                                entity_id: "{{ repeat.item }}"
                              data:
                                temperature: "{{ eco_target }}"
                              continue_on_error: true

                  - service: system_log.write
                    data:
                      message: >
                        üå°Ô∏è {{ room_name | upper }} TEMP SET: Away Eco Mode
                        Set AC to: {{ ((cooling_target_temp + eco_mode_setpoint_offset) if current_temp > comfort_max_temp else (heating_target_temp - eco_mode_setpoint_offset)) | round(0) }}¬∞C (rounded for AC compatibility)
                        Actual value: {{ ((cooling_target_temp + eco_mode_setpoint_offset) if current_temp > comfort_max_temp else (heating_target_temp - eco_mode_setpoint_offset)) | round(1) }}¬∞C
                        Reason: {{ 'Eco cooling (target +' + eco_mode_setpoint_offset|string + '¬∞C offset)' if current_temp > comfort_max_temp else 'Eco heating (target -' + eco_mode_setpoint_offset|string + '¬∞C offset)' }}
                        Current: {{ current_temp | round(1) }}¬∞C ‚Üí Comfort range: {{ comfort_min_temp | round(1) }}-{{ comfort_max_temp | round(1) }}¬∞C
                      level: warning
                  
                  # Set eco fan mode for efficient away eco mode
                  - repeat:
                      for_each: "{{ climate_list }}"
                      sequence:
                        - variables:
                            current_entity: "{{ repeat.item }}"
                            available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                            desired_eco_fan: "{{ fan_speed_eco }}"
                            selected_fan_mode: >
                              {% if desired_eco_fan in available_fans %}
                                {{ desired_eco_fan }}
                                {% elif 'Auto' in available_fans %}
                                Auto
                                {% elif 'auto' in available_fans %}
                                auto
                                {% elif '1' in available_fans %}
                                1
                                {% elif 'Level 1' in available_fans %}
                                Level 1
                                {% elif 'low' in available_fans %}
                                low
                                {% elif 'Low' in available_fans %}
                                Low
                                {% else %}
                                {{ available_fans[0] if available_fans else 'Auto' }}
                              {% endif %}

                        # Capture expected values for enhanced manual override detection (v3.3.0)
                        - service: input_text.set_value
                          target:
                            entity_id: "{{ helper_expected_fan }}"
                          data:
                            value: "{{ selected_fan_mode }}"
                          continue_on_error: true

                        # v4.2.1: 200ms propagation delay before fan service call
                        - delay:
                            milliseconds: 200

                        - service: climate.set_fan_mode
                          target:
                            entity_id: "{{ current_entity }}"
                          data:
                            fan_mode: "{{ selected_fan_mode }}"

                        # v4.2.1: Verify fan mode was set correctly, retry if not
                        - delay:
                            milliseconds: 500
                        - if:
                            - condition: template
                              value_template: "{{ state_attr(current_entity, 'fan_mode') | string | lower != selected_fan_mode | string | trim | lower }}"
                          then:
                            - service: climate.set_fan_mode
                              target:
                                entity_id: "{{ current_entity }}"
                              data:
                                fan_mode: "{{ selected_fan_mode }}"
                              continue_on_error: true

          - condition: template
            value_template: "{{ enable_notifications }}"

          - service: !input notification_service
            data:
              title: "Climate Away Mode"
              message: "{{ away_action | title }} mode activated - nobody home"
            continue_on_error: true

      # Low heating mode - DEPRECATED (unified heating mode)
      # This section is now handled by unified heating logic
      # Kept for backwards compatibility but should not activate
      - conditions:
          - condition: template
            value_template: "{{ false }}"
          - condition: template
            value_template: >
              {% if last_mode == 'heating' %}
                {# Same heating mode - allow escalation, enforce runtime for de-escalation #}
                {{ final_escalation_level > 0 or time_in_current_mode > runtime_min }}
              {% elif (last_mode == 'off' or actual_ac_state == 'off') and enforce_offtime %}
                {# Starting from OFF - enforce off-time if enabled #}
                {# Check BOTH helper mode AND actual AC state to catch mode change scenarios #}
                {{ time_in_current_mode > offtime_min }}
              {% else %}
                {# Switching from cooling/eco OR off-time protection disabled #}
                true
              {% endif %}
        sequence:
          - service: system_log.write
            data:
              message: >
                {% set current_mode = states(helper_mode) | default('off') %}
                {% set overshoot_turnoff = (target_temp + target_overshoot) | round(1) %}
                {% set temp_gap = (overshoot_turnoff - current_temp) | round(1) %}
                {% set temp_gap_adjusted = (adjusted_target - current_temp) | round(1) %}
                {% set eta_minutes = (temp_gap / temp_change_rate) | round(0) if temp_change_rate > 0 else 99 %}
                {% set effectiveness = current_effectiveness if dynamic_enabled else 65 %}
                {% set escalation = escalation_level if dynamic_enabled else 0 %}
                {% set deescalation = deescalation_level if dynamic_enabled else 0 %}
                {% set esc_display = 'L' ~ escalation if escalation > 0 else ('DE-L' ~ deescalation if deescalation > 0 else 'L0') %}
                {% set selected_fan = (final_escalation_level + 1) | string if final_escalation_level >= 0 else '1' %}
                {% set current_fan = selected_fan %}
                {% set target_info = 'User: ' ~ target_temp ~ '¬∞C | Overshoot: +' ~ target_overshoot ~ '¬∞C | AC Setpoint: ' ~ adjusted_target ~ '¬∞C' if adjusted_target != target_temp else 'User: ' ~ target_temp ~ '¬∞C | Overshoot: +' ~ target_overshoot ~ '¬∞C' %}

                {% if current_mode == 'heating' and current_temp < comfort_min_temp %}
                  {% if temp_gap <= 0.3 %}
                    üéØ {{ room_name | upper }} LOW HEATING - PRECISION FINISH

                    üìä Temperature Status:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C ‚Üí Target: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Remaining: {{ temp_gap_adjusted }}¬∞C
                        ‚Ä¢ ETA: ~{{ eta_minutes }} min

                    ‚ö° Performance:
                        {% if effectiveness >= 80 %}‚Ä¢ Status: üéØ PRECISE CONTROL{% elif effectiveness >= 60 %}‚Ä¢ Status: ‚öôÔ∏è GOOD EFFICIENCY ({{ effectiveness }}%){% else %}‚Ä¢ Status: üîß FINE-TUNING ({{ effectiveness }}% effective){% endif %}

                  {% elif temp_gap <= 1.5 %}
                    üî• {{ room_name | upper }} LOW HEATING - GENTLE APPROACH

                    üìä Temperature Status:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C ‚Üí Target: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Distance: {{ temp_gap_adjusted }}¬∞C to heat
                        ‚Ä¢ ETA: ~{{ eta_minutes }} min

                    ‚ö° Performance:
                        ‚Ä¢ Escalation: {{ esc_display }}
                        ‚Ä¢ Fan: {{ current_fan }}{% if escalation > 0 %}
                        ‚Ä¢ Status: üîº ESCALATING L{{ escalation }}{% elif deescalation > 0 %}
                        ‚Ä¢ Status: üîΩ DE-ESCALATING L{{ deescalation }}{% endif %}

                  {% else %}
                    üî• {{ room_name | upper }} LOW HEATING - PATIENT MODE

                    üìä Temperature Status:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C ‚Üí Target: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Distance: {{ temp_gap_adjusted }}¬∞C to heat
                        ‚Ä¢ Mode: Gentle power until comfort

                    ‚ö° Performance:
                        ‚Ä¢ Escalation: {{ esc_display }}
                        ‚Ä¢ Fan: {{ current_fan }}
                        ‚Ä¢ Effectiveness: {{ effectiveness }}%

                  {% endif %}
                {% else %}
                  {% if temp_gap >= 3.0 %}
                    üî• {{ room_name | upper }} LOW HEATING - CAUTIOUS START

                    üìä Temperature Status:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C (MODERATE COLD)
                        ‚Ä¢ Threshold: <{{ comfort_min_temp }}¬∞C
                        ‚Ä¢ Target: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Deficit: {{ temp_gap_adjusted }}¬∞C
                        ‚Ä¢ ETA: ~{{ eta_minutes }} min

                    ‚ö° Performance:
                        ‚Ä¢ Mode: Gentle heating approach

                  {% elif temp_gap >= 1.0 %}
                    üî• {{ room_name | upper }} LOW HEATING - COMFORT ADJUSTMENT

                    üìä Temperature Status:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C (SLIGHT COLD)
                        ‚Ä¢ Threshold: <{{ comfort_min_temp }}¬∞C
                        ‚Ä¢ Target: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Distance: {{ temp_gap_adjusted }}¬∞C to heat

                    ‚ö° Performance:
                        ‚Ä¢ Mode: Gentle warming
                        ‚Ä¢ Escalation: {{ esc_display }}
                        ‚Ä¢ Fan: {{ current_fan }}

                  {% else %}
                    üî• {{ room_name | upper }} LOW HEATING - MICRO-ADJUST

                    üìä Temperature Status:
                        ‚Ä¢ Current: {{ current_temp }}¬∞C
                        ‚Ä¢ Threshold: <{{ comfort_min_temp }}¬∞C
                        ‚Ä¢ Target: {{ adjusted_target }}¬∞C
                        ‚Ä¢ Remaining: {{ temp_gap_adjusted }}¬∞C
                        ‚Ä¢ ETA: ~{{ eta_minutes }} min

                    ‚ö° Performance:
                        ‚Ä¢ Mode: Minimal warming for fine-tuning

                  {% endif %}
                {% endif %}
                ‚Ä¢ Last Mode: {{ current_mode }}
              level: warning
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                üîç {{ room_name | upper }} CLIMATE DEBUG: LOW HEATING MODE
                ‚Ä¢ Temperature: {{ current_temp }}¬∞C < {{ comfort_min_temp }}¬∞C
                Target: {{ heating_target_temp }}¬∞C
                ‚Ä¢ Fan: Low/Minimum (efficient)
              level: warning

          # Capture expected values for enhanced manual override detection (v3.3.0)
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: >
                {% if current_temp > comfort_max_temp %}
                  cool
                {% elif current_temp < comfort_min_temp %}
                  heat
                {% else %}
                  heat_cool
                {% endif %}
            continue_on_error: true

          # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
          - service: climate.set_hvac_mode
            target:
              entity_id: !input climate_entities
            data:
              hvac_mode: >
                {% if current_temp > comfort_max_temp %}
                  cool
                {% elif current_temp < comfort_min_temp %}
                  heat
                {% else %}
                  heat_cool
                {% endif %}

          # Capture expected values for enhanced manual override detection (v3.3.0)
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ heating_target_temp }}"
            continue_on_error: true

          - service: system_log.write
            data:
              message: >
                üå°Ô∏è {{ room_name | upper }} TEMP SET: Low Heating
                Set AC to: {{ heating_target_temp | round(0) }}¬∞C (rounded for AC compatibility)
                Actual value: {{ heating_target_temp | round(1) }}¬∞C
                Current: {{ current_temp | round(1) }}¬∞C ‚Üí Target: {{ heating_target_temp | round(1) }}¬∞C
              level: warning

          # v4.6.14 FIX: Set low fan mode with compatibility check
          # Set fan FIRST, then temperature (Daikin integration requirement)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"

                    # Smart low fan mode selection
                    selected_fan_mode: >
                      {% set fans = state_attr(repeat.item, 'fan_modes') | list %}

                      {# Try low speed equivalents in order of preference #}
                      {% if 'low' in fans %}
                        low
                        {% elif 'Low' in fans %}
                        Low
                        {% elif '1' in fans %}
                        1
                        {% elif 'Level 1' in fans %}
                        Level 1
                        {% elif 'quiet' in fans %}
                        quiet
                        {% elif 'Quiet' in fans %}
                        Quiet
                        {% elif 'eco' in fans %}
                        eco
                        {% elif 'Eco' in fans %}
                        Eco
                        {% elif 'auto' in fans %}
                        auto
                        {% elif 'Auto' in fans %}
                        Auto
                      {# Fallback to available options #}
                        {% elif '2' in fans %}
                        2
                        {% elif 'Level 2' in fans %}
                        Level 2
                        {% else %}
                        {{ fans[0] if fans else 'Auto' }}
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_fan }}"
                  data:
                    value: "{{ selected_fan_mode }}"
                  continue_on_error: true

                # v4.6.14 FIX: Set fan mode FIRST (Daikin integration requirement)
                - service: climate.set_fan_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    fan_mode: "{{ selected_fan_mode | trim if selected_fan_mode is string else selected_fan_mode }}"
                  continue_on_error: true

                # v4.6.14 FIX: Set temperature SECOND (pydaikin will GET and read correct fan rate)
                - service: climate.set_temperature
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    temperature: "{{ heating_target_temp }}"
                  continue_on_error: true

                - condition: template
                  value_template: "{{ debug_enabled }}"
                - service: system_log.write
                  data:
                    message: >
                      üîç SMART LOW HEAT FAN: {{ repeat.item }}
                      ‚Ä¢ Available: {{ available_fans | join(', ') }}
                      ‚Ä¢ Selected: {{ selected_fan_mode }}
                      ‚Ä¢ Reason: Low fan speed for gentle heating
                    level: debug

          # Set swing mode with compatibility check
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_swings: "{{ state_attr(repeat.item, 'swing_modes') | list }}"
                    desired_swing: !input swing_mode_active
                    selected_swing_mode: >
                      {% if desired_swing in available_swings %}
                        {{ desired_swing }}
                        {% elif desired_swing == 'both' and '3D' in available_swings %}
                        3D
                        {% elif desired_swing == 'both' and 'Both' in available_swings %}
                        Both
                        {% elif desired_swing == 'vertical' and 'Vertical' in available_swings %}
                        Vertical
                        {% elif desired_swing == 'Vertical' and 'vertical' in available_swings %}
                        vertical
                        {% elif desired_swing == 'horizontal' and 'Horizontal' in available_swings %}
                        Horizontal
                        {% elif desired_swing == 'Horizontal' and 'horizontal' in available_swings %}
                        horizontal
                        {% elif 'both' in available_swings %}
                        both
                        {% elif 'Both' in available_swings %}
                        Both
                        {% elif '3D' in available_swings %}
                        3D
                        {% elif 'Vertical' in available_swings %}
                        Vertical
                        {% elif 'vertical' in available_swings %}
                        vertical
                        {% else %}
                        {{ available_swings[0] if available_swings else 'off' }}
                      {% endif %}
                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_swing }}"
                  data:
                    value: "{{ selected_swing_mode | trim }}"
                  continue_on_error: true

                - service: climate.set_swing_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    swing_mode: "{{ selected_swing_mode | trim }}"
          
          # v4.2.1: 200ms propagation delay before temperature service call
          - delay:
              milliseconds: 200

          # v3.9.13: Set temperature with correct fan/swing
          - service: climate.set_temperature
            target:
              entity_id: !input climate_entities
            data:
              temperature: "{{ heating_target_temp }}"

          # v4.2.1: Verify temperature was set correctly, retry if not
          - delay:
              milliseconds: 500
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - if:
                    - condition: template
                      value_template: "{{ (state_attr(repeat.item, 'temperature') | float(0) - heating_target_temp) | abs > 0.5 }}"
                  then:
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ repeat.item }}"
                      data:
                        temperature: "{{ heating_target_temp }}"
                      continue_on_error: true

          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "heating"

          # Update hysteresis tracking - we're now heating
          - condition: template
            value_template: "{{ helper_last_transition is defined and helper_last_transition != none }}"
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_last_transition }}"
            data:
              value: "heating"
          
          # Update mode start time for effectiveness tracking (only if it exists)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'cooling' or actual_ac_state == 'off') }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true
          
          - condition: template
            value_template: "{{ enable_notifications }}"
          
          - service: !input notification_service
            data:
              title: "{{ room_name }} Climate Control"
              message: "Low heating mode - {{ current_temp }}¬∞C"
            continue_on_error: true

      # Medium heating mode - DEPRECATED (unified heating mode)
      # This section is now handled by unified heating logic
      # Kept for backwards compatibility but should not activate
      - conditions:
          - condition: template
            value_template: "{{ false }}"
        sequence:
          - condition: template
            value_template: "{{ debug_enabled }}"
          - service: system_log.write
            data:
              message: >
                üîç {{ room_name | upper }} CLIMATE DEBUG: MEDIUM HEATING MODE
                ‚Ä¢ Temperature: {{ current_temp }}¬∞C (below {{ comfort_min_temp }}¬∞C min)
                Target: {{ heating_target_temp }}¬∞C
                ‚Ä¢ Fan: Auto/Medium (efficient)
              level: warning
          
          # Set HVAC mode to auto for efficient medium heating
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_modes: "{{ state_attr(repeat.item, 'hvac_modes') | list }}"
                    # Smart heating mode selection
                    # v3.10.0: Only use auto/heat_cool if cooling is also enabled
                    selected_hvac_mode: >
                      {% set modes = state_attr(repeat.item, 'hvac_modes') | list %}
                      {# For heating, try heating-capable modes #}
                      {% if 'heat' in modes %}
                        heat
                      {% elif 'Heat' in modes %}
                        Heat
                      {% elif enable_cooling and 'auto' in modes %}
                        auto
                      {% elif enable_cooling and 'Auto' in modes %}
                        Auto
                      {% elif enable_cooling and 'heat_cool' in modes %}
                        heat_cool
                      {% elif enable_cooling and 'Heat/Cool' in modes %}
                        Heat/Cool
                      {% else %}
                        off
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_hvac }}"
                  data:
                    value: "{{ selected_hvac_mode }}"
                  continue_on_error: true

                # v4.6.11 FIX: climate.set_hvac_mode with active mode (cool/heat) implicitly turns on AC
                - service: climate.set_hvac_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    hvac_mode: "{{ selected_hvac_mode }}"
          
          # Capture expected values for enhanced manual override detection (v3.3.0)
          - service: input_number.set_value
            target:
              entity_id: "{{ helper_expected_temp }}"
            data:
              value: "{{ heating_target_temp }}"
            continue_on_error: true

          - service: system_log.write
            data:
              message: >
                üå°Ô∏è {{ room_name | upper }} TEMP SET: Medium Heating
                Set AC to: {{ heating_target_temp | round(0) }}¬∞C (rounded for AC compatibility)
                Actual value: {{ heating_target_temp | round(1) }}¬∞C
                Current: {{ current_temp | round(1) }}¬∞C ‚Üí Target: {{ heating_target_temp | round(1) }}¬∞C
              level: warning

          # v4.6.14 FIX: Set auto/medium fan mode for efficient heating
          # Set fan FIRST, then temperature (Daikin integration requirement)
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_fans: "{{ state_attr(repeat.item, 'fan_modes') | list }}"
                    selected_fan_mode: >
                      {% if 'Auto' in available_fans %}
                        Auto
                        {% elif 'auto' in available_fans %}
                        auto
                        {% elif 'medium' in available_fans %}
                        medium
                        {% elif 'Level 3' in available_fans %}
                        Level 3
                        {% elif '3' in available_fans %}
                        3
                        {% else %}
                        {{ available_fans[-1] if available_fans else 'Auto' }}
                      {% endif %}

                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_fan }}"
                  data:
                    value: "{{ selected_fan_mode }}"
                  continue_on_error: true

                # v4.6.14 FIX: Set fan mode FIRST (Daikin integration requirement)
                - service: climate.set_fan_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    fan_mode: "{{ selected_fan_mode | trim if selected_fan_mode is string else selected_fan_mode }}"
                  continue_on_error: true

                # v4.6.14 FIX: Set temperature SECOND (pydaikin will GET and read correct fan rate)
                - service: climate.set_temperature
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    temperature: "{{ heating_target_temp }}"
                  continue_on_error: true

          # Set swing mode with compatibility check
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - variables:
                    current_entity: "{{ repeat.item }}"
                    available_swings: "{{ state_attr(repeat.item, 'swing_modes') | list }}"
                    desired_swing: !input swing_mode_active
                    selected_swing_mode: >
                      {% if desired_swing in available_swings %}
                        {{ desired_swing }}
                        {% elif desired_swing == 'both' and '3D' in available_swings %}
                        3D
                        {% elif desired_swing == 'both' and 'Both' in available_swings %}
                        Both
                        {% elif desired_swing == 'vertical' and 'Vertical' in available_swings %}
                        Vertical
                        {% elif desired_swing == 'Vertical' and 'vertical' in available_swings %}
                        vertical
                        {% elif desired_swing == 'horizontal' and 'Horizontal' in available_swings %}
                        Horizontal
                        {% elif desired_swing == 'Horizontal' and 'horizontal' in available_swings %}
                        horizontal
                        {% elif 'both' in available_swings %}
                        both
                        {% elif 'Both' in available_swings %}
                        Both
                        {% elif '3D' in available_swings %}
                        3D
                        {% elif 'Vertical' in available_swings %}
                        Vertical
                        {% elif 'vertical' in available_swings %}
                        vertical
                        {% else %}
                        {{ available_swings[0] if available_swings else 'off' }}
                      {% endif %}
                # Capture expected values for enhanced manual override detection (v3.3.0)
                - service: input_text.set_value
                  target:
                    entity_id: "{{ helper_expected_swing }}"
                  data:
                    value: "{{ selected_swing_mode | trim }}"
                  continue_on_error: true

                - service: climate.set_swing_mode
                  target:
                    entity_id: "{{ current_entity }}"
                  data:
                    swing_mode: "{{ selected_swing_mode | trim }}"
          
          # v4.2.1: 200ms propagation delay before temperature service call
          - delay:
              milliseconds: 200

          # v3.9.13: Set temperature with correct fan/swing
          - service: climate.set_temperature
            target:
              entity_id: !input climate_entities
            data:
              temperature: "{{ heating_target_temp }}"

          # v4.2.1: Verify temperature was set correctly, retry if not
          - delay:
              milliseconds: 500
          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                - if:
                    - condition: template
                      value_template: "{{ (state_attr(repeat.item, 'temperature') | float(0) - heating_target_temp) | abs > 0.5 }}"
                  then:
                    - service: climate.set_temperature
                      target:
                        entity_id: "{{ repeat.item }}"
                      data:
                        temperature: "{{ heating_target_temp }}"
                      continue_on_error: true

          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "heating"

          # Update hysteresis tracking - we're now heating
          - condition: template
            value_template: "{{ helper_last_transition is defined and helper_last_transition != none }}"
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_last_transition }}"
            data:
              value: "heating"
          
          # Update mode start time for effectiveness tracking (only if it exists)
          - condition: template
            value_template: "{{ dynamic_enabled and helper_mode_time not in [none, '', 'unavailable', 'unknown', []] and helper_mode_time is string and helper_mode_time != '' and (last_mode != 'cooling' or actual_ac_state == 'off') }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ helper_mode_time }}"
            data:
              datetime: "{{ now() }}"
            continue_on_error: true
          
          - condition: template
            value_template: "{{ enable_notifications }}"
          
          - service: !input notification_service
            data:
              title: "{{ room_name }} Climate Control"
              message: "Medium heating mode - {{ current_temp }}¬∞C"
            continue_on_error: true

  # Turn off AC in Smart mode when presence is lost (after grace period)
  # v3.9.23 FIX: Don't turn off if presence detected NOW (even during confirmation delay)
  - if:
        - condition: template
          value_template: >
            {{
              actual_ac_state == 'on' and
              control_mode == 'Smart' and
              not smart_presence_active and
              not room_presence_detected and
              last_mode in ['cooling', 'heating', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only'] and
              time_since_change >= runtime_min
            }}
    then:
      # Log the turn-off action
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üö™ {{ room_name | upper }} SMART MODE - PRESENCE NOT CONFIRMED

                {% if room_presence_detected %}
                ‚è≥ Presence detected but confirmation delay not met:
                    ‚Ä¢ Control Mode: Smart
                    ‚Ä¢ Sensors detecting presence: YES
                    ‚Ä¢ Time with presence: {{ minutes_with_presence | round(1) }} min
                    ‚Ä¢ Required confirmation delay: {{ presence_confirmation_delay }} min
                    ‚Ä¢ Grace period since last confirmed: {{ presence_timeout }} min
                    ‚Ä¢ Current Mode: {{ last_mode }}
                    ‚Ä¢ Action: Turning AC OFF (presence not confirmed for {{ presence_confirmation_delay }} min)
                {% else %}
                ‚úÖ Turning Off After Grace Period:
                    ‚Ä¢ Control Mode: Smart
                    ‚Ä¢ Sensors detecting presence: NO
                    ‚Ä¢ Minutes since last confirmed: {{ minutes_since_presence | round(1) }} min
                    ‚Ä¢ Grace Period: {{ presence_timeout }} minutes
                    ‚Ä¢ Current Mode: {{ last_mode }}
                    ‚Ä¢ Action: Turning AC OFF (no presence after grace period)
                {% endif %}
              level: warning

      # v3.14.0: Always-on event logging for deactivation
      - if:

          - condition: template

            value_template: "{{ event_logging_enabled }}"

        then:
      - service: system_log.write
        data:
          message: >
            üî¥ {{ room_name | upper }} AC DEACTIVATED

            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            üìä USER INFO:
            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            Final Temperature: {{ current_temp }}¬∞C (Target: {{ target_temp }}¬∞C)
            Mode at Shutdown: {{ states(helper_mode) | default('unknown') }}

            Reason: Smart mode - No presence detected (grace period expired)
            ‚Ä¢ Control Mode: {{ control_mode }}
            ‚Ä¢ Temperature achieved: {{ current_temp | float <= (target_temp + 0.5) if 'Smart mode - No presence detected (grace period expired)' == 'Target achieved' else 'N/A' }}

            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            üîç DEBUG DATA (for troubleshooting):
            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            Temperature Analysis:
                ‚Ä¢ current_temp: {{ current_temp }}¬∞C
                ‚Ä¢ target_temp: {{ target_temp }}¬∞C
                ‚Ä¢ target_overshoot: {{ target_overshoot if target_overshoot is defined else 0 }}¬∞C

            Deactivation Conditions:
                ‚Ä¢ actual_ac_state: {{ actual_ac_state }}
                ‚Ä¢ time_since_change: {{ time_since_change | round(1) }}s
                ‚Ä¢ control_mode: {{ control_mode }}

            State Updates (performed):
                ‚Ä¢ helper_last_mode: updated to appropriate off state
                ‚Ä¢ helper_expected_hvac: updated to 'off' BEFORE climate.turn_off
                ‚Ä¢ helper_change: updated to now()

            Trigger Info:
                ‚Ä¢ trigger.id: {{ trigger.id }}
                ‚Ä¢ trigger.entity_id: {{ trigger.entity_id if trigger.entity_id is defined else 'N/A' }}
          level: warning

      # Turn off the AC
      # v3.11.13 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
      - condition: template
        value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
      - service: input_datetime.set_datetime
        target:
          entity_id: !input helper_last_change
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

      # Update expected_hvac BEFORE turn_off (this is correct - tells detection what we expect)
      - if:
          - condition: template
            value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: "off"
            continue_on_error: true

      # v4.2.1: 200ms propagation delay before turn_off
      - delay:
          milliseconds: 200

      - service: climate.turn_off
        target:
          entity_id: !input climate_entities
        continue_on_error: true

      # v4.2.1: Verify AC was turned off correctly, retry if not
      - delay:
          milliseconds: 500
      - repeat:
          for_each: "{{ climate_list }}"
          sequence:
            - if:
                - condition: template
                  value_template: "{{ states(repeat.item) not in ['off', 'unavailable'] }}"
              then:
                - service: climate.turn_off
                  target:
                    entity_id: "{{ repeat.item }}"
                  continue_on_error: true

      # v4.2.1: Update mode helper AFTER turn_off completes to prevent false override detection
      - service: input_text.set_value
        target:
          entity_id: !input helper_last_mode
        data:
          value: "off"
        continue_on_error: true

      # Update mode start time for off-time protection tracking
      - if:
          - condition: template
            value_template: "{{ helper_mode_time not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: !input helper_mode_start_time
            data:
              datetime: "{{ now() }}"
            continue_on_error: true


  # Turn off AC if it's running but temperature has reached/passed target
  # v3.9.27 FIX: Use OVERSHOOT target, not user target!
  # v4.6.0: Don't turn off if bed ECO mode should activate instead
  - if:
      - condition: template
        value_template: >
          {{
            actual_ac_state == 'on' and
            (last_mode == 'cooling' or last_mode == 'heating') and
            time_since_change >= runtime_min and
            (
              (last_mode == 'cooling' and current_temp <= (target_temp - target_overshoot)) or
              (last_mode == 'heating' and current_temp >= (target_temp + target_overshoot))
            ) and
            not (bed_sensor_manual and is_state(bed_sensor_manual, 'on') and bed_eco_fan_only_mode == true)
          }}
    then:
      # Log the turn-off action
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üéØ {{ room_name | upper }} TARGET REACHED - TURNING OFF

                ‚úÖ Conditions Met:
                    ‚Ä¢ Current: {{ current_temp }}¬∞C
                    ‚Ä¢ Target: {{ cooling_target_temp if last_mode == 'cooling' else heating_target_temp }}¬∞C
                    ‚Ä¢ Mode: {{ last_mode }}
                    ‚Ä¢ Runtime: {{ time_since_change | round(1) }}min (min: {{ runtime_min }}min)
                    ‚Ä¢ Action: Turning AC OFF (target achieved)
              level: warning

      # Turn off the AC
      # v3.11.13 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
      - condition: template
        value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
      - service: input_datetime.set_datetime
        target:
          entity_id: !input helper_last_change
        data:
          datetime: "{{ now() }}"
        continue_on_error: true

      # Update expected_hvac BEFORE turn_off (this is correct - tells detection what we expect)
      - if:
          - condition: template
            value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ helper_expected_hvac }}"
            data:
              value: "off"
            continue_on_error: true

      # v4.6.5: Small delay for helper propagation, then turn off - no verification retry needed
      - delay:
          milliseconds: 200

      - service: climate.turn_off
        target:
          entity_id: !input climate_entities
        continue_on_error: true

      # v4.2.1: Update mode helper AFTER turn_off completes to prevent false override detection
      - service: input_text.set_value
        target:
          entity_id: !input helper_last_mode
        data:
          value: "off"
        continue_on_error: true

      # Update mode start time for off-time protection tracking
      - if:
          - condition: template
            value_template: "{{ helper_mode_time not in [none, '', 'unavailable', 'unknown'] }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: !input helper_mode_start_time
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

  # Debug: Show which conditions were evaluated but not met
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            üîç {{ room_name | upper }} DEBUG: Choose block completed - no conditions matched

            üìä Final Summary:
                ‚Ä¢ should_activate: {{ should_activate }}
                ‚Ä¢ smart_presence_active: {{ smart_presence_active }}
                ‚Ä¢ current_temp: {{ current_temp }}¬∞C
                ‚Ä¢ Control mode: {{ control_mode }}
                ‚Ä¢ AC state: {{ actual_ac_state }}
                ‚Ä¢ Time since change: {{ time_since_change | round(1) }}min
                ‚Ä¢ Room presence: {{ room_presence_detected }}
                ‚Ä¢ smart_behavior: {{ smart_behavior }}
                ‚Ä¢ extreme_temp_detected: {{ extreme_temp_detected }}

            üå°Ô∏è Thresholds that were checked:
                ‚Ä¢ Cooling: {{ current_temp }} > {{ comfort_max_temp }} = {{ current_temp > comfort_max_temp }}
                ‚Ä¢ Heating: {{ current_temp }} < {{ comfort_min_temp }} = {{ current_temp < comfort_min_temp }}
                ‚Ä¢ In Comfort Zone: {{ comfort_min_temp }} ‚â§ {{ current_temp }} ‚â§ {{ comfort_max_temp }} = {{ current_temp >= comfort_min_temp and current_temp <= comfort_max_temp }}
                ‚Ä¢ Escalation: {{ should_escalate }}
          level: warning


  # STATE SYNCHRONIZATION: Handle helper/AC mismatch (e.g., after HA restart)
  # v3.11.8 FIX: Expanded to catch heating/cooling mode mismatches, not just off/on mismatches
  # If helper says "off" but AC is running, OR helper says heating but AC is cooling (or vice versa)
  # v3.18.17: SKIP state sync when AC is in fan_only or dry mode
  # These modes are manual/user-controlled and should not be interfered with
  - if:
      - condition: template
        value_template: >
          {% set actual_hvac = states(climate_list[0]) | default('off') %}
          {% set is_unsupported_mode = actual_hvac in ['fan_only', 'dry'] %}
          {% set helper_is_heating = last_mode == 'heating' %}
          {% set helper_is_cooling = last_mode == 'cooling' %}
          {% set ac_is_heating = actual_hvac in ['heat'] %}
          {% set ac_is_cooling = actual_hvac in ['cool'] %}
          {{
            not is_unsupported_mode and (
              (last_mode == 'off' and actual_ac_state == 'on') or
              (helper_is_heating and ac_is_cooling) or
              (helper_is_cooling and ac_is_heating)
            )
          }}
    then:
      # Determine what the AC is probably doing based on current temperature
      # v3.11.8 FIX: Respect enable_cooling/enable_heating flags - don't guess heating mode if heating disabled!
      - variables:
          # v3.11.14 FIX: Check if AC is in continue mode FIRST before calculating probable_mode
          # This prevents State Sync from setting helper to "off" when AC should keep running
          # in continue mode (pursuing overshoot target below normal thresholds)
          in_continue_mode_cooling_check: >
            {% set actual_hvac = states(climate_list[0]) | default('off') %}
            {% set overshoot_target = target_temp - target_overshoot %}
            {{ enable_cooling
               and actual_hvac in ['cool']
               and current_temp > overshoot_target
               and current_temp <= comfort_max_temp }}

          in_continue_mode_heating_check: >
            {% set actual_hvac = states(climate_list[0]) | default('off') %}
            {% set overshoot_target = target_temp + target_overshoot %}
            {{ enable_heating
               and actual_hvac in ['heat']
               and current_temp < overshoot_target
               and current_temp >= comfort_min_temp }}

          probable_mode: >
            {% if enable_cooling and current_temp > comfort_max_temp %}
              cooling
            {% elif enable_heating and current_temp < comfort_min_temp %}
              heating
            {% elif in_continue_mode_cooling_check %}
              {# v4.0.0: Simplified - just show 'cooling' (no tier modes) #}
              cooling
            {% elif in_continue_mode_heating_check %}
              {# v4.0.0: Simplified - just show 'heating' (no tier modes) #}
              heating
            {% else %}
              off
            {% endif %}

          # v3.9.31 CRITICAL FIX: Check if AC is in continue mode pursuing overshoot target
          # Don't turn off AC if it's still trying to reach the overshoot target
          # v3.11.8 FIX: Only apply continue mode when AC was ALREADY running in cooling/heating
          # Prevents false activation when entering room at comfortable temp above overshoot target
          # v3.11.13 FIX: Use actual_hvac (AC state) instead of last_mode (helper state)
          # Fixes state sync turning off AC prematurely when helper out of sync
          # v3.11.14 FIX: Use pre-calculated continue mode checks to avoid duplication
          in_continue_mode_cooling: "{{ in_continue_mode_cooling_check }}"

          in_continue_mode_heating: "{{ in_continue_mode_heating_check }}"

          should_be_running: >
            {% set actual_hvac_mode = states(climate_list[0]) | default('off') %}
            {% set is_unsupported_mode = actual_hvac_mode in ['fan_only', 'dry'] %}
            {{ (probable_mode != 'off' or in_continue_mode_cooling or in_continue_mode_heating) and not is_unsupported_mode }}

      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üîÑ {{ room_name | upper }} STATE SYNC: Helper/AC mismatch detected

                üìä Mismatch Details:
                    ‚Ä¢ Helper Mode: {{ last_mode }} (says AC should be OFF)
                    ‚Ä¢ Actual AC State: {{ actual_ac_state }} (AC is ON)
                    ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                    ‚Ä¢ Target Temp: {{ target_temp }}¬∞C
                    ‚Ä¢ Overshoot Target: {% if enable_cooling %}{{ (target_temp - target_overshoot) | round(1) }}¬∞C (cooling){% elif enable_heating %}{{ (target_temp + target_overshoot) | round(1) }}¬∞C (heating){% else %}N/A{% endif %}
                    ‚Ä¢ Comfort Zone: {{ comfort_min_temp }}-{{ comfort_max_temp }}¬∞C

                ü§î Analysis:
                    ‚Ä¢ Probable Mode: {{ probable_mode }}
                    ‚Ä¢ In Continue Mode (Cooling): {{ in_continue_mode_cooling }}
                    ‚Ä¢ In Continue Mode (Heating): {{ in_continue_mode_heating }}
                    ‚Ä¢ Should AC Be Running: {{ should_be_running }}

                üõ†Ô∏è Action: {{ 'Updating helper to match AC operation' if should_be_running else 'Turning OFF AC (overshoot target reached)' }}
                üí° Reason: {% if should_be_running %}Helper out of sync - AC running but helper says "off" (possible causes: HA restart, manual control, or helper update lag){% elif in_continue_mode_cooling or in_continue_mode_heating %}AC in continue mode - pursuing overshoot target{{ ' (cooling to ' + (target_temp - target_overshoot) | round(1) | string + '¬∞C)' if in_continue_mode_cooling else ' (heating to ' + (target_temp + target_overshoot) | round(1) | string + '¬∞C)' if in_continue_mode_heating }}{% else %}AC is ON but overshoot target reached - no further cooling/heating needed (possible causes: manual turn-on, another automation, or lingering AC state){% endif %}
              level: warning

      # If AC should be running, update helper to track it
      # v3.18.6 CRITICAL FIX: Do NOT update helper_change during state sync!
      # State sync is housekeeping to keep helpers in sync with reality.
      # Updating helper_change blocks manual override detection for 45 seconds.
      # When user turns AC on ‚Üí state sync runs ‚Üí helper_change updated ‚Üí within_hardware_delay=true ‚Üí override blocked!
      - if:
          - condition: template
            value_template: "{{ should_be_running }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "{{ probable_mode }}"
            continue_on_error: true

          # v3.18.6: REMOVED helper_change update - only update last_mode for tracking
          # helper_change should only be updated when automation actively makes a control decision
          # NOT when passively syncing state

          # v3.18.6 CRITICAL FIX: Do NOT update helper_expected_hvac during state sync!
          # State sync is PASSIVE - it's detecting reality, not making decisions.
          # When user manually turns AC on ‚Üí state sync updates last_mode='cooling' or 'heating' for tracking
          # BUT expected_hvac should stay at its old value (likely 'off')
          # This allows manual override detection to work:
          #   - last_mode='off' (old value before state sync)
          #   - expected_hvac='off' (what automation last commanded)
          #   - actual_state='on' (user turned it on)
          #   - Result: is_manual_on=TRUE ‚Üí Override activates!
          #
          # If we set expected_hvac='cool' here, it blocks override:
          #   - automation_expects_on=TRUE (because expected_hvac='cool')
          #   - Result: is_manual_on=FALSE ‚Üí Override blocked!
          #
          # State sync should ONLY update tracking helpers (last_mode, mode_start_time)
          # NOT command helpers (expected_hvac, expected_fan, expected_swing)

          # Update mode start time helper for off-time protection tracking
          - if:
              - condition: template
                value_template: "{{ helper_mode_time not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_datetime.set_datetime
                target:
                  entity_id: !input helper_mode_start_time
                data:
                  datetime: "{{ now() }}"
                continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    ‚úÖ {{ room_name | upper }} STATE SYNC: Helper updated to {{ probable_mode }}
                    üìã AC running correctly for current temp ({{ current_temp }}¬∞C) - helper synced, will continue operation
                    {% if in_continue_mode_cooling %}üéØ Continue mode: Cooling to overshoot target {{ (target_temp - target_overshoot) | round(1) }}¬∞C{% elif in_continue_mode_heating %}üéØ Continue mode: Heating to overshoot target {{ (target_temp + target_overshoot) | round(1) }}¬∞C{% else %}üí° Helper was "off" but AC should be running - restored tracking{% endif %}
                  level: warning

      # If AC should NOT be running (temp in comfort zone), turn it off
      - if:
          - condition: template
            value_template: "{{ not should_be_running }}"
        then:
          # v3.13.2 FIX: Update helper_change BEFORE turn_off to prevent false Override detection
          - condition: template
            value_template: "{{ helper_change not in [none, '', 'unavailable', 'unknown'] }}"
          - service: input_datetime.set_datetime
            target:
              entity_id: !input helper_last_change
            data:
              datetime: "{{ now() }}"
            continue_on_error: true

          # v3.13.17 FIX: Update helpers BEFORE turn_off to prevent false override
          - if:
              - condition: template
                value_template: "{{ helper_expected_hvac not in [none, '', 'unavailable', 'unknown'] }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ helper_expected_hvac }}"
                data:
                  value: "off"
                continue_on_error: true

          - service: input_text.set_value
            target:
              entity_id: !input helper_last_mode
            data:
              value: "off"
            continue_on_error: true

          - repeat:
              for_each: "{{ climate_list }}"
              sequence:
                # v4.6.5: Set HVAC mode to off then turn off - no verification retry needed
                - service: climate.set_hvac_mode
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    hvac_mode: "off"
                  continue_on_error: true

                - delay:
                    milliseconds: 200

                - service: climate.turn_off
                  target:
                    entity_id: "{{ repeat.item }}"
                  continue_on_error: true

          - if:
              - condition: template
                value_template: "{{ debug_enabled }}"
            then:
              - service: system_log.write
                data:
                  message: >
                    ‚úÖ {{ room_name | upper }} STATE SYNC: AC turned OFF
                    üìã Temperature {{ current_temp }}¬∞C - overshoot target reached
                    üéØ Overshoot target: {% if enable_cooling %}{{ (target_temp - target_overshoot) | round(1) }}¬∞C (cooling){% elif enable_heating %}{{ (target_temp + target_overshoot) | round(1) }}¬∞C (heating){% else %}{{ target_temp }}¬∞C{% endif %}
                    üí° Helper was "off" but AC was running - turned off after reaching overshoot target
                  level: warning

  # v3.9.44 STATE SYNC REVERSE: Helper says AC should be running, but AC is OFF
  # This happens when automation turns off AC but helper doesn't update (rare edge case)
  # Without this, manual override keeps triggering because of the mismatch
  # IMPORTANT: Must run even if override is active (to break the catch-22 loop)
  # Don't sync immediately after sending commands - give AC hardware time to respond
  - if:
      - condition: template
        value_template: "{{ last_mode in ['cooling', 'heating', 'eco', 'bed_comfort_eco', 'bed_comfort_quiet', 'bed_eco_fan_only', 'comfort_fan_only', 'stability_fan_only'] and actual_ac_state == 'off' and time_since_change > 30 }}"
    then:
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üîÑ {{ room_name | upper }} STATE SYNC REVERSE: Helper/AC mismatch detected (v3.9.44 FIX)

                üìä Mismatch Details:
                    ‚Ä¢ Helper Mode: {{ last_mode }} (says AC should be running)
                    ‚Ä¢ Actual AC State: {{ actual_ac_state }} (AC is OFF)
                    ‚Ä¢ Current Temp: {{ current_temp }}¬∞C
                    ‚Ä¢ Target Temp: {{ target_temp }}¬∞C
                    ‚Ä¢ Time since last change: {{ time_since_change | round(1) }}min

                üîß Analysis:
                    ‚Ä¢ AC was probably turned off by automation (temperature reached)
                    ‚Ä¢ Helper stuck at "{{ last_mode }}" instead of "off"
                    ‚Ä¢ Without fix: Manual override keeps triggering on every check

                ‚úÖ Action: Syncing helper to "off" to match reality
              level: warning

      # Sync helper to match reality - AC is off
      - service: input_text.set_value
        target:
          entity_id: !input helper_last_mode
        data:
          value: "off"
        continue_on_error: true

      # v3.11.0: Override flag removed - Override is now a control mode

      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                ‚úÖ {{ room_name | upper }} STATE SYNC REVERSE: Helper updated to "off"
                üìã Helper now matches AC state - manual override cleared automatically
              level: warning

  # v3.1.6/v3.1.7 helper_change update REMOVED - caused false override re-triggers
  # The update ran even when choose block had no actions, causing override re-activation
  # Proper fix is in the manual detection logic itself (see manual_override_detection variable)

  # v3.18.14: SMART MODE NO PRESENCE - Turn off AC when no confirmed presence
  - if:
      - condition: template
        value_template: "{{ control_mode == 'Smart' and not smart_presence_active and actual_ac_state == 'on' }}"
    then:
      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                ‚èπÔ∏è {{ room_name | upper }} SMART MODE - TURNING OFF (NO PRESENCE)

                üìä Status:
                    ‚Ä¢ Last Mode: {{ last_mode }}
                    ‚Ä¢ AC State: {{ actual_ac_state }}
                    ‚Ä¢ Presence: None ({{ minutes_since_presence | round(0) }}min ago)
                    ‚Ä¢ Action: Turning off AC
              level: warning

      # v4.2.1: 200ms propagation delay before turn_off
      - delay:
          milliseconds: 200

      # v4.4.1 FIX: Use climate_list variable instead of !input (invalid in action section)
      - service: climate.turn_off
        target:
          entity_id: "{{ climate_list }}"

      # v4.2.1: Verify AC was turned off correctly, retry if not
      - delay:
          milliseconds: 500
      - repeat:
          for_each: "{{ climate_list }}"
          sequence:
            - if:
                - condition: template
                  value_template: "{{ states(repeat.item) not in ['off', 'unavailable'] }}"
              then:
                - service: climate.turn_off
                  target:
                    entity_id: "{{ repeat.item }}"
                  continue_on_error: true

      - service: input_text.set_value
        target:
          entity_id: !input helper_last_mode
        data:
          value: "smart_off"

      - service: input_datetime.set_datetime
        target:
          entity_id: !input helper_last_change
        data:
          datetime: "{{ now() }}"

  # v5.0.0: Update state machine helper on every run
  - if:
      - condition: template
        value_template: "{{ helper_state_machine not in [none, '', 'unavailable', 'unknown'] }}"
    then:
      - service: input_select.select_option
        target:
          entity_id: "{{ helper_state_machine }}"
        data:
          option: "{{ current_state_machine }}"
        continue_on_error: true

  # v5.0.6 CRITICAL: FINAL SNAPSHOT SYNC - Safety net for any missed service calls
  # This ensures snapshot is ALWAYS synced with actual AC state at end of automation run
  # Even if we missed a service call location, this will catch it
  - if:
      - condition: template
        value_template: "{{ helper_last_command not in [none, 'unavailable', 'unknown'] and climate_list | length > 0 }}"
    then:
      - variables:
          final_actual_hvac: "{{ states(climate_list[0]) }}"
          final_actual_temp: "{{ state_attr(climate_list[0], 'temperature') | float(22) | round(1) }}"
          final_actual_fan: "{{ state_attr(climate_list[0], 'fan_mode') | default('unknown') }}"
          final_actual_swing: "{{ state_attr(climate_list[0], 'swing_mode') | default('unknown') }}"
          final_snapshot: "hvac={{ final_actual_hvac }},temp={{ final_actual_temp }},fan={{ final_actual_fan }},swing={{ final_actual_swing }}"
          final_checksum: >
            {% set hvac_codes = {'off': 0, 'cool': 1, 'heat': 2, 'auto': 3, 'dry': 4, 'fan_only': 5, 'heat_cool': 6} %}
            {{ ((final_actual_temp * 1000) + (final_actual_fan | string | length) + (final_actual_swing | string | length) + hvac_codes.get(final_actual_hvac, 99)) | int(0) }}

      - service: input_text.set_value
        target:
          entity_id: "{{ helper_last_command }}"
        data:
          value: "{{ final_snapshot }}"
        continue_on_error: true

      - service: input_number.set_value
        target:
          entity_id: "{{ helper_state_checksum }}"
        data:
          value: "{{ final_checksum }}"
        continue_on_error: true

      - if:
          - condition: template
            value_template: "{{ debug_enabled }}"
        then:
          - service: system_log.write
            data:
              message: >
                üîí {{ room_name | upper }} FINAL SNAPSHOT SYNC
                    ‚Ä¢ Snapshot: {{ final_snapshot }}
                    ‚Ä¢ Checksum: {{ final_checksum }}
                    ‚Ä¢ Source: Actual AC state (safety net)
              level: warning

  # Debug: No conditions matched
  - if:
      - condition: template
        value_template: "{{ debug_enabled }}"
    then:
      - service: system_log.write
        data:
          message: >
            [18/18] ‚úÖ {{ room_name | upper }} CLIMATE CONTROL: All Good

            {% if (last_mode == 'cooling' or last_mode == 'heating') and actual_ac_state == 'on' %}üîÑ AC Status:
                ‚Ä¢ Mode: {{ last_mode|title }} active
                ‚Ä¢ Current Temperature: {{ current_temp }}¬∞C
            {% if last_mode == 'cooling' %}
            üéØ Cooling Targets:
                ‚Ä¢ Comfort Temperature: {{ target_temp }}¬∞C{% if target_overshoot > 0 %}
                ‚Ä¢ Overshoot Target: {{ (target_temp - target_overshoot) | round(1) }}¬∞C
                ‚Ä¢ Distance to Target: {{ (current_temp - (target_temp - target_overshoot)) | round(1) }}¬∞C away{% endif %}
            {% elif last_mode == 'heating' %}
            üéØ Heating Targets:
                ‚Ä¢ Comfort Temperature: {{ target_temp }}¬∞C{% if target_overshoot > 0 %}
                ‚Ä¢ Overshoot Target: {{ (target_temp + target_overshoot) | round(1) }}¬∞C
                ‚Ä¢ Distance to Target: {{ ((target_temp + target_overshoot) - current_temp) | round(1) }}¬∞C away{% endif %}
            {% endif %}{% elif current_temp >= comfort_min_temp and current_temp <= comfort_max_temp and actual_ac_state == 'off' %}üéØ Status:
                ‚Ä¢ Temperature: {{ current_temp }}¬∞C is perfect
                ‚Ä¢ AC State: Off{% else %}‚è∏Ô∏è Status:
                ‚Ä¢ No action required right now{% endif %}

            üìã Technical Details:
                ‚Ä¢ Temperature: {{ current_temp }}¬∞C
                ‚Ä¢ Occupancy: {% if room_presence_detected %}Room occupied{% elif anyone_home %}Home but elsewhere{% elif approaching_home %}Approaching{% else %}Away{% endif %}
                ‚Ä¢ Current Mode: {% if should_activate and (last_mode == 'cooling' or last_mode == 'heating') %}{{ last_mode|title }}{% if dynamic_enabled and final_escalation_level > 0 %} - ESCALATING L{{ final_escalation_level }} üîº{% elif dynamic_enabled and deescalation_level > 0 %} - DE-ESCALATING L{{ deescalation_level }} üîΩ{% elif dynamic_enabled and current_effectiveness >= 80 %} - EFFECTIVE ({{ current_effectiveness }}%) ‚öñÔ∏è{% endif %}{% elif actual_ac_state == 'off' %}OFF ‚ö´{% elif current_temp >= comfort_min_temp and current_temp <= comfort_max_temp %}IDLE - COMFORT ZONE{% if dynamic_enabled and deescalation_level > 0 %} (DE-ESCALATED L{{ deescalation_level }}) üîΩ{% endif %} ‚úÖ{% elif should_activate %}MONITORING ‚è∏Ô∏è{% else %}STANDBY{% if last_mode != 'off' %} - LAST: {{ last_mode|title }}{% endif %}{% endif %}
          level: warning

mode: restart
